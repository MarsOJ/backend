{"classification": 1, "content": "设栈S和队列Q初始状态均为空，元素abcdefg依次进入栈S中，若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是bdcfeag，则栈S的容量至少是？", "code": "", "answer": ["C"], "explanation": "按顺序取出栈顶元素，模拟一遍即可", "source": "C1002", "subproblem": [{"content": "", "choice": ["1", "2", "3", "4"]}]}
{"classification": 1, "content": "若元素abcdef依次进栈，允许进栈、退栈操作交替进行，但不允许连续三次进行退栈操作，则不可能得到的出栈序列是", "code": "", "answer": ["D"], "explanation": "A：ininininoutoutinoutoutinoutout\nB：inininoutoutinoutoutinoutinout\nC：ininoutinoutoutininoutinoutout", "source": "C1003", "subproblem": [{"content": "", "choice": ["dcebfa", "cbdaef", "bcaefd", "afedcb"]}]}
{"classification": 1, "content": "某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作。若元素abcde依次入此队列后再进行出队操作，则不可能得到的出队序列是", "code": "", "answer": ["C"], "explanation": "简单模拟", "source": "C1004", "subproblem": [{"content": "", "choice": ["bacde", "dbace", "dbcae", "ecbad"]}]}
{"classification": 1, "content": "十进制数23的二进制数是多少？", "code": "", "answer": ["D"], "explanation": "我们可以将23表示为几个不同的2的幂次和，23=16+4+2+1", "source": "C1005", "subproblem": [{"content": "", "choice": ["00010110", "10010111", "10010110", "00010111"]}]}
{"classification": 1, "content": "无符号二进制数10110110的无符号八进制数为多少？", "code": "", "answer": ["B"], "explanation": "(10110110)2可以看成(10 110 100)2，也就是(2 6 6)8。", "source": "C1006", "subproblem": [{"content": "", "choice": ["626", "266", "552", "554"]}]}
{"classification": 1, "content": "无符号二进制数1111的十六进制数为多少？", "code": "", "answer": ["C"], "explanation": "(1111)2 = (15)10 = (F)16", "source": "C1007", "subproblem": [{"content": "", "choice": ["1A", "10", "F", "A"]}]}
{"classification": 1, "content": "无符号二进制数10110101的十六进制数是多少？", "code": "", "answer": ["B"], "explanation": "(10110101)2 = (1011 0101)2 = (B 5)16", "source": "C1008", "subproblem": [{"content": "", "choice": ["AF", "B5", "85", "3F"]}]}
{"classification": 1, "content": "二进制数、八进制数、十进制数、十六进制数分别可以用怎样的方法表示？以下表示正确的是？", "code": "", "answer": ["C"], "explanation": "A中二进制应表示为01B；B中八进制表示0～7，如果为67O是正确的；D中十进制应为1360D。", "source": "C1009", "subproblem": [{"content": "", "choice": ["一个二进制数：01H", "一个八进制数：68O", "一个十六进制数：AAH", "一个十进制数：1360B"]}]}
{"classification": 1, "content": "一个十进制数10.375的二进制表示是多少？", "code": "", "answer": ["C"], "explanation": "(10.375)10 = (8 + 2 + 0.25 + 0.125)10 = (1010.011)", "source": "C1010", "subproblem": [{"content": "", "choice": ["1010.110", "1011.111", "1010.011", "1011.110"]}]}
{"classification": 1, "content": "将无符号十六进制数(1A.C)转换为十进制数。", "code": "", "answer": ["A"], "explanation": "(1A.C)16 = (16 * 1 + 1 * 10 + 12 / 16)10 = 26.75", "source": "C1011", "subproblem": [{"content": "", "choice": ["26.75", "26.875", "11.75", "11.875"]}]}
{"classification": 1, "content": "10位无符号二进制数可以表示的最大十进制数是多少？", "code": "", "answer": ["B"], "explanation": "由于是无符号的10位二进制数，所以最大可以表示的十进制数是2^10 - 1。", "source": "C1012", "subproblem": [{"content": "", "choice": ["1024", "1023", "512", "511"]}]}
{"classification": 1, "content": "有符号二进制原码10011001的十进制数为多少？", "code": "", "answer": ["A"], "explanation": "有符号数的二进制数第一个值代表正负，1代表负数。", "source": "C1013", "subproblem": [{"content": "", "choice": ["-25", "-26", "-24", "-23"]}]}
{"classification": 1, "content": "有符号二进制数01101110的十进制数是多少？", "code": "", "answer": ["B"], "explanation": "有符号二进制数的第一位为符号，0表示正。", "source": "C1014", "subproblem": [{"content": "", "choice": ["108", "110", "-108", "-110"]}]}
{"classification": 1, "content": "一个无符号十进制数N，它最少需要几位无符号二进制数才能表示？", "code": "", "answer": ["D"], "explanation": "由于是无符号二进制数，所以最高位也可以用以表示2的幂次。所以，只需要保证2^x - 1≥N就可以了。", "source": "C1015", "subproblem": [{"content": "", "choice": ["log2(N)向上取整", "log2(N)向上取整+1", "log2(N+1)四舍五入", "log2(N+1)向上取整"]}]}
{"classification": 1, "content": "无符号十进制数N，要将其用有符号二进制数表示，至少需要几位二进制数？", "code": "", "answer": ["B"], "explanation": "因为二进制中有一位为符号位，所以要额外多留一位，最后满足2^(x-1)-1≥N即可。", "source": "C1016", "subproblem": [{"content": "", "choice": ["log2(N+1)向上取整", "log2(N+1)向上取整+1", "log2(N)向上取整+1", "log2(N)向上取整+2"]}]}
{"classification": 1, "content": "以下关于无符号二进制数说法正确的是哪个？", "code": "", "answer": ["A"], "explanation": "C中，如果x为偶数，则2^0=1，应该是x&1==0；D中，如果x能被4整除，应该是x%4==0。", "source": "C1017", "subproblem": [{"content": "", "choice": ["判断十进制数x二进制从小到大第i位(从第0位开始，下同)为0还是1，可以用x&(1<<i)的返回值确定。", "判断十进制数x二进制从小到大第i位(从第0位开始，下同)为0还是1，可以用x&(1<<(i+1))的返回值确定。", "如果十进制数x为偶数，则x&2==0。", "如果十进制数x能被4整除，则x&4==0。"]}]}
{"classification": 1, "content": "(01101011)2等于以下哪个数？", "code": "", "answer": ["D"], "explanation": "二进制转八进制，可以从低位开始，每三位计算，不足则向上补0，二进制转十六进制，可以从低位开始，每四位计算，不足则向上补0.", "source": "C1018", "subproblem": [{"content": "", "choice": ["(5B)16", "(323)8", "(6C)16", "(153)8"]}]}
{"classification": 1, "content": "有符号二进制数01101100的反码是多少？", "code": "", "answer": ["A"], "explanation": "正数的反码就是原码。", "source": "C1019", "subproblem": [{"content": "", "choice": ["01101100", "01101101", "10010011", "10010100"]}]}
{"classification": 1, "content": "有符号二进制数10010001的反码是多少？", "code": "", "answer": ["C"], "explanation": "负数的反码是将原码除符号为以外按位取反。", "source": "C1020", "subproblem": [{"content": "", "choice": ["10010001", "10010010", "11101110", "01101110"]}]}
{"classification": 1, "content": "有符号二进制数11111111的反码是多少？", "code": "", "answer": ["A"], "explanation": "负数的反码，将原码除符号位以外按位取反得到反码。", "source": "C1021", "subproblem": [{"content": "", "choice": ["10000000", "00000000", "11111111", "10000001"]}]}
{"classification": 1, "content": "关于原码、反码、补码，下列说法错误的是？", "code": "", "answer": ["C"], "explanation": "正数的补码是原码，负数的补码是反码加1。", "source": "C1022", "subproblem": [{"content": "", "choice": ["正数的反码就是原码。", "负数的反码是将原码除符号位以外按位取反得到反码。", "任意数的补码是反码加1。", "负数的补码，是将负数的原码从右到左找到第一个1，以此为分界线，右边的0都不变，而左边除符号位按位取反。"]}]}
{"classification": 1, "content": "有符号二进制数00110011的补码是多少？", "code": "", "answer": ["A"], "explanation": "正数的补码是原码。", "source": "C1023", "subproblem": [{"content": "", "choice": ["00110011", "00110100", "01001101", "11001101"]}]}
{"classification": 1, "content": "有符号二进制数10010110的补码是多少？", "code": "", "answer": ["C"], "explanation": "负数的补码等于其反码加1。", "source": "C1024", "subproblem": [{"content": "", "choice": ["10010110", "11101001", "11101010", "01101010"]}]}
{"classification": 1, "content": "求无符号二进制数10010011和01011111的和。", "code": "", "answer": ["B"], "explanation": "可以将其转换为10进制再求和，当然也可以利用加法公式直接求和。", "source": "C1025", "subproblem": [{"content": "", "choice": ["11110011", "11110010", "11110101", "11110110"]}]}
{"classification": 1, "content": "如果在基础运算之中，要求对2^64取模，实际上可以使用哪种整型定义方式进行定义，使得运算需要取模时可以直接自然溢出？", "code": "", "answer": ["B"], "explanation": "unsigned long long的范围刚好时0~2^64-1", "source": "C1026", "subproblem": [{"content": "", "choice": ["unsigned int", "unsigned long long", "long long", "int"]}]}
{"classification": 1, "content": "求二进制数10110011异或01100001的值。", "code": "", "answer": ["A"], "explanation": "异或操作指的是在二进制中对应位，相同为0，不同为1。", "source": "C1027", "subproblem": [{"content": "", "choice": ["11010010", "11110011", "00100001", "11110010"]}]}
{"classification": 1, "content": "计算机软件保护法是用来保护软件（ ）的", "code": "", "answer": ["D"], "explanation": "我国1991年6月4日发布、2001年1月1日修订实施的《计算机软件保护条例》第2条规定：本条例所称计算机软件，是指计算机程序及其有关文档。", "source": "C1028", "subproblem": [{"content": "", "choice": ["编写权", "复制权", "使用权", "著作权"]}]}
{"classification": 1, "content": "微型计算机的问世是由于（ ）的出现", "code": "", "answer": ["C"], "explanation": "计算机发展大致可分为四代：\n第一代，电子管计算机时代；\n第二代，晶体管计算机时代；\n第三代，集成电路计算机时代；\n第四代，大规模和超大规模集成电路计算机时代（1971年至今），其特点：大规模或超大规模集成电路作为逻辑元件和存储器，体积更小，可靠性更高，速度为每秒几千万至数亿次，也直接导致了微型计算机的问世。", "source": "C1029", "subproblem": [{"content": "", "choice": ["中小规模集成电路", "晶体管电路", "（超）大规模集成电路", "电子管电路"]}]}
{"classification": 1, "content": "图灵(Alan Turing)是（ ）", "code": "", "answer": ["B"], "explanation": "艾伦·麦席森·图灵，英国数学家。1931年，图灵进入剑桥大学国王学院，毕业后到美国普林斯顿大学攻读博士学位，二战爆发后回到剑桥，后层协助军方破解德国注明密码系统Enigma，帮助盟军取得了二战胜利。\n图灵对于人工智能的发展有着诸多贡献，例如：图灵曾写过一篇名为《机器会思考吗？》(Can Machine Think?)的论文，其中提出了一种用于判定机器是否具有智能的试验方法，即图灵试验。\n此外，图灵提出的著名图灵机模型为现代计算机的逻辑工作方式奠定了基础。", "source": "C1030", "subproblem": [{"content": "", "choice": ["美国人", "英国人", "德国人", "法国人"]}]}
{"classification": 1, "content": "第一个给计算机写程序的人是（ ）", "code": "", "answer": ["B"], "explanation": "某种意义上，程序设计的出现甚至早于电子计算机的出现。英国著名诗人拜伦的女儿Ada Lovelace曾设计了巴贝奇分析机上解伯努利方程的一个程序。她甚至还建立了循环和子程序的概念。由于她在程序设计上的开创性工作，Ada Lovelace被称为世界上第一位程序员。", "source": "C1031", "subproblem": [{"content": "", "choice": ["Alan Mathison Turing", "Ada Lovelace", "John von Neumann", "Edsger Wybe Dijkstra"]}]}
{"classification": 1, "content": "美籍匈牙利数学家冯·诺依曼对计算机科学发展所做出的贡献是", "code": "", "answer": ["C"], "explanation": "A.图灵提出图灵机\nB.Ada Lovlace是世界上第一位程序员\nC.EDVAC：离散变量自动电子计算机，冯·诺依曼以“关于EDVAC的报告草案”为题，起草了长达101页的总结报告。报告广泛而具体地介绍了制造电子计算机和程序设计的思想。EDVAC方案明确奠定了新机器由五个部分组成，包括：运算器、逻辑控制装置、存储器、输入设备、输出设备，并描述了五个部分的职能和相互关系。\nD.摩尔定律是由英特尔创始人之一戈登·摩尔提出来的。其内容为：当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，其性能也将提升一倍。", "source": "C1032", "subproblem": [{"content": "", "choice": ["提出理想计算机的数学模型，成为计算机科学的理论基础", "是世界上第一个编写计算机程序的人", "提出存储程序工作原理，并设计出第一台具有存储程序功能的计算机EDVAC", "指出计算机性能将以每两年翻一番的速度向前发展"]}]}
{"classification": 1, "content": "彩色显示器所显示的五彩斑斓的色彩，是由红色、蓝色和（ ）色混合而成的。", "code": "", "answer": ["D"], "explanation": "三基色是指红绿蓝三色。人眼对红绿蓝最为敏感，大多数颜色可以从红绿蓝三色按照不同比例合成。同样，绝大多数单色光也可以分解为红绿蓝三种色光。", "source": "C1033", "subproblem": [{"content": "", "choice": ["紫", "白", "黑", "绿"]}]}
{"classification": 1, "content": "在下面各个世界顶级奖项中，为计算机科学与技术领域作出杰出贡献的科学家设立的奖项是", "code": "", "answer": ["D"], "explanation": "沃尔夫奖（人类科学和艺术文明）、诺贝尔奖（生理医学、文字、物理、化学、经济、和平）、菲尔兹奖（数学）、图灵奖（计算机，2000年，姚期智获图灵奖，他是目前获得图灵奖的唯一华裔计算机科学家）", "source": "C1034", "subproblem": [{"content": "", "choice": ["沃尔夫奖", "诺贝尔奖", "菲尔兹奖", "图灵奖"]}]}
{"classification": 1, "content": "IT的含义是", "code": "", "answer": ["B"], "explanation": "IT是Infomation Technology的缩写，指计算机、通信及其相关技术", "source": "C1035", "subproblem": [{"content": "", "choice": ["通信技术", "信息技术", "网络技术", "信息学"]}]}
{"classification": 1, "content": "微机内的存储器地址是以（ ）编址的", "code": "", "answer": ["B"], "explanation": "字长表示一个存储单元由多少位二进制数组成，八位机的一个字长就是一个字节，十六位机的一个字长是两个字节，三十二位机的一个字长可以表示四个字节。字节位的多少，表明可访问的存储器的地址多少。", "source": "C1036", "subproblem": [{"content": "", "choice": ["二进制位", "字长", "字节", "微处理器的型号"]}]}
{"classification": 1, "content": "在外部设备中，绘图仪属于", "code": "", "answer": ["A"], "explanation": "能按照人们要求自动绘制图形的设备，将计算机的输出信息以图形的形式输出", "source": "C1037", "subproblem": [{"content": "", "choice": ["输出设备", "输入设备", "外存储器", "主存储器"]}]}
{"classification": 1, "content": "RAM中的信息是", "code": "", "answer": ["B"], "explanation": "RAM是指随机读写存储器，可对任一存储单元进行读和写，计算机关闭电源后其内部信息将不再保存。", "source": "C1038", "subproblem": [{"content": "", "choice": ["生产厂家预先写入的", "计算机工作时随机写入的", "防止计算机病毒侵入使用的", "专门用于计算机开机时自检用的"]}]}
{"classification": 1, "content": "计算机系统总线上传送的信号有", "code": "", "answer": ["B"], "explanation": "数据总线控制传送数据信号，地址总线控制传送地址信号，控制总线传送控制信号。", "source": "C1039", "subproblem": [{"content": "", "choice": ["地址信号、控制信号", "数据信号、控制信号、地址信号", "控制信号、数据信号", "数据信号、地址信号"]}]}
{"classification": 1, "content": "在计算机硬件系统中，Cache是（ ）存储器", "code": "", "answer": ["D"], "explanation": "cache是高速缓冲存储器的简称", "source": "C1040", "subproblem": [{"content": "", "choice": ["只读", "可编程只读", "可擦除可编程只读", "高速缓冲"]}]}
{"classification": 1, "content": "微型计算机中，（ ）的存取速度最快", "code": "", "answer": ["C"], "explanation": "寄存器>高速缓冲>内存储器>外存储器", "source": "C1041", "subproblem": [{"content": "", "choice": ["高速缓存", "外存储器", "寄存器", "内存储器"]}]}
{"classification": 1, "content": "下列计算机设备中，既是输入设备又是输出设备的是", "code": "", "answer": ["B"], "explanation": "既可以显示数据，又可以接收用户的输入", "source": "C1042", "subproblem": [{"content": "", "choice": ["键盘", "触摸屏", "扫描仪", "投影仪"]}]}
{"classification": 1, "content": "下列哪个不是个人计算机的硬件组成部分", "code": "", "answer": ["B"], "explanation": "虚拟内存指的是用外存（如硬盘）来模拟内存，是一种存储器管理的方式，而不是硬件。", "source": "C1043", "subproblem": [{"content": "", "choice": ["主板", "虚拟内存", "电源", "总线"]}]}
{"classification": 1, "content": "下面哪个部件对个人桌面电脑的正常运行不是必需的", "code": "", "answer": ["C"], "explanation": "光驱是读取光盘的硬件，非必需。", "source": "C1044", "subproblem": [{"content": "", "choice": ["CPU", "显卡", "光驱", "主板"]}]}
{"classification": 1, "content": "下面哪个不是计算机的存储设备", "code": "", "answer": ["A"], "explanation": "文件管理器一般是软件", "source": "C1045", "subproblem": [{"content": "", "choice": ["文件管理器", "内存", "高速缓存", "硬盘"]}]}
{"classification": 1, "content": "下列设备不具有计算功能的是", "code": "", "answer": ["C"], "explanation": "输出设备，没有CPU或者计算元器件", "source": "C1046", "subproblem": [{"content": "", "choice": ["笔记本电脑", "智能手机", "液晶显示器", "电子计算器"]}]}
{"classification": 1, "content": "以下哪个不是计算机的输出设备", "code": "", "answer": ["D"], "explanation": "扫描仪是输入设备", "source": "C1047", "subproblem": [{"content": "", "choice": ["音箱", "显示器", "打印机", "扫描仪"]}]}
{"classification": 1, "content": "以下断电后仍然能保存数据的是", "code": "", "answer": ["B"], "explanation": "ROM是只读存储器，只能读出信息，不能写入信息，计算机关闭电源后信息仍旧保存，一般它用于存储固定的系统软件和字库等", "source": "C1048", "subproblem": [{"content": "", "choice": ["寄存器", "ROM", "RAM", "高速缓冲"]}]}
{"classification": 1, "content": "十六进制数5F1的二进制数是多少？", "code": "", "answer": ["B"], "explanation": "十六进制5的二进制是0101，十六进制F的二进制是1111，十六进制1的二进制数0001，拼起来就是答案了。", "source": "C1049", "subproblem": [{"content": "", "choice": ["010111111000", "010111110001", "000010111111", "010111100001"]}]}
{"classification": 1, "content": "十六进制数59A转换成八进制数是多少？", "code": "", "answer": ["C"], "explanation": "将其转换成二进制数为010110011010，再从低位开始每三位换成八进制数。", "source": "C1050", "subproblem": [{"content": "", "choice": ["1635", "5462", "2632", "2634"]}]}
{"classification": 1, "content": "无符号八进制数626转换成无符号十六进制数是多少？", "code": "", "answer": ["B"], "explanation": "将无符号八进制数转换成二进制数为110010110，也就是(1 1001 0110)2，然后从低位每四位看成十六进制的一部分，拼凑成十六进制数。", "source": "C1051", "subproblem": [{"content": "", "choice": ["CB0", "196", "14B", "AC2"]}]}
{"classification": 1, "content": "十六进制数7A的八进制数是多少？", "code": "", "answer": ["A"], "explanation": "十六进制7A的二进制数为01111010，可以看作为(01 111 010)2，转换成八进制就是(172)8。", "source": "C1052", "subproblem": [{"content": "", "choice": ["172", "362", "364", "361"]}]}
{"classification": 1, "content": "八进制数7742转换成十六进制数是多少？", "code": "", "answer": ["D"], "explanation": "八进制数7742转换成二进制数是111111100010，再转换成十六进制数就是FE2了。", "source": "C1053", "subproblem": [{"content": "", "choice": ["FF4", "FE4", "FF1", "FE2"]}]}
{"classification": 1, "content": "十进制数72转换成七进制数是多少？", "code": "", "answer": ["A"], "explanation": "72 = 49 * 1 + 7 * 3 + 1 * 2。", "source": "C1054", "subproblem": [{"content": "", "choice": ["132", "110", "1020", "102"]}]}
{"classification": 1, "content": "无符号二进制数0110110转换为九进制数是多少？", "code": "", "answer": ["B"], "explanation": "(0110110)2 = (54)10 = 9 * 6 + 1 * 0 = (60)9", "source": "C1055", "subproblem": [{"content": "", "choice": ["59", "60", "58", "61"]}]}
{"classification": 1, "content": "十六进制数26转换成五进制数是多少？", "code": "", "answer": ["C"], "explanation": "(26)16 = (38)10 = 25 * 1 + 5 * 2 + 1 * 3 = (123)5。", "source": "C1056", "subproblem": [{"content": "", "choice": ["101", "52", "123", "111"]}]}
{"classification": 1, "content": "元素abcde依次进入初始为空的栈中，若元素进栈后可停留、可出栈，直到所有元素都出栈，则在所有可能的出栈序列中，以元素d开头的序列个数是", "code": "", "answer": ["B"], "explanation": "decba dceba dcbea dcbae", "source": "C1057", "subproblem": [{"content": "", "choice": ["3", "4", "5", "6"]}]}
{"classification": 1, "content": "一个无符号五进制数423转换为无符号七进制数是多少？", "code": "", "answer": ["A"], "explanation": "(423)5 = (113)10 = 49 * 2 + 14 * 2 + 1 * 1 = (221)7", "source": "C1058", "subproblem": [{"content": "", "choice": ["221", "211", "996", "126"]}]}
{"classification": 1, "content": "已知两个长度分别为m和n的升序链表，若将它们合并为一个长度为m+n的降序链表，则最坏情况下时间复杂度是", "code": "", "answer": ["A"], "explanation": "在合并过程中，最坏情况是两个链表中的元素都要遍历一遍。先用两个指针从表头开始走到两个链表的末尾，花费O(n+m)时间，然后依次比较两个指针所指向的元素，把较大的那个放入新链表中，然后让较大元素对应的的指针后退一个位置，再比较，以此类推直到某个链表已经处理完，最后再把另外一个链表的剩余元素按顺序搬入新链表即可。", "source": "C1059", "subproblem": [{"content": "", "choice": ["O(m+n)", "O(mn)", "O(min(m,n))", "O(max(m,n))"]}]}
{"classification": 1, "content": "一个栈的入栈序列为1,2,3…n，其出栈序列是p1,p2,p3…pn。若p2为3，则p3可能取值的个数是", "code": "", "answer": ["C"], "explanation": "除了3本身以外，其他的值均可以取到", "source": "C1060", "subproblem": [{"content": "", "choice": ["n-3", "n-2", "n-1", "n"]}]}
{"classification": 1, "content": "循环队列放在一维数组A[0…M-1]中，end1指向队头元素，end2指向队尾元素的后一个位置，假设队列两端均可进行入队和出队操作，队列中最多能容纳M-1个元素。初始时为空。下列判断队空和队满的条件中，正确的是", "code": "", "answer": ["A"], "explanation": "队满条件：队尾指针的再下一个位置是队头", "source": "C1061", "subproblem": [{"content": "", "choice": ["队空：end1==end2；队满：end1==(end2+1)%M", "队空：end1==end2；队满：end2==(end1+1)%(M-1)", "队空：end2==(end1+1)%M；队满：end1==(end2+1)%M", "队空：end1==(end2+1)%M；队满：end2==(end1+1)%(M-1)"]}]}
{"classification": 1, "content": "无符号九进制数824转换成无符号六进制数是多少？", "code": "", "answer": ["C"], "explanation": "(824)9 = (670)10 = 216 * 3 + 36 * 0 + 6 * 3 + 1 * 4 = (3034)6", "source": "C1062", "subproblem": [{"content": "", "choice": ["3100", "554", "3034", "545"]}]}
{"classification": 1, "content": "下列关于栈的叙述，错误的是：\n（1）采用非递归方式重写递归程序时必须使用栈\n（2）函数调用时，系统要用栈保存必要的信息\n（3）只要确定了入栈次序，即可确定出栈次序\n（4）栈是一种受限的线性表，允许在其两端进行操作", "code": "", "answer": ["C"], "explanation": "略", "source": "C1064", "subproblem": [{"content": "", "choice": ["(1)", "(1)(2)(3)", "(1)(3)(4)", "(2)(3)(4)"]}]}
{"classification": 1, "content": "现有队列Q和栈S，初始时Q中的元素依次是123456（1在队头），S为空。若仅允许下列3种操作：（1）出队并输出出队元素；（2）出队并将出队元素入栈；（3）出栈并输出出栈元素；则不可能得到的输出序列是", "code": "", "answer": ["C"], "explanation": "模拟即可", "source": "C1065", "subproblem": [{"content": "", "choice": ["125643", "234561", "345612", "654321"]}]}
{"classification": 1, "content": "对空栈S进行Push和Pop操作，入栈序列ABCDE经过Push，Push，Pop，Push，Pop，Push，Push，Pop操作后得到的出栈序列是：", "code": "", "answer": ["D"], "explanation": "略", "source": "C1066", "subproblem": [{"content": "", "choice": ["BAC", "BAE", "BCA", "BCE"]}]}
{"classification": 1, "content": "已知指针指向一个带头结点的非空单循环链表，其中next是指向直接后继结点的指针，h是头指针，p是尾指针，q为临时指针，现要删除该链表的第一个元素，正确的语句序列是", "code": "", "answer": ["D"], "explanation": "要考虑到删除元素之后链表里元素为空的情形，此时head->next=tail", "source": "C1067", "subproblem": [{"content": "", "choice": ["h->next=h-next->next; q=h->next; free(q);", "q=h->next; h->next=h->next->next; free(q);", "q=h->next; h->next=q->next; if(p!=q)p=h; free(q);", "q=h->next; h->next=q->next; if(p==q)p=h; free(q);"]}]}
{"classification": 1, "content": "已知初始为空的队列Q的一端能进行入队操作又能进行出队操作，另一端只能进行入队操作，若入队序列是12345，则不能得到的出队序列是", "code": "", "answer": ["D"], "explanation": "模拟即可", "source": "C1068", "subproblem": [{"content": "", "choice": ["54312", "53124", "42135", "41325"]}]}
{"classification": 1, "content": "六个元素654321从左到右依次顺序进栈，在进栈过程中会有元素被弹出栈。问下列哪一个不可能是合法的出栈序列？", "code": "", "answer": ["C"], "explanation": "注意入栈顺序是6~1", "source": "C1069", "subproblem": [{"content": "", "choice": ["543612", "453126", "346521", "234156"]}]}
{"classification": 1, "content": "深度优先搜索时，需要用到的数据结构是", "code": "", "answer": ["C"], "explanation": "略", "source": "C1070", "subproblem": [{"content": "", "choice": ["链表", "队列", "栈", "散列表"]}]}
{"classification": 1, "content": "什么是一种先进先出的线性表", "code": "", "answer": ["B"], "explanation": "略", "source": "C1071", "subproblem": [{"content": "", "choice": ["栈", "队列", "哈希表（散列表）", "二叉树"]}]}
{"classification": 1, "content": "如果一个栈初始时为空，且当前栈中的元素从栈顶到栈底依次为abc，另有元素d已经出栈，则可能的入栈顺序是", "code": "", "answer": ["D"], "explanation": "模拟即可", "source": "C1072", "subproblem": [{"content": "", "choice": ["adcb", "bacd", "acbd", "dcba"]}]}
{"classification": 1, "content": "链表不具备的特点是", "code": "", "answer": ["A"], "explanation": "基本概念", "source": "C1073", "subproblem": [{"content": "", "choice": ["可随机访问任一元素", "不必事先估计存储空间", "所需空间与线性表长度成正比", "插入删除时不需要移动元素"]}]}
{"classification": 1, "content": "线性表若采用链表存储结构，要求内存中可用存储单位地址", "code": "", "answer": ["C"], "explanation": "D是一本正经的胡说八道", "source": "C1074", "subproblem": [{"content": "", "choice": ["必须不连续", "必须连续", "连续不连续均可", "前3个元素必须连续，后面的元素连续不连续均可"]}]}
{"classification": 1, "content": "有一空栈S，对下列待进栈的数据元素序列123456依次进行进栈、出栈、进栈、出栈、进栈操作，则栈S的栈顶元素为", "code": "", "answer": ["B"], "explanation": "模拟即可", "source": "C1075", "subproblem": [{"content": "", "choice": ["6", "3", "1", "2"]}]}
{"classification": 1, "content": "一张32位的像素为1024*2048的图片，占用多大的空间", "code": "", "answer": ["C"], "explanation": "选C 图片大小为32*1024*2048bit，也即32*1024*2048/8/1024/1024MB=8MB", "source": "C1076", "subproblem": [{"content": "", "choice": ["64GB", "8GB ", "8MB", "64MB"]}]}
{"classification": 1, "content": "无符号三进制数201转换成无符号二进制数是多少？", "code": "", "answer": ["C"], "explanation": "(201)3 = (19)10 = (16 + 2 + 1) = (10011)2", "source": "C1077", "subproblem": [{"content": "", "choice": ["2011", "2021", "10011", "10010"]}]}
{"classification": 1, "content": "无符号二进制数1011转换成无符号三进制数是多少？", "code": "", "answer": ["A"], "explanation": "(1011)2 = (11)10 = (9 + 1 * 2) = (102)3", "source": "C1078", "subproblem": [{"content": "", "choice": ["102", "101", "1001", "100"]}]}
{"classification": 1, "content": "十进制数986转换成15进制数是多少？", "code": "", "answer": ["B"], "explanation": "(986)10 = (225 * 4 + 15 * 5 + 1 * 11) = (45B)15。", "source": "C1079", "subproblem": [{"content": "", "choice": ["54A", "45B", "543", "45A"]}]}
{"classification": 1, "content": "无符号十五进制数EA转换成无符号十六进制数是多少？", "code": "", "answer": ["C"], "explanation": "(EA)15 = (220)10 = (16 * 13 + 1 * 12) = (DC)16", "source": "C1080", "subproblem": [{"content": "", "choice": ["EA", "E9", "DC", "DD"]}]}
{"classification": 1, "content": "有符号二进制数1011转换成十进制数是多少？", "code": "", "answer": ["C"], "explanation": "第一位是符号位，说明该数为负数，负数的二进制为它的补码，所以为C。", "source": "C1081", "subproblem": [{"content": "", "choice": ["-3", "3", "-5", "5"]}]}
{"classification": 1, "content": "有符号二进制数0011转换成十进制数是多少？", "code": "", "answer": ["C"], "explanation": "符号位是0，表示正数，所以转换成十进制是3。", "source": "C1082", "subproblem": [{"content": "", "choice": ["-3", "-2", "3", "-4"]}]}
{"classification": 1, "content": "十进制数-11转换成有符号二进制数是多少？", "code": "", "answer": ["D"], "explanation": "负数的二进制是将该十进制数求绝对值之后转成补码后的答案。", "source": "C1083", "subproblem": [{"content": "", "choice": ["10001011", "10001100", "00001011", "11110101"]}]}
{"classification": 1, "content": "开一个int类型的数组a[400][400]使用了多少内存？", "code": "", "answer": ["A"], "explanation": "一个int型占用的空间为4B，开了400 * 400个，所以使用的内存为4 * 400 * 400B = 4 * 400 * 400 / 1024KB=625KB。", "source": "C1084", "subproblem": [{"content": "", "choice": ["625KB", "160000B", "640KB", "0.64MB"]}]}
{"classification": 1, "content": "一个long long型的变量占用多少内存？", "code": "", "answer": ["D"], "explanation": "一个long long类型占用的内存是8B，sizeof(long long)==8。", "source": "C1085", "subproblem": [{"content": "", "choice": ["2B", "4B", "6B", "8B"]}]}
{"classification": 1, "content": "一个unsigned long long定义的变量占用多少内存？", "code": "", "answer": ["B"], "explanation": "unsigned long long与long long能表示的范围长度一样，所以均为8个字节。", "source": "C1086", "subproblem": [{"content": "", "choice": ["4B", "8B", "16B", "32B"]}]}
{"classification": 1, "content": "定义一个unsigned int类型的变量，使用了多少内存？", "code": "", "answer": ["C"], "explanation": "与int使用内存大小一样，unsigned只是将最高位变成了符号位。", "source": "C1087", "subproblem": [{"content": "", "choice": ["1B", "2B", "4B", "8B"]}]}
{"classification": 1, "content": "一个short int类型的变量，占用了多少内存？", "code": "", "answer": ["B"], "explanation": "一个short int类型的变量占用2个字节，2B=16b。", "source": "C1088", "subproblem": [{"content": "", "choice": ["1B", "2B", "4B", "8b"]}]}
{"classification": 1, "content": "在64位编译器下，定义一个long int类型的变量占用多少内存？", "code": "", "answer": ["C"], "explanation": "在64位编译器下，定义一个long int类型的变量占用8个字节。", "source": "C1089", "subproblem": [{"content": "", "choice": ["2B", "4B", "8B", "16B"]}]}
{"classification": 1, "content": "在32位编译器下，定义一个long int类型的变量占用多少内存？", "code": "", "answer": ["B"], "explanation": "在32位编译器下，定义一个long int类型的变量占用4个字节。", "source": "C1090", "subproblem": [{"content": "", "choice": ["2B", "4B", "8B", "16B"]}]}
{"classification": 1, "content": "定义一个char类型的变量，占用了多少内存？", "code": "", "answer": ["A"], "explanation": "一个char类型的变量，占用1个字节。", "source": "C1091", "subproblem": [{"content": "", "choice": ["1B", "2B", "3B", "4B"]}]}
{"classification": 1, "content": "定义一个bool类型的变量，占用多少内存？", "code": "", "answer": ["C"], "explanation": "bool变量占用了 1 个字节的内存，当值为false的时候，实际上存储的是0x00，为ture时实际上存储的是0x01。", "source": "C1092", "subproblem": [{"content": "", "choice": ["1b", "2b", "1B", "2B"]}]}
{"classification": 1, "content": "关于堆的内存申请，以下说法正确的是？", "code": "", "answer": ["B"], "explanation": "在C++语言中，可以使用new函数申请内存，并且当使用完之后，利用delete函数释放。", "source": "C1093", "subproblem": [{"content": "", "choice": ["在C语言中，可以使用malloc函数申请内存，并且当使用完之后，利用delete函数释放。", "在C语言中，可以使用malloc函数申请内存，并且当使用完之后，利用free函数释放。", "在C++语言中，可以使用new函数申请内存，并且当使用完之后，利用free函数释放。", "以上说法均不正确。"]}]}
{"classification": 1, "content": "利用计算机来模仿人的高级思维活动称为（）。", "code": "", "answer": ["B"], "explanation": "人工智能", "source": "C1094", "subproblem": [{"content": "", "choice": ["并行计算", "人工智能", "自动控制", "计算机辅助系统"]}]}
{"classification": 1, "content": "关于空间关系中，下列说法正确的是？", "code": "", "answer": ["A"], "explanation": "数组的空间是连续的。回收内存时，栈的空间是连续的，所以不会产生碎片。堆由于是链式存储的，所以会产生碎片。", "source": "C1095", "subproblem": [{"content": "", "choice": ["使用任意类型定义一个数组，数组中的元素位置是连续的。", "回收内存时，栈的空间是不连续的，会产生碎片。", "回收内存时，堆由于是连续存储的，所以不会产生碎片。", "以上说法均不对"]}]}
{"classification": 1, "content": "现有一张分辨率为 1024*1024 像素的 32 位真彩色图像。请问要存储这张图像，需要多大的存储空间？（ ）", "code": "", "answer": ["B"], "explanation": "一共需要的空间为1024*1024*32，一共为2^25bit，所以为2^5Mbit也就是4MB", "source": "C1096", "subproblem": [{"content": "", "choice": ["16MB", "4MB", "8MB", "32MB"]}]}
{"classification": 1, "content": "组成计算机主机的主要是（）。", "code": "", "answer": ["D"], "explanation": "中央处理器和主存储器是构成计算机主机的主要部分", "source": "C1097", "subproblem": [{"content": "", "choice": ["外设", "主板", "运算器和存储器", "中央处理器和主存储器"]}]}
{"classification": 1, "content": "指令的操作码表示的是（）。", "code": "", "answer": ["D"], "explanation": "指令的操作码代表的是指令做什么操作", "source": "C1098", "subproblem": [{"content": "", "choice": ["停止操作", "操作结构", "操作地址", "做什么操作"]}]}
{"classification": 1, "content": "计算机指令是由什么组成的（）。", "code": "", "answer": ["D"], "explanation": "计算机指令由操作码和地址码构成", "source": "C1459", "subproblem": [{"content": "", "choice": ["指令码和操作码", "操作数和地址码", "指令寄存器和地址寄存器 ", "操作码和地址码"]}]}
{"classification": 1, "content": "一个长度为10000的字符串至少需要用多少内存的char数组才能存下？", "code": "", "answer": ["A"], "explanation": "一个char类型的变量占用1B内存，一个长度为10000的数组，至少需要用10000B。", "source": "C1099", "subproblem": [{"content": "", "choice": ["10000B", "20000B", "10KB", "1MB"]}]}
{"classification": 1, "content": "题目要求你输入一个N*N的矩阵，保证矩阵中的每个数都在int范围以内，现在要求对矩阵中的每个数都乘以一个int范围以内的整数并输出，请问需要多少内存？", "code": "", "answer": ["C"], "explanation": "int乘以int有可能超过int的范围，但是一定不会超过long long的范围，所以我们可以直接使用long long来进行表示。", "source": "C1100", "subproblem": [{"content": "", "choice": ["(4*N*N) B", "(N*N) B", "(8*N*N) B", "(2 * N * N) B"]}]}
{"classification": 1, "content": "需要存储一个32位变量，需要至少使用多少内存空间？", "code": "", "answer": ["A"], "explanation": "1B = 8b，一个32位变量，需要32b进行存储，也就是需要4B内存。", "source": "C1101", "subproblem": [{"content": "", "choice": ["4B", "4b", "8b", "32B"]}]}
{"classification": 1, "content": "关于以下代码的输出值说法，正确的是？", "code": "printf(\"%lu\\n\", sizeof(char[100]));", "answer": ["A"], "explanation": "输出的值为char类型数组占用了多少字节。", "source": "C1102", "subproblem": [{"content": "", "choice": ["输出的值为100。", "输出的值为200。", "输出的值为char类型数组占用了多少位。", "输出的值为char类型变量占用了多少字节。"]}]}
{"classification": 1, "content": "关于位、字节、KB、MB，以下说法正确的是？", "code": "", "answer": ["D"], "explanation": "1B = 8b; 1 KB = 1024 B;  1 MB = 1024 KB", "source": "C1103", "subproblem": [{"content": "", "choice": ["1 b = 8 B", "1 Kb = 1024 B", "1 MB = 1024 B", "1 MB = 1024 KB"]}]}
{"classification": 1, "content": "一个int类型的变量占用了多少位的内存？", "code": "", "answer": ["D"], "explanation": "一个int类型的变量占用了32位的内存，等于占用了4字节的内存。", "source": "C1104", "subproblem": [{"content": "", "choice": ["4", "8", "16", "32"]}]}
{"classification": 1, "content": "众所周知，在信息学竞赛中，常常会遇到定义变量类型的范围不够的情况，现在有一种叫做__int128的定义变量的方式，已知__int128可以定义128位的变量，请问用它定义一个变量使用了多少内存？", "code": "", "answer": ["B"], "explanation": "128 b = 16 B，1 B = 8 b。", "source": "C1105", "subproblem": [{"content": "", "choice": ["128B", "16B", "8B", "4B"]}]}
{"classification": 1, "content": "如果有一个有符号的正数，定义该变量使用了x位的内存，但是如果我们提前知道它是个正数，我们至少可以使用多少位的内存来保证该数在数据范围以内呢？", "code": "", "answer": ["C"], "explanation": "因为知道是正数，所以就不需要考虑符号位了，所以直接使用(x - 1) b就可以了。", "source": "C1106", "subproblem": [{"content": "", "choice": ["x", "x + 1", "x - 1", "x / 2"]}]}
{"classification": 1, "content": "我们需要对一系列数做加、减、乘、整除和取模运算，模数固定且为32位整数，现在我们至少使用多大内存的变量类型才能保证以上运算不会出现数据溢出的情况？", "code": "", "answer": ["B"], "explanation": "因为存在乘法操作，所以得对两个32位的数进行相乘，两个32位数的相乘不会超过64位，所以我们只需要一个64位整数就可以了。64b = 8B", "source": "C1107", "subproblem": [{"content": "", "choice": ["4B", "8B", "48b", "32b"]}]}
{"classification": 1, "content": "如下代码所示，我们定义并使用了如下数组，大概使用了多少内存？", "code": "const int maxN = 1e6;\nint a[maxN];", "answer": ["A"], "explanation": "使用的内存大致为：1000000 * 4 / 1024 / 1024 MB ≈ 4MB", "source": "C1108", "subproblem": [{"content": "", "choice": ["4 MB", "3 MB", "2 MB", "1 MB"]}]}
{"classification": 1, "content": "如下代码所示，该程序定义并使用了以下数组，大致使用了多少内存？", "code": "const int maxN = 1e7;\nbool flag[maxN];", "answer": ["A"], "explanation": "一个bool类型占用1个字节，所以使用的内存大致为：10000000 / 1024 / 1024 MB ≈ 10 MB。", "source": "C1109", "subproblem": [{"content": "", "choice": ["10 MB", "8 MB", "20 MB", "40 MB"]}]}
{"classification": 1, "content": "如下代码所示，定义并使用了数组a和数组b，请问大致使用了多少内存？", "code": "const int maxN = 1e5, maxM = 1e6;\nlong long a[maxN];\nint b[maxM];", "answer": ["C"], "explanation": "一个long long类型占用了8个字节，一个int类型占用了4个字节，然后再根据数组大小，乘起来后加起来就可以了。", "source": "C1110", "subproblem": [{"content": "", "choice": ["12 MB", "7 MB", "4.5 MB", "6 MB"]}]}
{"classification": 1, "content": "我们知道long long类型使用8个字节，也就是64位；现在，我们想知道去掉了long long的符号位的unsigned long long占用多少内存呢？", "code": "", "answer": ["A"], "explanation": "unsigned long long只是将long long的符号位变成了记录数的值的数位而已，并不代表将符号位“去掉”了。", "source": "C1111", "subproblem": [{"content": "", "choice": ["8 B", "63 b", "65 b", "7 B"]}]}
{"classification": 1, "content": "如下代码所示，定义并使用了数组x，请问大致使用了多少内存？", "code": "struct node\n{\n    int a[100][100];\n    node() { memset(a, 0, sizeof(a)); }\n};\nnode x[10];", "answer": ["A"], "explanation": "一个结构体node使用的内存为40 KB，现在定义了10个node结构体，所以使用了的内存大致为400 KB。", "source": "C1112", "subproblem": [{"content": "", "choice": ["400 KB", "100 KB", "40 KB", "10 KB"]}]}
{"classification": 1, "content": "代码如下所示，请问此时会发生什么情况？", "code": "int x[10] = {0};\nx[1] = 1;\nx[10] = 1000000;", "answer": ["C"], "explanation": "数组下标是从0开始的，所以最多表示到x[9]。", "source": "C1113", "subproblem": [{"content": "", "choice": ["int范围不够，x[10]存不下1000000。", "使用内存过多，内存不够。", "数组越界，没法使用x[10]。", "会正常的执行程序。"]}]}
{"classification": 1, "content": "冯·诺依曼结构计算机的五大基本构件包括存储器、输入设备、输出设备、控制器（）。", "code": "", "answer": ["A"], "explanation": "冯·诺依曼结构计算机的五大基本构件包括存储器、输入设备、输出设备、控制器和运算器", "source": "C1114", "subproblem": [{"content": "", "choice": ["运算器", "显示器", "鼠标", "硬盘控制器"]}]}
{"classification": 1, "content": "冯·诺依曼结构计算机的五大基本构件包括存储器、输入设备、输出设备、控制器（）。", "code": "", "answer": ["A"], "explanation": "冯·诺依曼结构计算机的五大基本构件包括存储器、输入设备、输出设备、控制器和运算器", "source": "C1115", "subproblem": [{"content": "", "choice": ["运算器", "显示器", "鼠标", "硬盘控制器"]}]}
{"classification": 1, "content": "打印机是计算机的输出图形的输出设备，同属于输出设备的还有（）。", "code": "", "answer": ["B"], "explanation": "键盘扫描仪和鼠标都属于输入设备", "source": "C1116", "subproblem": [{"content": "", "choice": ["键盘", "显示器", "扫描仪", "鼠标"]}]}
{"classification": 1, "content": "计算机的主频即计算机的时钟频率，较高的主频用吉赫来表示，其英文缩写是（）。", "code": "", "answer": ["C"], "explanation": "吉赫的缩写是GHz", "source": "C1117", "subproblem": [{"content": "", "choice": ["MHz", "KHz", "GHz", "GDP"]}]}
{"classification": 1, "content": "计算机的字长是它的主要性能指标之一。主要性能指标还包括下列四项中的（）。", "code": "", "answer": ["D"], "explanation": "一般情况下CPU主频越高处理文件的速度越快", "source": "C1118", "subproblem": [{"content": "", "choice": ["有无鼠标和键盘", "有无喷墨打印机", "有无绘图功能", "主频"]}]}
{"classification": 1, "content": "下面不属于计算机安全要解决的问题是（）。", "code": "", "answer": ["D"], "explanation": "操作人员人身的安全保证不属于计算机安全要解决的问题", "source": "C1119", "subproblem": [{"content": "", "choice": ["安全技术", "安全法规的建立", "设计保护用户隐私的软件", "操作员人身安全的保证"]}]}
{"classification": 1, "content": "以下设备中，不属于音频设备的是（）。", "code": "", "answer": ["D"], "explanation": "显示屏不属于音频设备，属于输出设备", "source": "C1120", "subproblem": [{"content": "", "choice": ["声卡", "话筒", "音箱", "显示屏"]}]}
{"classification": 1, "content": "用于解析域名的协议是（）。", "code": "", "answer": ["D"], "explanation": "HTTPS和HTTP协议是网络通信协议，FTP是文件传输协议", "source": "C1121", "subproblem": [{"content": "", "choice": ["HTTP", "HTTPS", "FTP", "DNS"]}]}
{"classification": 1, "content": "计算机网络按使用范围划分为（）。", "code": "", "answer": ["A"], "explanation": "计算机网络按使用范围分为广域网和局域网", "source": "C1122", "subproblem": [{"content": "", "choice": ["广域网 局域网", "专用网 公用网", "低速网 高速网", "军用网 民用网"]}]}
{"classification": 1, "content": "复旦大学和上海交通大学的网站分别为www.fudan.edu.cn和www.sjtu.edu.cn，以下说法不正确的是（）。", "code": "", "answer": ["C"], "explanation": "两个网站的IP地址不同", "source": "C1123", "subproblem": [{"content": "", "choice": ["它们都属于中国教育网", "它们都提供www服务", "它们使用的IP地址相同", "它们分别属于两个学校的门户网站"]}]}
{"classification": 1, "content": "计算机可分为数字计算机、模拟计算机和混合计算机，这种分类的依据是计算机的（）。", "code": "", "answer": ["C"], "explanation": " 处理数据的方式是计算机可分为数字计算机、模拟计算机和混合计算机的依据", "source": "C1124", "subproblem": [{"content": "", "choice": ["功能", "性能", "处理数据的方式", "价格"]}]}
{"classification": 1, "content": "以下不属于电子数字计算机特点的是（）。", "code": "", "answer": ["C"], "explanation": "电子数字计算机形状并不粗笨", "source": "C1125", "subproblem": [{"content": "", "choice": ["运算快速", "计算精度高", "形状粗笨", "通用性强"]}]}
{"classification": 1, "content": "在微型计算机的各种设备中，既用于输入又可用于输出的设备是（）。", "code": "", "answer": ["D"], "explanation": "鼠标和键盘只能做输入设备，投影仪只能做输出设备", "source": "C1126", "subproblem": [{"content": "", "choice": ["键盘", "鼠标", "投影仪", "磁盘驱动器"]}]}
{"classification": 1, "content": "在 Internet 上收发 E-mail 的协议不包括（）。", "code": "", "answer": ["D"], "explanation": "ARP协议是根据IP地址获取物理地址的一个TCP/IP协议", "source": "C1127", "subproblem": [{"content": "", "choice": ["SMTP", "POP3", "IMAP", "ARP"]}]}
{"classification": 1, "content": "无符号二进制数10001001所表示的十进制数是（）", "code": "", "answer": ["A"], "explanation": "无符号二进制数的每一位都是数值位，即无符号二进制数10001001=1×128+1×8+1×1=127", "source": "C1128", "subproblem": [{"content": "", "choice": ["137", "-137", "9", "-9"]}]}
{"classification": 1, "content": "有符号二进制数10001001所表示的十进制数是（）", "code": "", "answer": ["D"], "explanation": "有符号二进制数左边第一位是符号位，符号位用0表示“正”，用1表示“负”。所以有符号二进制数10001001=-(1×8+1×1)=-9", "source": "C1129", "subproblem": [{"content": "", "choice": ["137", "-137", "9", "-9"]}]}
{"classification": 1, "content": "原码是有符号数的最简单的编码方式，8 位二进制原码的表示范围是（）。", "code": "", "answer": ["B"], "explanation": "原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1，其余位表示数值的大小。所以8 位二进制原码的能表示的最大最小值分别为(+11111111)2=+127、( -11111111)2=-127", "source": "C1130", "subproblem": [{"content": "", "choice": ["-128 ~ +128", "-127 ~ +127", "-127 ~ +128", "-128 ~ +127"]}]}
{"classification": 1, "content": "下列有关原码、反码、补码说法错误的是（）。", "code": "", "answer": ["B"], "explanation": "8位二进制原码的表示范围：-127～+127；\n8位二进制反码的表示范围：-127～+127；\n8位二进制补码的表示范围：-128～+127。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t（在补码中用(-128)代替了(-0)，所以补码的表示范围为：(-128~0~127)共256个）\n", "source": "C1131", "subproblem": [{"content": "", "choice": ["8位二进制原码的表示范围为：-127～+127", "8位二进制反码的表示范围为：-128～+127", "8位二进制补码的表示范围为：-128～+127", "8位二进制反码的表示范围为：-127～+127"]}]}
{"classification": 1, "content": "在有关整数的补码表示法中，以下说法正确的是（）。", "code": "", "answer": ["C"], "explanation": "A、8位二进制补码的表示范围：-128～+127，A错；B、用负数的原码求补码，应保持符号位不变，B错；C、正整数的补码是其二进制表示，与原码相同；D、\n[-0]补=11111111+1=00000000=[+0]原=[+0]补，D错。\n", "source": "C1132", "subproblem": [{"content": "", "choice": ["8位二进制补码的表示范围为：-127～+128", "负数的补码为对该数的原码的各位取反，然后在最后一位加1", "X为正整数时，[X]原=[X]补", "补码系统的整数 0 有两种表示方式"]}]}
{"classification": 1, "content": "下列说法错误的是（）。", "code": "", "answer": ["C"], "explanation": "正整数的原码、补码、反码表示方法均相同；负整数的反码等于对该数的原码除符号位外各位取反，C错。", "source": "C1133", "subproblem": [{"content": "", "choice": ["对补码再求一次补码就为真值的原码", "[ -0]补= [+0]补=[+0]反=[+0]原", "一个整数的反码等于对该数的原码除符号位外各位取反", "整数 0 反码的表示形式有两种"]}]}
{"classification": 1, "content": "下列说法错误的是（）。", "code": "", "answer": ["B"], "explanation": "以8位机器数为例，整数的“+0”原码为00000000，反码为00000000；整数的“-0”原码为10000000，反码为11111111，B错。", "source": "C1134", "subproblem": [{"content": "", "choice": ["采用补码进行运算，所得结果仍为补码", "在整数的反码表示法中，只有负整数的编码最高位为1", "正整数的反码和补码都与原码相同", "负整数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1"]}]}
{"classification": 1, "content": "已知一个 8 位二进制数的补码为11111001，则这个数的原码是（ ）。", "code": "", "answer": ["D"], "explanation": "对于负数，由补码求原码：方法一、对补码再求一次补码就为真值的原码，即[[x]补]补=[x]原；方法二、或者进行逆运算，将补码数值部分减一后按位取反。", "source": "C1135", "subproblem": [{"content": "", "choice": ["11111001", "10000110", "00000110", "10000111"]}]}
{"classification": 1, "content": "已知一个 8 位二进制数的原码为11111001，则这个数的补码是（ ）。", "code": "", "answer": ["A"], "explanation": "11111001符号位为1，表示该数为负数，求负整数的补码：将其原码除符号位外的所有位取反后加1。", "source": "C1136", "subproblem": [{"content": "", "choice": ["10000111", "10000101", "01111001", "00000111"]}]}
{"classification": 1, "content": "已知一个 8 位二进制数的原码为11111001，则这个数的反码是（ ）。", "code": "", "answer": ["A"], "explanation": "负整数的反码等于对该数的原码除符号位外各位取反。", "source": "C1137", "subproblem": [{"content": "", "choice": ["10000110", "10000111", "10000101", "11111001"]}]}
{"classification": 1, "content": "一个字长为 16 位的整数的补码是11111111 11100110，其对应的十进制数应该是（）。", "code": "", "answer": ["B"], "explanation": "该负整数的原码=[11111111 11100110]补=(10000000 00011010)2=-(1×16+1×8+1×2)=-26", "source": "C1138", "subproblem": [{"content": "", "choice": ["-25", "-26", "25", "26"]}]}
{"classification": 1, "content": "十进制数 -15 的 16 位二进制补码表示为（）。", "code": "", "answer": ["D"], "explanation": "-15的16位二进制原码为(10000000 00001111)2，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1，即得补码。", "source": "C1139", "subproblem": [{"content": "", "choice": ["0000000011110001", "1000000001110001", "1000000011110001", "1111111111110001"]}]}
{"classification": 1, "content": "二进制数 00100101 和 00011010 的和是（ ）。", "code": "", "answer": ["B"], "explanation": "二进制数的加法运算法则:0+0=0,0+1=1 ,1+0=1, 1+1=10(向高位进位) ，所以(00100101)2+(00011010)2=(00111111)2。", "source": "C1140", "subproblem": [{"content": "", "choice": ["01111111", "00111111", "00110111", "00101111"]}]}
{"classification": 1, "content": "下列各十进制整数中，8 位二进制补码能表示的最大的数是（ ）。", "code": "", "answer": ["A"], "explanation": "8 位二进制补码能表示的最大的数（正整数）是01111111，即127。", "source": "C1141", "subproblem": [{"content": "", "choice": ["127", "128", "255", "256"]}]}
{"classification": 1, "content": "我们用 8 位二进制数表示一个数，则 -65的补码为（）。", "code": "", "answer": ["C"], "explanation": "-65的原码为(11000001)2，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1，即得补码。", "source": "C1142", "subproblem": [{"content": "", "choice": ["10111110", "00111110", "10111111", "00111111"]}]}
{"classification": 1, "content": "我们用 8 位二进制数表示一个数，则 +14 的反码为（）。", "code": "", "answer": ["A"], "explanation": "由于正数的原码、补码、反码表示方法均相同，不需转换。所以 [+14]反=[ +14]原=00001110", "source": "C1143", "subproblem": [{"content": "", "choice": ["00001110", "10001010", "00001010", "00001100"]}]}
{"classification": 1, "content": "对于正数，其原码、反码（）；对于负数，其原码、反码（）。", "code": "", "answer": ["B"], "explanation": "正数的原码、补码、反码表示方法均相同，负数的反码等于对该数的原码除符号位外各位取反。", "source": "C1144", "subproblem": [{"content": "", "choice": ["一致、一致", "一致、不一致", "不一致、一致", "不一致、不一致"]}]}
{"classification": 1, "content": "在8位二进制补码中，00011011表示的数是十进制下的（）。", "code": "", "answer": ["B"], "explanation": "根据补码求十进制：方法一、先求出该数的原码，即[00011011]补=00011011，然后根据原码求十进制。方法二、将补码各位按权值展开，即1×16+1×8+1×2+1×1=27(若首位为1，应加上-128)。", "source": "C1145", "subproblem": [{"content": "", "choice": ["26", "27", "31", "25"]}]}
{"classification": 1, "content": "在8位二进制补码中，10000000表示的数是十进制下的（）。", "code": "", "answer": ["D"], "explanation": "-1×2^7＝-128", "source": "C1146", "subproblem": [{"content": "", "choice": ["127", "-127", "128", "-128"]}]}
{"classification": 1, "content": "在8位二进制反码中，10000000表示的数是十进制下的（）。", "code": "", "answer": ["B"], "explanation": "该数的补码为10000001，转化为十进制为-1×2^7＋1×2^0＝-127;或者通过该原码11111111计算，原码首尾为“1”表示负数，所以该数转化为十进制为-(1×2^6＋1×2^5＋1×2^4＋1×2^3＋1×2^2＋1×2^1＋1×2^0)＝-(64＋32＋16＋8＋4＋2＋1)＝-127", "source": "C1147", "subproblem": [{"content": "", "choice": ["127", "-127", "128", "-128"]}]}
{"classification": 1, "content": "在8位二进制原码中，11111111表示的数是十进制下的（）。", "code": "", "answer": ["B"], "explanation": "原码首尾为“1”表示负数，所以该数转化为十进制为-(1×2^6＋1×2^5＋1×2^4＋1×2^3＋1×2^2＋1×2^1＋1×2^0)＝-(64＋32＋16＋8＋4＋2＋1)＝-127", "source": "C1148", "subproblem": [{"content": "", "choice": ["127", "-127", "128", "-128"]}]}
{"classification": 1, "content": "已知 8 位机器码是10001011，若其为补码，则其表示的十进制真值是（）。", "code": "", "answer": ["A"], "explanation": "先求出该数的原码，即[10001011]补=11110101，然后根据原码求十进制", "source": "C1149", "subproblem": [{"content": "", "choice": ["-117", "-11", "-116", "11"]}]}
{"classification": 1, "content": "已知 8 位机器码是10001011，若其为原码，则其对应的补码是（）。", "code": "", "answer": ["C"], "explanation": "求负整数的补码：将其原码除符号位外的所有位取反后加1。", "source": "C1150", "subproblem": [{"content": "", "choice": ["11110100", "10001011", "11110101", "11110011"]}]}
{"classification": 1, "content": "已知 8 位机器码是10011010，若其为反码，则其对应的补码是（）。", "code": "", "answer": ["A"], "explanation": "负整数的反码等于对该数的原码除符号位外各位取反，负整数的补码等于对该数的原码除符号位外各位取反后加1，所以补码可由反码加1得来。", "source": "C1151", "subproblem": [{"content": "", "choice": ["10011011", "11100101", "11100110", "10011010"]}]}
{"classification": 1, "content": "已知[X]补=00111001，求X（真值）（）。", "code": "", "answer": ["C"], "explanation": "对补码再求一次补码就为真值的原码，即[[x]补]补=[x]原=00111001", "source": "C1152", "subproblem": [{"content": "", "choice": ["-0111001", "-1000110", "+0111001", "+1000110"]}]}
{"classification": 1, "content": "已知[X]补=10111001，求[X]原（）。", "code": "", "answer": ["C"], "explanation": "对补码再求一次补码就为真值的原码，即[[x]补]补=[x]原=11000111", "source": "C1153", "subproblem": [{"content": "", "choice": ["11000101", "11000110", "11000111", "10111010"]}]}
{"classification": 1, "content": "已知[X]补=00101001，求[X]反（）。", "code": "", "answer": ["A"], "explanation": "正数的原码、补码、反码表示方法均相同。", "source": "C1154", "subproblem": [{"content": "", "choice": ["00101001", "00101010", "00101011", "00101000"]}]}
{"classification": 1, "content": "已知[X]原=00001101，求[X]反（）。", "code": "", "answer": ["D"], "explanation": "正数的原码、补码、反码表示方法均相同。", "source": "C1155", "subproblem": [{"content": "", "choice": ["01110010", "00001110", "00001110", "00001101"]}]}
{"classification": 1, "content": "已知[X]反=10111001，求[X]原（）。", "code": "", "answer": ["B"], "explanation": "负整数的反码等于对该数的原码除符号位外各位取反，反之负整数的原码等于对该数的反码除符号位外各位取反。", "source": "C1156", "subproblem": [{"content": "", "choice": ["10111001", "11000110", "10111010", "11000111"]}]}
{"classification": 1, "content": "对于正数，其原码、补码（）；对于负数，其原码、补码（）。", "code": "", "answer": ["B"], "explanation": "正数的原码、补码、反码表示方法均相同，负数的补码等于对该数的原码除符号位外各位取反后加1。", "source": "C1157", "subproblem": [{"content": "", "choice": ["一致、一致", "一致、不一致", "不一致、一致", "不一致、不一致"]}]}
{"classification": 1, "content": "二进制数-1110的 8 位二进制原码是（）。", "code": "", "answer": ["A"], "explanation": "原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1，其余位表示数值的大小。", "source": "C1158", "subproblem": [{"content": "", "choice": ["10001110", "00001110", "11111110", "11110110"]}]}
{"classification": 1, "content": "二进制数+1110的 8 位二进制补码是（）。", "code": "", "answer": ["D"], "explanation": "正数的原码、补码、反码表示方法均相同。根据原码表示法，二进制数+1110的原码为00001110", "source": "C1159", "subproblem": [{"content": "", "choice": ["10001110", "11111110", "00000110", "00001110"]}]}
{"classification": 1, "content": "二进制数-1111的8 位二进制补码是（）。", "code": "", "answer": ["A"], "explanation": "二进制数-1111的原码为10001111，反码为11110000，补码为11110001。", "source": "C1160", "subproblem": [{"content": "", "choice": ["11110001", "11110000", "10000000", "10001111"]}]}
{"classification": 1, "content": "二进制数-1010的 8 位二进制反码是（）。", "code": "", "answer": ["A"], "explanation": "二进制数-1010的原码为10001010，反码为11110101", "source": "C1161", "subproblem": [{"content": "", "choice": ["11110101", "10001010", "00001010", "01110101"]}]}
{"classification": 1, "content": "二进制数-1011的 8 位二进制原码是（）。", "code": "", "answer": ["D"], "explanation": "原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1，其余位表示数值的大小。", "source": "C1162", "subproblem": [{"content": "", "choice": ["10000011", "11111011", "00001011", "10001011"]}]}
{"classification": 1, "content": "对于机器码01110011，若它是补码，对应的二进制数真值是（）。", "code": "", "answer": ["D"], "explanation": "正数的原码、补码、反码表示方法均相同。所以该数的原码为01110011", "source": "C1163", "subproblem": [{"content": "", "choice": ["-0111001", "+0111001", "-1110011", "+1110011"]}]}
{"classification": 1, "content": "对于机器码10010111，若它是反码，对应的二进制数真值是（）。", "code": "", "answer": ["A"], "explanation": "负整数的反码等于对该数的原码除符号位外各位取反，反之负整数的原码等于对该数的反码除符号位外各位取反。所以该数的原码为11101000", "source": "C1164", "subproblem": [{"content": "", "choice": ["-1101000", "-0010111", "-1101001", "-1001011"]}]}
{"classification": 1, "content": "在8位二进制补码中，11111111表示的数是十进制下的（）。", "code": "", "answer": ["B"], "explanation": "对补码再求一次补码就为真值的原码，即[[x]补]补=[x]原，所以该数的原码=[11111111]补=10000001，即十进制下的-1", "source": "C1165", "subproblem": [{"content": "", "choice": ["1", "-1", "0", "127"]}]}
{"classification": 1, "content": "在8位二进制反码中，11111110表示的数是十进制下的（）。", "code": "", "answer": ["B"], "explanation": "负整数的反码等于对该数的原码除符号位外各位取反，反之负整数的原码等于对该数的反码除符号位外各位取反。所以该数的原码为10000001，即十进制下的-1", "source": "C1166", "subproblem": [{"content": "", "choice": ["1", "-1", "0", "-127"]}]}
{"classification": 1, "content": "已知一个 8 位二进制数的原码为10000000，则这个数的补码是（）。", "code": "", "answer": ["A"], "explanation": "求负整数的补码：将其原码除符号位外的所有位取反后加1。发生溢出，符号位不变。", "source": "C1167", "subproblem": [{"content": "", "choice": ["10000000", "10000001", "00000000", "11111111"]}]}
{"classification": 1, "content": "+17的 8 位二进制原码、反码和补码表示，正确的是（）。", "code": "", "answer": ["B"], "explanation": "[+17]原=[ +17]反=[ +17]补，原码最高位为符号位，其余位表示数值的大小。", "source": "C1168", "subproblem": [{"content": "", "choice": ["00010001、01101110、01101111 ", "00010001、00010001、00010001", "00010001、01101110、00010001 ", "00010001、00010001、00010010 "]}]}
{"classification": 1, "content": "-2的8 位二进制原码、反码和补码表示，正确的是（）。", "code": "", "answer": ["C"], "explanation": "负整数的反码等于原码除符号位外的所有位取反；负整数的补码等于原码除符号位外的所有位取反后加1；原码最高位为符号位，其余位表示数值的大小。", "source": "C1169", "subproblem": [{"content": "", "choice": ["10000100、11111011、11111100", "10000100、11111011、10000101", "10000010、11111101、11111110", "10000010、11111101、10000011"]}]}
{"classification": 1, "content": "-10的8 位二进制原码、反码和补码表示，正确的是（）。", "code": "", "answer": ["D"], "explanation": "负整数的反码等于原码除符号位外的所有位取反；负整数的补码等于原码除符号位外的所有位取反后加1；原码最高位为符号位，其余位表示数值的大小。", "source": "C1170", "subproblem": [{"content": "", "choice": ["10001010、11110101、01110110", "11111010、00000101、00000110", "11111010、11110101、11110110", "10001010、11110101、11110110"]}]}
{"classification": 1, "content": "设二进制数10000011分别以原码、反码和补码表示，则对应的十进制数依次是（）。", "code": "", "answer": ["A"], "explanation": "当二进制数10000011分别以原码、反码和补码表示时，它们对应的原码分别为10000011、11111100、11111101", "source": "C1171", "subproblem": [{"content": "", "choice": ["-3、-124、-125 ", "-3、-125、-124", "-3、-3、-3", "3、-124、125"]}]}
{"classification": 1, "content": "设二进制数10001000分别以原码、反码和补码表示，则对应的十进制数依次是（）。", "code": "", "answer": ["D"], "explanation": "当二进制数10001000分别以原码、反码和补码表示时，它们对应的原码分别为10001000、11110111、11111000", "source": "C1172", "subproblem": [{"content": "", "choice": ["-8、-120、-8", "-8、-8、-120", "-8、-120、-119", "-8、-119、-120"]}]}
{"classification": 1, "content": "有符号二进制数01000001所表示的十进制数是（）。", "code": "", "answer": ["B"], "explanation": "有符号二进制数左边第一位是符号位，符号位用0表示“正”，用1表示“负”。所以有符号二进制数01000001=1×64+1×1=65", "source": "C1173", "subproblem": [{"content": "", "choice": ["33", "65", "31", "63"]}]}
{"classification": 1, "content": "十进制数-36对应的16位二进制原码、反码和补码分别是（）。", "code": "", "answer": ["C"], "explanation": "负整数的反码等于原码除符号位外的所有位取反；负整数的补码等于原码除符号位外的所有位取反后加1；原码最高位为符号位，符号位用0表示“正”，用1表示“负”，其余位表示数值的大小。", "source": "C1174", "subproblem": [{"content": "", "choice": ["11111111 10100100、10000000 01011011、10000000 01011100 ", "11111111 10100100、11111111 11011011、11111111 11011100", "10000000 00100100、11111111 11011011、11111111 11011100", "10000000 10100100、11111111 01011011、11111111 01011100"]}]}
{"classification": 1, "content": "十进制数+2对应的16位二进制原码、反码和补码分别是（）。", "code": "", "answer": ["B"], "explanation": "正数的原码、补码、反码表示方法均相同。原码最高位为符号位，符号位用0表示“正”，用1表示“负”，其余位表示数值的大小。", "source": "C1175", "subproblem": [{"content": "", "choice": ["00000000 00000010、00000000 00000010、00000000 00000011", "00000000 00000010、00000000 00000010、00000000 00000010", "00000000 00000010、00000000 11111101、00000000 11111110", "00000010 00000010、00000010 00000010、00000010 00000010"]}]}
{"classification": 1, "content": "十进制数-127对应的8位二进制原码、反码和补码分别是（）。", "code": "", "answer": ["A"], "explanation": "负整数的反码等于原码除符号位外的所有位取反；负整数的补码等于原码除符号位外的所有位取反后加1；原码最高位为符号位，符号位用0表示“正”，用1表示“负”，其余位表示数值的大小。", "source": "C1176", "subproblem": [{"content": "", "choice": ["11111111、10000000、10000001 ", "10000000、11111111、00000000 ", "11111111、10000000、00000000", "10000001、11111110、11111111"]}]}
{"classification": 1, "content": "十进制数-1对应的8位二进制原码、反码和补码分别是（）。", "code": "", "answer": ["D"], "explanation": "负整数的反码等于原码除符号位外的所有位取反；负整数的补码等于原码除符号位外的所有位取反后加1；原码最高位为符号位，符号位用0表示“正”，用1表示“负”，其余位表示数值的大小。", "source": "C1177", "subproblem": [{"content": "", "choice": ["11111111、10000000、10000001", "10000000、11111111、00000000  ", "11111111、10000000、00000000", "10000001、11111110、11111111"]}]}
{"classification": 1, "content": "下列软件中不是计算机操作系统的是：", "code": "", "answer": ["D"], "explanation": "WPS是办公软件不是计算机操作系统", "source": "C1178", "subproblem": [{"content": "", "choice": ["DOS", "Windows", "LINUX", "WPS"]}]}
{"classification": 1, "content": "第二代电子计算机的逻辑元器件是（）。", "code": "", "answer": ["A"], "explanation": "第二代电子计算机的逻辑元器件是晶体管", "source": "C1179", "subproblem": [{"content": "", "choice": ["晶体管", "电子管", "集成电路", "继电器"]}]}
{"classification": 1, "content": "在微型计算机中ROM指的是（）。", "code": "", "answer": ["C"], "explanation": "在微型计算机中ROM指的是只读存储器", "source": "C1180", "subproblem": [{"content": "", "choice": ["顺序存取存储器", "随机存取存储器", "只读存储器", "光盘驱动器"]}]}
{"classification": 1, "content": "下列存储容量和1GB等价的是（）。", "code": "", "answer": ["B"], "explanation": "1GB=1024MB", "source": "C1181", "subproblem": [{"content": "", "choice": ["1000MB", "1024MB", "1024KB", "2048MB"]}]}
{"classification": 1, "content": "以下网络协议中，属于应用层协议的是（）。", "code": "", "answer": ["B"], "explanation": "FTP属于应用层协议，TCP属于传输层协议，IP属于网络层协议", "source": "C1182", "subproblem": [{"content": "", "choice": ["TCP", "FTP", "IP", "ARP"]}]}
{"classification": 1, "content": "如下代码所示，定义并使用了数组a，请问大致使用了多少内存？", "code": "const int maxN = 5e6;\nunsigned int a[maxN];", "answer": ["B"], "explanation": "一个unsigned int类型的变量，占用了4B的内存，所以5000000个该类型，占用了大约20MB内存。", "source": "C1183", "subproblem": [{"content": "", "choice": ["10 MB", "20 MB", "30 MB", "40 MB"]}]}
{"classification": 1, "content": "以下属于解释语言的是（）。", "code": "", "answer": ["A"], "explanation": "只有python属于解释性语言", "source": "C1184", "subproblem": [{"content": "", "choice": ["python", "C++", "C", "Pascal"]}]}
{"classification": 1, "content": "如下代码所示，定义并使用了数组a，请问大致使用了多少内存？", "code": "const int maxN = 5e6;\nunsigned long long a[maxN];", "answer": ["C"], "explanation": "一个unsigned long long类型占用8B内存，所以5e6个该类型，占用的是40MB左右内存。", "source": "C1185", "subproblem": [{"content": "", "choice": ["20 MB", "30 MB", "40 MB", "50 MB"]}]}
{"classification": 1, "content": "打印机有多种类型，下列速度快，分辨率高的打印机是（）。", "code": "", "answer": ["A"], "explanation": "激光打印机速度快，分辨率高", "source": "C1186", "subproblem": [{"content": "", "choice": ["激光式", "喷墨式", "击打式", "点阵式"]}]}
{"classification": 1, "content": "标准的ASCII码共有（）。", "code": "", "answer": ["D"], "explanation": "标准的ASCII码一共128个", "source": "C1187", "subproblem": [{"content": "", "choice": ["1000个", "100个", "127个", "128个"]}]}
{"classification": 1, "content": "在32位编译器环境下，定义并使用一个int数据类型的变量占用了多少内存？", "code": "", "answer": ["D"], "explanation": "无论是在32位编译环境还是在64位编译环境下，int都是4个字节的。", "source": "C1188", "subproblem": [{"content": "", "choice": ["1 B", "2 B", "3 B", "4 B"]}]}
{"classification": 1, "content": "如下代码所示，在32位编译器环境下，定义并使用了数组a，请问大致使用了多少内存？", "code": "const int maxN = 2e6;\nint a[maxN];", "answer": ["C"], "explanation": "无论是在32位编译器还是64位编译器环境下，int都是4B，再乘上数组大小，大致使用了8 MB内存。", "source": "C1189", "subproblem": [{"content": "", "choice": ["2 MB", "4 MB", "8 MB", "16 MB"]}]}
{"classification": 1, "content": "在网络的7层架构中，处于物理层和网络层之间的模型是（）。", "code": "", "answer": ["A"], "explanation": "网络的七层架构从下到上依次是：物理层、数据链路层、网络层、传输层、会话层 、表示层、应用层", "source": "C1190", "subproblem": [{"content": "", "choice": ["数据链路层", "会话层", "表示层", "应用层"]}]}
{"classification": 1, "content": "云计算是一种基于互联网的超级计算模式，其主要技术不包括（）。", "code": "", "answer": ["C"], "explanation": "生物计算属于生物的范畴，和云计算无关", "source": "C1191", "subproblem": [{"content": "", "choice": ["分布式处理", "并行处理", "生物计算", "网格计算"]}]}
{"classification": 1, "content": "某用户上网时，在浏览器上输入https://www.fudan.edu.cn/，其中https的含义是（）。", "code": "", "answer": ["C"], "explanation": "https属于超文本传输协议", "source": "C1192", "subproblem": [{"content": "", "choice": ["网际协议", "文本传输协议", "超文本传输协议", "邮件协议"]}]}
{"classification": 1, "content": "下列关于计算机病毒的叙述中，正确的是（）。", "code": "", "answer": ["D"], "explanation": "计算机病毒会破坏u盘的内容，并且是可以被清理掉的", "source": "C1193", "subproblem": [{"content": "", "choice": ["计算机病毒不破坏u盘的内容", "计算机病毒不影响计算机运行速度", "计算机病毒不能被清理", "计算机病毒影响程序的执行或破坏用户的数据雨程序"]}]}
{"classification": 1, "content": "在微型计算机中，总线分为控制总线、数据总线和（）。", "code": "", "answer": ["B"], "explanation": "总线分为控制总线、数据总线和地址总线", "source": "C1194", "subproblem": [{"content": "", "choice": ["并行总线", "地址总线", "串行总线", "主板线"]}]}
{"classification": 1, "content": "计算机高级语言的翻译过程有两种形式，分别是编译和（）。", "code": "", "answer": ["B"], "explanation": "两种形式分别是编译和解释", "source": "C1195", "subproblem": [{"content": "", "choice": ["运行", "解释", "链接", "构建"]}]}
{"classification": 1, "content": "当用malloc分配内存的时候，此时分配的内存在程序的哪个位置？", "code": "", "answer": ["A"], "explanation": "malloc分配内存时，把内存分配到程序的堆的位置", "source": "C1196", "subproblem": [{"content": "", "choice": ["堆", "栈", "寄存器", "内核区域"]}]}
{"classification": 1, "content": "一个字节最多可以表示不同的编码个数为（）。", "code": "", "answer": ["D"], "explanation": "一个字节最多能编出256种不同的码，因为1个字节有8位，而每位有0和1两种选择，所以按照排列组合的理论，一共有2的8次方种不同的值，即256种不同的码", "source": "C1197", "subproblem": [{"content": "", "choice": ["8个", "128个", "32个", "256个"]}]}
{"classification": 1, "content": "在微型计算机中，执行一个程序时，其加载顺序为（）。", "code": "", "answer": ["B"], "explanation": "文件要从外村读到内存，然后用CPU执行指令", "source": "C1198", "subproblem": [{"content": "", "choice": ["CPU->外存->内存", "外存->内存->CPU", "内存->外存->CPU", "CPU->内存->外存"]}]}
{"classification": 1, "content": "在Internet中，IPv6地址由（）", "code": "", "answer": ["D"], "explanation": "IPv6地址由128位二进制数组成的", "source": "C1199", "subproblem": [{"content": "", "choice": ["8位二进制数构成", "16位二进制构成", "32位二进制构成", "128位二进制构成"]}]}
{"classification": 1, "content": "计算机网络中，所以设备通过一条传输介质通信的拓扑结构为（）。", "code": "", "answer": ["C"], "explanation": "总线拓扑结构所有设备连接到一条连接介质上", "source": "C1200", "subproblem": [{"content": "", "choice": ["环型", "星型", "总线型", "树型"]}]}
{"classification": 1, "content": "世界上第一台具有程序存储功能的计算机是（）。", "code": "", "answer": ["C"], "explanation": "世界上第一台实现存储程序控制功能的计算机是EDVAC", "source": "C1201", "subproblem": [{"content": "", "choice": ["ENIAC", "EDSAC", "EDVAC", "UNIVAC"]}]}
{"classification": 1, "content": "下列有关CPU的叙述中，正确的是（）。", "code": "", "answer": ["D"], "explanation": "CPU能直接存取内存储器数据", "source": "C1202", "subproblem": [{"content": "", "choice": ["CPU由RAM和ROM构成", "CPU主要用来存储数据", "CPU能直接读取外存的数据", "CPU能直接存取内存储器数据"]}]}
{"classification": 1, "content": "下列存储器，属于易失性存储器的是（）。", "code": "", "answer": ["A"], "explanation": "电源关闭时RAM不能保留数据，如果需要保存数据，就必须把它们写入到一个长期的存储器中（例如硬盘）", "source": "C1203", "subproblem": [{"content": "", "choice": ["RAM", "ROM", "U盘", "光盘"]}]}
{"classification": 1, "content": "计算机网络的主要功能是（）。", "code": "", "answer": ["A"], "explanation": "各种计算机通过网络互联，可以起到共享资源的作用", "source": "C1204", "subproblem": [{"content": "", "choice": ["资源共享", "文献编排", "数据处理", "信息加工"]}]}
{"classification": 1, "content": "在Internet中，每台连网的设备都必须由唯一的IP地址，正确的IP地址是（）。", "code": "", "answer": ["A"], "explanation": "IP地址被.分开，并且每段数据不能超过256", "source": "C1205", "subproblem": [{"content": "", "choice": ["200.112.111.1", "202,197,1,1", "202:202:1:0", "202.257.14.13"]}]}
{"classification": 1, "content": "按照传递信息的功能不同，微型计算机的内部总线分三种，不包括（）。", "code": "", "answer": ["D"], "explanation": "任何总线都具有传输功能", "source": "C1206", "subproblem": [{"content": "", "choice": ["控制总线", "地址总线", "数据总线", "传输总线"]}]}
{"classification": 1, "content": "计算机内存中存储信息的基本单位是（）。", "code": "", "answer": ["B"], "explanation": "字节是计算机内存中存储信息的基本单位", "source": "C1207", "subproblem": [{"content": "", "choice": ["位", "字节", "双字节", "四字节"]}]}
{"classification": 1, "content": "在微型计算机中，不属于串行接口的是（）。", "code": "", "answer": ["A"], "explanation": "LPT接口是一种并口，用来连接打印机和扫描仪设备", "source": "C1208", "subproblem": [{"content": "", "choice": ["LPT", "PS/2", "COM1", "RJ-45"]}]}
{"classification": 1, "content": "在因特网上的每一台主机都有唯一的地址标识，称为（）。", "code": "", "answer": ["C"], "explanation": "IP地址是在因特网的唯一地址标识", "source": "C1209", "subproblem": [{"content": "", "choice": ["用户名", "计算机名", "IP地址", "主机MAC地址"]}]}
{"classification": 1, "content": "利用HTML语言编写网页，实现超链接的标记为（）。", "code": "", "answer": ["B"], "explanation": "<a>...</a>是实现超链接的标记", "source": "C1210", "subproblem": [{"content": "", "choice": ["<p>...</p>", "<a>...</a>", "<body>...</body>", "<hn>...</hn>"]}]}
{"classification": 1, "content": "世界上第一台电子数字计算机诞生于（）。", "code": "", "answer": ["A"], "explanation": "世界上第一台通用计算机：时间：1946年2月14日，名字：\"ENIAC\"\n诞生地：美国宾夕法尼亚大学诞生。", "source": "C1211", "subproblem": [{"content": "", "choice": ["1946年", "1950年", "1999年", "1998年"]}]}
{"classification": 1, "content": "连接计算机系统结构的五大基本组成部件是（）。", "code": "", "answer": ["D"], "explanation": "总线连接计算机系统结构的五大基本组成部件", "source": "C1212", "subproblem": [{"content": "", "choice": ["电缆", "网线", "适配器", "总线"]}]}
{"classification": 1, "content": "字符'a'的ASCII码为97，则'f'的ASCII码为（）。", "code": "", "answer": ["B"], "explanation": "'f'-'a'=5，所以它们的ASCII码差值为5", "source": "C1213", "subproblem": [{"content": "", "choice": ["106", "102", "92", "93"]}]}
{"classification": 1, "content": "一片容量为 4GB 的U盘能存储大约( )个大小为 1MB 程序代码。", "code": "", "answer": ["D"], "explanation": "4GB/1MB大约为4000", "source": "C1214", "subproblem": [{"content": "", "choice": ["1000", "2000", "3000", "4000"]}]}
{"classification": 1, "content": "1bit由多少二进制位组成（）。", "code": "", "answer": ["A"], "explanation": "1bit就是1个二进制位，注意区分bit和byte", "source": "C1215", "subproblem": [{"content": "", "choice": ["1", "8", "16", "4"]}]}
{"classification": 1, "content": "在计算机领域中通常用MIPS来描述（）。", "code": "", "answer": ["A"], "explanation": "MIPS(Million Instructions Per Second)，这是衡量CPU速度的一个指标。", "source": "C1216", "subproblem": [{"content": "", "choice": ["计算机的运算速度", "计算机的可靠性", "计算机的性价比", "计算机的可扩展性"]}]}
{"classification": 1, "content": "剪贴板是个临时存储区，它属于什么的一部分（）？", "code": "", "answer": ["D"], "explanation": "剪切板是内存的一部分，可以发现当重启电脑是里面的内容就会消失", "source": "C1217", "subproblem": [{"content": "", "choice": ["主板", "光盘", "硬盘", "内存"]}]}
{"classification": 1, "content": "微型计算机中运算器的主要功能是（）。", "code": "", "answer": ["C"], "explanation": "微型计算机中运算器的主要功能是进行算术运算和逻辑运算。运算器由算术逻辑单元、累加器、状态寄存器、通用寄存器组等组成。", "source": "C1218", "subproblem": [{"content": "", "choice": ["算术运算", "逻辑运算", "算术和逻辑运算", "科学运算"]}]}
{"classification": 1, "content": "下列语言不需要处理，计算机就可以直接执行的是（）", "code": "", "answer": ["A"], "explanation": "机器语言是最低级的语言，可以被计算机直接执行", "source": "C1219", "subproblem": [{"content": "", "choice": ["机器语言", "符号语言", "汇编语言", "高级语言"]}]}
{"classification": 1, "content": "具有多媒体功能的微型计算机系统中，常见的CD-ROM是（）。", "code": "", "answer": ["A"], "explanation": "CD-ROM（Compact Disc Read-Only Memory）即只读光盘，是一种在电脑上使用的光碟", "source": "C1220", "subproblem": [{"content": "", "choice": ["只读光盘", "只读内存储器", "只读大容量软盘", "只读硬盘"]}]}
{"classification": 1, "content": "下列有关编译程序和解释程序的叙述，正确的是（）。", "code": "", "answer": ["C"], "explanation": "编译程序能产生目标程序，解释程序不能产生目标程序，比如C就会产生目标程序，python不产生目标程序", "source": "C1221", "subproblem": [{"content": "", "choice": ["编译程序、解释程序都能产生目标程序", "编译程序、解释程序都不能产生目标程序", "编译程序能产生目标程序，解释程序不能产生目标程序", "编译程序不能产生目标程序，解释程序能产生目标程序"]}]}
{"classification": 1, "content": "通常计算机硬件由五部分构成，它们是输入设备、输出设备、运算器、控制器和（）。", "code": "", "answer": ["A"], "explanation": "计算机硬件系统五大部件由运算器、控制器、存储器、输入设备、输出设备组成", "source": "C1222", "subproblem": [{"content": "", "choice": ["存储器", "显示器", "寄存器", "散热器"]}]}
{"classification": 1, "content": "表达式 a + b * c + (d + e * f) * g 的后缀形式为（）。", "code": "", "answer": ["A"], "explanation": "<p>1)先按照运算符的优先级对中缀表达式加括号，变成((a+(b*c))+((d+(e*f))*g))</p>\n\n<p>2)将运算符移到括号的后面，变成((a(bc)*)+((d(ef)*)+g)*)+</p>\n\n<p>3)去掉括号，得到abc*+def*+g*+</p>", "source": "C1223", "subproblem": [{"content": "", "choice": ["a b c * + d e f * + g * +", "a b + c * d + e * f * g +", "a + b * c + (d + e * f) * g", "+ + a * b c * + d * e f g"]}]}
{"classification": 1, "content": "后缀表达式 6  2  5  3  + 8 * + 3  +  * 的值为（）。", "code": "", "answer": ["B"], "explanation": "可转为中缀表达式 6*((2+(5+3)*8)+3)=414", "source": "C1224", "subproblem": [{"content": "", "choice": ["288", "414", "328", "512"]}]}
{"classification": 1, "content": "下列选项中，属于操作系统主要功能的是（）。", "code": "", "answer": ["C"], "explanation": "操作系统控制和管理计算机系统资源", "source": "C1225", "subproblem": [{"content": "", "choice": ["把源程序翻译成目标程序", "进行数据分析", "控制和管理计算机系统资源", "进行数据处理"]}]}
{"classification": 1, "content": "下列为C类的IP地址是（）。", "code": "", "answer": ["B"], "explanation": "可以查看网络中按照大类区分IP地址的细则", "source": "C1226", "subproblem": [{"content": "", "choice": ["12.134.23.10", "210.143.241.3", "120.44.45.7", "168.168.168.10"]}]}
{"classification": 1, "content": "下列属于二级域名的是（）。", "code": "", "answer": ["C"], "explanation": "二级域名就是在一级域名前再加一级", "source": "C1227", "subproblem": [{"content": "", "choice": [".com", ".org", "baidu.com", "youa.baidu.com"]}]}
{"classification": 1, "content": "下列有关虚拟内存的说话,正确的是()。", "code": "", "answer": ["D"], "explanation": "虚拟内存可以防止应用程序直接访问物理地址，隔离了各个进程的内存空间", "source": "C1228", "subproblem": [{"content": "", "choice": ["虚拟内存就是swap空间", "虚拟内存就是物理内存", "虚拟内存可有可无", "虚拟内存可以防止应用程序直接访问物理地址。"]}]}
{"classification": 1, "content": "计算机中配置高速缓冲存储器，是为了解决（）。", "code": "", "answer": ["C"], "explanation": "配置高速缓冲存储器Cache为了解决CPU与内存速度不匹配", "source": "C1229", "subproblem": [{"content": "", "choice": ["CPU与外设速度不匹配", "内存和外存速度不匹配", "CPU与内存速度不匹配", "CPU和外存速度不匹配"]}]}
{"classification": 1, "content": "直接用二进制编写程序的语言（）。", "code": "", "answer": ["A"], "explanation": "机器语言是直接用二进制编写程序的语言", "source": "C1230", "subproblem": [{"content": "", "choice": ["机器语言", "汇编语言", "高级语言", "脚本语言"]}]}
{"classification": 1, "content": "国标码GB2312-80,也称为汉字的（）。", "code": "", "answer": ["A"], "explanation": "汉字交换码是指不同的具有汉字处理功能的计算机系统之间在交换汉字信息时所使用的代码标准。自国家标准 GB2312 － 80 公布以来，我国一直延用该标准所规定的国标码作为统一的汉字信息交换码。", "source": "C1231", "subproblem": [{"content": "", "choice": ["交换码", "区位码", "输入码", "机内码"]}]}
{"classification": 1, "content": "在程序运行过程中，局部变量占用的空间被分配在（）。", "code": "", "answer": ["B"], "explanation": "局部变量分配在栈上，全局变量被分配在堆上", "source": "C1232", "subproblem": [{"content": "", "choice": ["堆上", "栈上", "内核", "磁盘"]}]}
{"classification": 1, "content": "在程序运行过程中，如果malloc的空间太多，会因为（）引发错误", "code": "", "answer": ["B"], "explanation": "malloc分配的内存在堆上，当malloc的空间太多，就会因为堆空间溢出导致错误", "source": "C1233", "subproblem": [{"content": "", "choice": ["栈空间溢出", "堆空间溢出", "队列空间溢出", "链表空间溢出"]}]}
{"classification": 1, "content": "一个long long类型的整数变量占（）个字节。", "code": "", "answer": ["B"], "explanation": "long long类型64位，8个字节", "source": "C1234", "subproblem": [{"content": "", "choice": ["4", "8", "16", "32"]}]}
{"classification": 1, "content": "在Internet中，超文本传输协议的英文缩写是（）。", "code": "", "answer": ["D"], "explanation": "HTTP是超文本传输协议的英文缩写", "source": "C1235", "subproblem": [{"content": "", "choice": ["TCP", "FTP", "SMTP", "HTTP"]}]}
{"classification": 1, "content": "下列属于视频文件格式的是（）。", "code": "", "answer": ["A"], "explanation": "mp4属于视频文件格式", "source": "C1236", "subproblem": [{"content": "", "choice": ["mp4", "jpeg", "txt", "png"]}]}
{"classification": 1, "content": "局域网的英文缩写是", "code": "", "answer": ["A"], "explanation": "局域网的英文缩写是LAN-Local Area Network", "source": "C1237", "subproblem": [{"content": "", "choice": ["LAN", "WAN", "MAC", "WPS"]}]}
{"classification": 1, "content": "以下哪个竞赛活动最受oiers向往（）。", "code": "", "answer": ["C"], "explanation": "IOI含金量最高", "source": "C1238", "subproblem": [{"content": "", "choice": ["NOI", "NOIP", "IOI", "CCPC"]}]}
{"classification": 1, "content": "下列哪类竞赛不是面向中学生（）。", "code": "", "answer": ["A"], "explanation": "ACM竞赛面向大学生", "source": "C1239", "subproblem": [{"content": "", "choice": ["ACM竞赛", "NOI", "NOIP", "IOI"]}]}
{"classification": 1, "content": "微型计算机中，运算器的基本功能是（）。", "code": "", "answer": ["B"], "explanation": "运算器的主要功能是实现算术和逻辑运算", "source": "C1240", "subproblem": [{"content": "", "choice": ["控制机器各个部件协调工作", "实现算术和逻辑运算", "获取外部信息", "存放数据"]}]}
{"classification": 1, "content": "现在计算机应用最前沿的领域是（）。", "code": "", "answer": ["A"], "explanation": "目前人工智能是计算机应用最前沿的领域", "source": "C1241", "subproblem": [{"content": "", "choice": ["人工智能", "软件开发", "软件架构", "系统安全"]}]}
{"classification": 1, "content": "目前NOIP复赛支持的语言不包括（）。", "code": "", "answer": ["A"], "explanation": "目前NOIP还不支持Java", "source": "C1242", "subproblem": [{"content": "", "choice": ["Java", "C", "C++", "Pascal "]}]}
{"classification": 1, "content": "编译器的主要作用是（）。", "code": "", "answer": ["A"], "explanation": "编译器的主要作用是把高级语言编译成机器语言", "source": "C1243", "subproblem": [{"content": "", "choice": ["把高级语言编译成机器语言", "负责诊断代码错误", "控制和管理计算机资源", "进行软硬件的交互"]}]}
{"classification": 1, "content": "下列哪种现象会导致程序崩溃（）。", "code": "", "answer": ["A"], "explanation": "只有整数除以0会导致程序崩溃", "source": "C1244", "subproblem": [{"content": "", "choice": ["整数除以0", "整数乘以0", "代码行数超过1000行", "代码行数小于10行"]}]}
{"classification": 1, "content": "栈和队列都是常用的线性表，用两个队列可以模拟一个栈，如果要对一个空栈进行下列操作：\n\tpush x_1\n\tpush x_2\n\tpop\n\tpush x_3\n\tpop\n\tpop\n至少需要几次队列 push 和 pop 操作", "code": "", "answer": ["C"], "explanation": "考虑下面的算法（伪代码）\nq[2] are empty queues\ncur_q = 0\n\nfunc stack_pop():\n\twhile q[cur_q].size() > 1:\n\t\tq[cur_q ^ 1].push( q[cur_q].front() )\n\t\tq[cur_q].pop()\n\tpass\n\tq[cur_q].pop()\n\tcur_q = cur_q ^ 1\npass\n\nfunc stack_push(e):\n\tq[cur_q].push(e)\npass", "source": "C1245", "subproblem": [{"content": "", "choice": ["8次", "9次", "10次", "12次"]}]}
{"classification": 1, "content": "栈和队列都是常用的线性表，用两个栈可以模拟一个队列，如果要对一个空队列进行下列操作：\n\tpush x_1\n\tpush x_2\n\tpop\n\tpush x_3\n\tpop\n\tpop\n至少需要几次栈 push 和 pop 操作", "code": "", "answer": ["A"], "explanation": "入队时始终压入s1，而出队时从s2弹出，当s2为空时，再将s1中除栈顶元素全部转移至s2即可。", "source": "C1246", "subproblem": [{"content": "", "choice": ["8次", "10次", "12次", "14次"]}]}
{"classification": 1, "content": "优先级队列是常用的数据结构，可以高效地插入元素，返回和删除优先级最大的元素，用两个优先级队列可以模拟一个可删优先级队列，它不仅支持删除最优先元素，还可以支持删除任意队列中的元素。假设优先级队列通过二叉堆实现，关于这一模拟算法，下列陈述正确的有\n\t① 该算法的时间复杂度不会优于O(n log^2 n)\n\t② 该算法的时间复杂度可能是O(n log n)\n\t③ 该算法的空间复杂度不会优于O(n log^2 n)\n\t④ 该算法的空间复杂度可能是O(n)", "code": "", "answer": ["D"], "explanation": "用一个队列记录入队元素，另一个队列记录出队元素，查询最大元素时比较两个队列的最大元素，若相同则同时删除，直至不同。", "source": "C1247", "subproblem": [{"content": "", "choice": ["①③", "①④", "②③", "②④"]}]}
{"classification": 1, "content": "链表是常用的线性表，链表的每个节点可以同时保存 prev 和 next 指针（双向链表），也可以只保存 next 指针（单链表）。下列关于链表的陈述，正确的是", "code": "", "answer": ["A"], "explanation": "尽管单链表内部元素没有记录prev指针，但可以通过顺序访问得到其prev指针。\n尽管c++中std::sort()要求参数为随机访问迭代器，但快速排序，归并排序等的思想都可以应用于链表。", "source": "C1248", "subproblem": [{"content": "", "choice": ["单链表中任意元素均可被删除", "双向链表只能从链表的头尾插入元素", "单链表不支持O(1)时间的随机访问，因此无法在O(nlogn)的时间内完成排序.", "双向链表支持O(1)时间的随机访问，因此可以在O(nlogn)的时间内完成排序."]}]}
{"classification": 1, "content": "链表，栈和队列都是常用的线性表，考虑用一个单链接链表（每个节点只保存next指针）实现栈或队列，下面的陈述正确的是", "code": "", "answer": ["C"], "explanation": "维护单链表的 head 和 tail 指针，模拟栈时从 head 元素，模拟队列时则从 tail 插入元素", "source": "C1249", "subproblem": [{"content": "", "choice": ["栈可以在O(1)时间内实现插入和删除，队列不可以", "队列可以在O(1)时间内实现插入和删除，栈不可以", "栈和队列都可以在O(1)时间内实现插入和删除", "栈和队列都不可以在O(1)时间内实现插入和删除"]}]}
{"classification": 1, "content": "称定义在一系列集合上的性质P具有遗传性，当且仅当性质P对集合S成立时，其对任意T是S的子集也成立。对于有向图G(V, E), 其子点集V_1上的下列性质，不满足遗传性的是", "code": "", "answer": ["B"], "explanation": "连通图的子图不一定连通", "source": "C1250", "subproblem": [{"content": "", "choice": ["生成子图的无环性.", "生成子图的连通性.", "补集生成子图的双连通性.", "补集生成子图的连通性."]}]}
{"classification": 1, "content": "快速排序和归并排序都是常用的排序算法，关于两种算法的陈述，正确的是", "code": "", "answer": ["C"], "explanation": "以选取区间首元素为基准的快速排序为例，其在单减序列上运行时复杂度为O(n^2).", "source": "C1251", "subproblem": [{"content": "", "choice": ["对于同一序列，快速排序总是比归并排序更快", "对于同一序列，归并排序总是比快速排序更快", "对于特定的序列，快速排序的时间复杂度可能退化为O(n^2)", "对于特定的序列，归并排序的时间复杂度可能退化为O(n^2)"]}]}
{"classification": 1, "content": "对下面两个序列作一次升序归并，得到的结果是\nseq_1: 3, 5, 1, 7\nseq_2: 2, 8, 4, 6", "code": "", "answer": ["C"], "explanation": "作归并时，每次比较两个序列的首元素，并将较小者加入最终序列的末尾", "source": "C1252", "subproblem": [{"content": "", "choice": ["1, 3, 5, 7, 2, 4, 6, 8", "1, 2, 3, 4, 5, 6, 7, 8", "2, 3, 5, 1, 7, 8, 4, 6", "2, 3, 5, 8, 1, 4, 6, 7"]}]}
{"classification": 1, "content": "一个序列{a_n}的逆序对数是指的是二元组(i,j)的数量，其中 i < j 而 a_i > a_j，有同学使用这段代码计算一个序列的逆序对数，对于序列\n\tA[] = {3, 2, 5, 7, 6, 4, 1, 8}\n其输出结果是", "code": "```cpp\nint&nbsp;temp[MAX_SIZE];<br>\nint&nbsp;countInversePair(int&nbsp;l,&nbsp;int&nbsp;r,&nbsp;int&nbsp;A[])&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if(l&nbsp;+&nbsp;1&nbsp;==&nbsp;r)&nbsp;return&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;mid&nbsp;=&nbsp;l&nbsp;+&nbsp;(r&nbsp;-&nbsp;l)&nbsp;/&nbsp;2;<br>\n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ans&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;countInversePair(l,&nbsp;mid,&nbsp;A);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;countInversePair(mid,&nbsp;r,&nbsp;A);<br>\n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ptr_l&nbsp;=&nbsp;l,&nbsp;ptr_r&nbsp;=&nbsp;mid,&nbsp;ptr_t&nbsp;=&nbsp;0;<br>\n <br>\n&nbsp;&nbsp;&nbsp;&nbsp;while(ptr_l&nbsp;&lt;&nbsp;mid&nbsp;||&nbsp;ptr_r&nbsp;&lt;&nbsp;r)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ptr_l&nbsp;&gt;=&nbsp;mid&nbsp;||&nbsp;A[ptr_l]&nbsp;&gt;&nbsp;A[ptr_r])&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[ptr_t++]&nbsp;=&nbsp;A[ptr_r++];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;ans&nbsp;+&nbsp;mid&nbsp;-&nbsp;ptr_l;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[ptr_t++]&nbsp;=&nbsp;A[ptr_l++];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;ptr_t;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[l&nbsp;+&nbsp;i]&nbsp;=&nbsp;temp[i];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>\n}<br>\n<br>\nprintf(&quot;%d\\n&quot;,&nbsp;countInversePair(0,&nbsp;8,&nbsp;A));", "answer": ["A"], "explanation": "这位同学的代码中忘记统计两侧的逆序对数，只返回了后一半序列和前一半之间的逆序对数", "source": "C1253", "subproblem": [{"content": "", "choice": ["7", "9", "10", "11"]}]}
{"classification": 1, "content": "冒泡排序是经典的排序算法，用冒泡排序算法对下面的序列进行排序（最终升序）时，共发生了多少次元素交换\n    3, 2, 5, 7, 6, 4, 1, 8", "code": "", "answer": ["D"], "explanation": "冒泡排序每次交换两个相邻元素，会使序列的逆序对数减少1，于是总交换数即为总逆序对数。", "source": "C1254", "subproblem": [{"content": "", "choice": ["7", "9", "10", "11"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】在内存储器中每个存储单元都被赋予一个唯一的序号，称为（ ）。", "code": "", "answer": ["A"], "explanation": "每个存储单元都有一个自己的地址。", "source": "C1255", "subproblem": [{"content": "", "choice": ["地址", "序号", "下标", "编号"]}]}
{"classification": 1, "content": "3 的 16 次方等于多少？", "code": "", "answer": ["A"], "explanation": "用快速幂的分治思想快速计算，只需要列两次竖式计算即可， 3^2 = 9 ，3^4 = 9 * 9 = 81 ，3^8 = 81 * 81 = 6561，3^16 = 6561 * 6561 = 43046721", "source": "C1256", "subproblem": [{"content": "", "choice": ["43046721", "6561", "6571", "43047621"]}]}
{"classification": 1, "content": "在长度为 129 个整数的有序数组上二分查找某个数字是否存在，最坏情况下需要比较多少次？", "code": "", "answer": ["B"], "explanation": " 按这样的思路分析，假设目前待查范围长度为 x ，那么选取中间位置的一次比较，就能把待查范围长度缩小为 x/2 （下取整）。注意，可能查询的数字不存在，因此即便待查区间范围大小变为 1 了，也需要再用一次比较去判断是否存在。", "source": "C1257", "subproblem": [{"content": "", "choice": ["6", "8", "7", "9"]}]}
{"classification": 1, "content": "在长度为 255 个整数的有序数组上二分查找某个数字是否存在，最坏情况下需要比较多少次？", "code": "", "answer": ["C"], "explanation": " 按这样的思路分析，假设目前待查范围长度为 x ，那么选取中间位置的一次比较，就能把待查范围长度缩小为 x/2 （下取整）。注意，可能查询的数字不存在，因此即便待查区间范围大小变为 1 了，也需要再用一次比较去判断是否存在。", "source": "C1258", "subproblem": [{"content": "", "choice": ["7", "10", "8", "9"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】编译器的主要功能是（ ）。", "code": "", "answer": ["A"], "explanation": "编译器是让程序员写的相应的语言变成可以让计算机执行的指令代码。", "source": "C1259", "subproblem": [{"content": "", "choice": ["将源程序翻译成机器指令代码", "将源程序重新组合", "将低级语言翻译成高级语言", "将一种高级语言翻译成另一种高级语言"]}]}
{"classification": 1, "content": " 在实数区间 0～1 之间二分查找一个实数值。请问至少需要取多少次中点之后，才能将误差范围缩小到 0.01 以内？", "code": "", "answer": ["D"], "explanation": "把题目中的数字扩大100倍，相当于在0~100之间二分，多少次能使得区间缩小到长度小于1？用公式计算发现是7次，当然也可以直接二分模拟：进行第一次去中点后，区间范围变成 0.5 ，然后接着为 0.25，0.125，0.0625，0.03125，0.015625，0.0078125，因此至少需要 7 次", "source": "C1260", "subproblem": [{"content": "", "choice": ["6", "5", "8", "7"]}]}
{"classification": 1, "content": "把 10 个水果分给 3 个小朋友，在所有分配方案中，分得水果最少的小朋友最多能有多少个水果？", "code": "", "answer": ["D"], "explanation": "可以二分答案，二分的 mid 表示水果最少的小朋友有多少个水果，检验这种情况是否成立，调整二分区间即可。", "source": "C1261", "subproblem": [{"content": "", "choice": ["0", "1", "2", "3"]}]}
{"classification": 1, "content": "现有一个数列  2，3，4，1，8，5，9 。使用冒泡排序算法，使得数字从小到大有序排列，需要交换多少对数字？", "code": "", "answer": ["C"], "explanation": " 按序交换：(4,1) (8,5) (3,1) (2,1)。", "source": "C1262", "subproblem": [{"content": "", "choice": ["2", "3", "4", "5"]}]}
{"classification": 1, "content": "设x = true，y = true，z = false，以下逻辑运算表达式值为真的是（ ）。", "code": "", "answer": ["D"], "explanation": "‘^’是异或操作，’|’是或操作，异或操作是相同为0，相异为1；或操作是只要有1，就为1。", "source": "C1263", "subproblem": [{"content": "", "choice": ["(y ^ x) | z", "x ^ (z | y) ^ z", "(x ^ y) | z", "(x ^ y) | (z | x)"]}]}
{"classification": 1, "content": "现有一个数列  2，7，4，1，9，3，8 。使用冒泡排序算法，使得数字从小到大有序排列，需要交换多少对数字？", "code": "", "answer": ["B"], "explanation": "按序交换：(7,4) (7,1) (9,3) (9,8) (4,1) (7,3) (2,1) (4,3)。", "source": "C1264", "subproblem": [{"content": "", "choice": ["7", "8", "9", "10"]}]}
{"classification": 1, "content": " 以下哪一项中的排序算法都是稳定的？", "code": "", "answer": ["A"], "explanation": " 冒泡排序、插入排序是稳定的，选择排序、快速排序是不稳定的。", "source": "C1265", "subproblem": [{"content": "", "choice": ["插入排序，冒泡排序", "选择排序，插入排序", "快速排序，冒泡排序", "选择排序，快速排序"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】现有一张分辨率为2048×1024 像素的 32 位真彩色图像。请问要存储这张图像，需要多大的存储空间？（ ）", "code": "", "answer": ["C"], "explanation": "32位 = 4B，2048 * 1024 * 4 B = 2 * 4 MB = 8 MB。", "source": "C1266", "subproblem": [{"content": "", "choice": ["16 MB", "4 MB", "8 MB", "32 MB"]}]}
{"classification": 1, "content": " 以下递归算法求解的结果是什么？", "code": "```c++\nint&nbsp;F(int&nbsp;a[],int&nbsp;n)<br>\n{<br>\n&nbsp;&nbsp;if(n==1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a[n-1];<br>\n&nbsp;&nbsp;else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;F(a,n-1)+a[n-1];<br>\n}", "answer": ["A"], "explanation": "这是一个求解数组a前n项和的递归算法。", "source": "C1267", "subproblem": [{"content": "", "choice": ["数组a的前n项和", "数组a的前n项乘积 ", "数组a的第一个数字", "数组a的最后一个数字"]}]}
{"classification": 1, "content": "以下递归算法求解的结果是什么？", "code": "```c++\nint&nbsp;F(int&nbsp;a[],int&nbsp;n)<br>\n{<br>\n&nbsp;&nbsp;if(n==1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a[n-1];<br>\n&nbsp;&nbsp;else<br>\n&nbsp;&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;tmp=F(a,n-1);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if(tmp&gt;a[n-1])<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;tmp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a[n-1];<br>\n&nbsp;&nbsp;}<br>\n}", "answer": ["B"], "explanation": "这是一个求解数组a前n项最大值的递归算法。", "source": "C1268", "subproblem": [{"content": "", "choice": ["数组a的前n项和 ", "数组a的前n项的最大值", "数组a的前n项的最小值", "数组a的最后一个数字"]}]}
{"classification": 1, "content": "有一个数列，它的第一项和第二项分别是 -2 和 1 。且它的第 n 项（n > 2）满足等式：f(n) = f(n-1) + f(n-2) ，那么请问数字 8 位于该数列的第几项？", "code": "", "answer": ["C"], "explanation": "-2，1，-1，0，1，1，2，3，5，8", "source": "C1269", "subproblem": [{"content": "", "choice": ["6", "9", "10", "7"]}]}
{"classification": 1, "content": "有一个数列，它的第一项和第二项分别是 3 和 4 。且它的第 n 项（n > 2）满足等式：f(n) = f(n-1) - f(n-2) ，那么请问该数列的第 8 项是多少？", "code": "", "answer": ["D"], "explanation": "该数列为 3，4，1，-3，-4，-1，3，4", "source": "C1270", "subproblem": [{"content": "", "choice": ["76", "28", "3", "4"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】冒泡排序算法的伪代码如下：\n对 n 个数用以上冒泡排序算法进行排序，最少需要比较多少次？（ ）", "code": "```C++\n输入：数组&nbsp;L，n&nbsp;≥&nbsp;1。输出：按非递减顺序排序的&nbsp;L。<br>\n算法&nbsp;BubbleSort：<br>\n&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;FLAG&nbsp;←&nbsp;n&nbsp;//&nbsp;标记被交换的最后元素位置<br>\n&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;while&nbsp;FLAG&nbsp;&gt;&nbsp;1&nbsp;do<br>\n&nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;←&nbsp;FLAG&nbsp;-&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FLAG&nbsp;←&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;=&nbsp;1&nbsp;to&nbsp;k&nbsp;do<br>\n&nbsp;&nbsp;&nbsp;&nbsp;6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;L(j)&nbsp;&gt;&nbsp;L(j+1)&nbsp;then&nbsp;do<br>\n&nbsp;&nbsp;&nbsp;&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L(j)&nbsp;↔&nbsp;L(j+1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FLAG&nbsp;←&nbsp;j", "answer": ["C"], "explanation": "如果这个长度为n的序列本身就已经是非递减排列，那么实际上只需要判断一次，会发现k=1，则退出循环。", "source": "C1271", "subproblem": [{"content": "", "choice": ["n^2", "n - 2", "n - 1", "n"]}]}
{"classification": 1, "content": "一个数列 f 被称作循环数列，当且仅当存在整数 T 对任意的正整数 i 满足 f(i) = f(i+T)，其中 T 被称为循环数列的循环节。现在有一个数列 a ，满足 a(1)=2，a(2)=3，当 n>3 时：f(n) = f(n-1) - f(n-2) 。请问数列 a 的最小正循环节是多少？", "code": "", "answer": ["C"], "explanation": "该数列为 2，3，1，-2，-3，-1，2，3 ... 故最小正循环节是 6", "source": "C1272", "subproblem": [{"content": "", "choice": ["3", "5", "6", "12"]}]}
{"classification": 1, "content": "一棵只含有根节点的树的树高为 1 。那么一棵含有 31 个节点的二叉树的树高最大是多少？", "code": "", "answer": ["D"], "explanation": " 二叉树是每个结点的孩子结点数不超过 2 的树，因此最高的情况是树形成一条链，每个非叶子节结恰好有一个孩子结点。", "source": "C1273", "subproblem": [{"content": "", "choice": ["4", "5", "6", "31"]}]}
{"classification": 1, "content": " 一棵只含有根节点的树的树高为 1 。那么一棵含有 31 个节点的二叉树的树高最小是多少？", "code": "", "answer": ["C"], "explanation": "二叉树是每个结点的孩子结点数不超过 2 的树，因此最矮的情况应该把每一层塞满，分别是1，2，4，8，16个结点，五层恰好一共 31 个节点。", "source": "C1274", "subproblem": [{"content": "", "choice": ["31", "6", "5", "4"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】设 A 是 n 个实数的数组，考虑下面的递归算法：\n请问算法 XYZ 的输出是什么？（ ）", "code": "```C++\nXYZ(A[1..n])<br>\n&nbsp;if&nbsp;n=1&nbsp;then&nbsp;return&nbsp;A[1]<br>\n&nbsp;else&nbsp;temp&nbsp;←&nbsp;XYZ(A[1..n-1])<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;temp&nbsp;&lt;&nbsp;A[n]<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;return&nbsp;temp<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;return&nbsp;A[n]", "answer": ["B"], "explanation": "当n=1的时候，返回的值为A[1]，当n!=1的时候，返回的是A[1……n-1]的值和A[n]的小的那个值，所以最后得到的是A[1……n]的最小值。", "source": "C1276", "subproblem": [{"content": "", "choice": ["数组的平均值", "数组的最小值", "数组的中值", "数组的最大值"]}]}
{"classification": 1, "content": "请选择以下说法中正确的一项：", "code": "", "answer": ["A"], "explanation": " 一棵深度为5的满二叉树的结点个数是31；完全二叉树不一定是满二叉树，反之一定；一棵含有 n 个结点的树一定含有 n-1 条边。", "source": "C1277", "subproblem": [{"content": "", "choice": ["满二叉树的每个非叶子结点一定含有两个孩子结点。", "一棵深度为5的满二叉树的结点个数是32。", "完全二叉树一定是满二叉树。", "一棵含有 n 个结点的树可能含有 n 条边。"]}]}
{"classification": 1, "content": " 以下哪些树形结构是二叉树？\n\n1：满二叉树\n\n2：二叉堆\n\n3：哈夫曼树\n\n4：二叉查找树", "code": "", "answer": ["D"], "explanation": "都是二叉树", "source": "C1280", "subproblem": [{"content": "", "choice": ["1,2", "1,2,3", "2,3,4", "1,2,3,4"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】链表不具有的特点是（ ）。", "code": "", "answer": ["A"], "explanation": "链表需要逐一寻址找到对应的元素，而非可以随机访问任一元素。链表需要事先估计存储空间，避免程序运行超内存。链表的插入和删除会对后面元素进行统一向后或者向前的移动。空间与线性表的长度成正相关。", "source": "C1281", "subproblem": [{"content": "", "choice": ["可随机访问任一元素", "不必事先估计存储空间", "插入删除不需要移动元素", "所需空间与线性表长度成正比"]}]}
{"classification": 1, "content": "一棵具有 n 个结点的树（n>2），最多有多少个叶子节点？", "code": "", "answer": ["C"], "explanation": "考虑一棵树的根结点连接了其余所有的 n-1 个结点。", "source": "C1283", "subproblem": [{"content": "", "choice": ["n", "n/2", "n-1", "1"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】有 10 个顶点的无向图至少应该有（ ）条边才能确保是一个连通图。", "code": "", "answer": ["A"], "explanation": "一个n个点的图，需要至少n-1条边就可以保证联通，例如2个点只需要1条边就可以联通了。", "source": "C1284", "subproblem": [{"content": "", "choice": ["9", "10", "11", "12"]}]}
{"classification": 1, "content": " 一张具有 100 个结点的无向图，其各个节点连通，则这张图中至少有多少条边？", "code": "", "answer": ["A"], "explanation": "边数最小的 n 结点连通图是一棵树，只有 n-1 条边。", "source": "C1285", "subproblem": [{"content": "", "choice": ["99", "100", "200", "5050"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】二进制数 1011 转换成十进制数是（ ）。", "code": "", "answer": ["A"], "explanation": "(1011)2 = (1 + 2 + 8) = (11)10。", "source": "C1286", "subproblem": [{"content": "", "choice": ["11", "10", "13", "12"]}]}
{"classification": 1, "content": "一张具有 n 个结点的无向图，其各个结点连通，图中无自环无重边，则这张图中至多有多少条边？", "code": "", "answer": ["A"], "explanation": "考虑满图", "source": "C1287", "subproblem": [{"content": "", "choice": ["n(n-1)/2", "2n", "n", "n-1"]}]}
{"classification": 1, "content": "一张具有 n 个结点的无向图，图中没有自环和重边，已知这张图中的所有结点连通，并且图中恰好有 n 条边。请问该图中有几个环？", "code": "", "answer": ["B"], "explanation": "当只有 n-1 条边时，连通图是一棵树，这个时候再加上一条边，图中恰好形成一个环。", "source": "C1288", "subproblem": [{"content": "", "choice": ["0", "1", "2", "3"]}]}
{"classification": 1, "content": "用邻接矩阵储存一个具有 n 个结点的有向图，图中没有自环和重边。要存下图中的边，请问至少需要多少个变量进行存储？", "code": "", "answer": ["B"], "explanation": " 邻接矩阵的空间复杂度为 O(n^2)", "source": "C1289", "subproblem": [{"content": "", "choice": ["n", "n^2", "2n", "nlogn"]}]}
{"classification": 1, "content": " 以下哪张图中，使用邻接表储存相比于邻接矩阵储存能够显著节省空间？", "code": "", "answer": ["D"], "explanation": "一棵具有n个结点的树使用邻接表储存只需要 O(n) 的空间，显著低于邻接矩阵的 O(n^2)。", "source": "C1290", "subproblem": [{"content": "", "choice": ["一张含有10个点，50条边的图。", "一张含有 n 个点的稠密图。", "一张含有 n 个结点的有向图，其中每个结点含有 n/2 条出边。", "一棵具有n个结点的树。"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】五个小朋友并排站成一列，其中有两个小朋友是双胞胎，如果要求这两个双胞胎必须相邻，则有（ ）种不同排列方法？", "code": "", "answer": ["A"], "explanation": "有两个小朋友一定要相邻，我们不妨将这两个小朋友看成一个人，于是，4个人的排列有4的阶乘种，也就是24种。但是，这两个相邻的小朋友没有规定谁左谁右，所以又有2种可能，所以总的方案就是24 * 2 = 48种。", "source": "C1292", "subproblem": [{"content": "", "choice": ["48", "36", "24", "72"]}]}
{"classification": 1, "content": "某同学去搬砖，他每搬一块小砖，需要花费 4 分钟，能获得 4 元钱的奖励；他每搬一块大砖，需要花费 10 分钟，但是能获得 11 元钱的奖励。他可以搬任意数量任意种类的砖，但是他只有 62 分钟的时间，请问他最多能获得多少元钱的奖励？", "code": "", "answer": ["B"], "explanation": " 搬 5 块大砖，3块小砖，刚好用完时间，获得 67 元钱的奖励。", "source": "C1295", "subproblem": [{"content": "", "choice": ["66", "67", "70", "76"]}]}
{"classification": 1, "content": "对此邻接矩阵表示的图进行深度优先遍历时，下列哪个选项不可能是遍历顺序（节点从0开始编号）.\n    0 1 1 1 \n    1 0 1 0\n    1 1 0 0\n    1 0 0 0", "code": "", "answer": ["D"], "explanation": "依邻接矩阵画出示意图后自然得解", "source": "C1296", "subproblem": [{"content": "", "choice": ["1，2，0，3", "1，0，2，3", "1，0，3，2", "1，2，3，0"]}]}
{"classification": 1, "content": "存储在计算机的存储单元中的（）。", "code": "", "answer": ["A"], "explanation": "存储在计算机的存储单元中的可以是数据或者指令", "source": "C1297", "subproblem": [{"content": "", "choice": ["可以是数据或者指令", "只能是字符", "只能是指令", "只能是数据"]}]}
{"classification": 1, "content": "计算机中用（）表示汉字。", "code": "", "answer": ["D"], "explanation": "汉字编码是专门表示汉字的编码", "source": "C1298", "subproblem": [{"content": "", "choice": ["信息编码", "BCD码", "ASCII码", "汉字编码"]}]}
{"classification": 1, "content": "某计算机系统的内存容量配置为128MB，128MB等于（）。", "code": "", "answer": ["A"], "explanation": "B是字节的单位，1M=1024K=1024*1024", "source": "C1299", "subproblem": [{"content": "", "choice": ["128×1024×1024个字节", "128×1000×1000×8个字节", "128×1024×1024×8个字节", "128×1000×1000个字节"]}]}
{"classification": 1, "content": "8个字节含二进制位（）。", "code": "", "answer": ["D"], "explanation": "1个字节8个二进制位", "source": "C1300", "subproblem": [{"content": "", "choice": ["8个", "16个", "32个", "64个"]}]}
{"classification": 1, "content": "“32位微型计算机”中的32指的是（）。", "code": "", "answer": ["D"], "explanation": "32位微型计算机代表机器字长为32位，指计算机进行一次整数运算所能处理的二进制数据的位数", "source": "C1301", "subproblem": [{"content": "", "choice": ["微机类型", "内存容量", "运算速度", "机器字长"]}]}
{"classification": 1, "content": "下列四个计算机存储容量的换算公式中，错误的是（）。", "code": "", "answer": ["C"], "explanation": "1M=1024K", "source": "C1302", "subproblem": [{"content": "", "choice": ["1KB=1024B", "1MB=1024KB", "1KB=1024MB", "1GB=1024MB"]}]}
{"classification": 1, "content": "微型计算机体积小，适合放在办公桌上使用，又可被称为（）。", "code": "", "answer": ["B"], "explanation": "微型计算机又成为个人计算机", "source": "C1303", "subproblem": [{"content": "", "choice": ["工作站", "个人计算机", "服务器", "终端"]}]}
{"classification": 1, "content": "以下几组信息存储容量单位中，按由小到大顺序排列的是（）。", "code": "", "answer": ["B"], "explanation": "KB<MB<GB", "source": "C1304", "subproblem": [{"content": "", "choice": ["MB，KB，GB", "KB，MB，GB", "GB，KB，MB", "GB，MB，KB"]}]}
{"classification": 1, "content": "能将计算机运行结果以可见的方式向用户展示的部件是（）。", "code": "", "answer": ["D"], "explanation": "输出设备例如显示屏，就可以把结果呈现给用户", "source": "C1305", "subproblem": [{"content": "", "choice": ["存储器", "控制器", "输入设备", "输出设备"]}]}
{"classification": 1, "content": "汇编语言是一种（）。", "code": "", "answer": ["A"], "explanation": "汇编语言一一对应于底层的机器语言", "source": "C1306", "subproblem": [{"content": "", "choice": ["依赖于计算机的低级程序设计语言", "计算机能直接执行的程序设计语言", "独立于计算机的高级程序设计语言", "面向问题的程序设计语言"]}]}
{"classification": 1, "content": "计算机中的所有信息都是以二进制方式表示的，这两个二进制数是（）。", "code": "", "answer": ["C"], "explanation": "0和1的可以组成计算机的所有信息", "source": "C1307", "subproblem": [{"content": "", "choice": ["1和2", "0和2", "0和1", "1和10"]}]}
{"classification": 1, "content": "计算机操作系统作为一个接口，连接着（）。", "code": "", "answer": ["D"], "explanation": "用户通过操作系统和计算机进行交互", "source": "C1308", "subproblem": [{"content": "", "choice": ["用户和软件", "系统软件和应用软件", "主机与外设", "用户和计算机"]}]}
{"classification": 1, "content": "下列关于存储设备的说法中正确的是（）。", "code": "", "answer": ["C"], "explanation": "内存中存储的信息断电后会消失，比如RAM", "source": "C1309", "subproblem": [{"content": "", "choice": ["计算机中内存的容量一般比硬盘大", "硬盘的读写速度比内存快", "内存中存储的信息断电后会消失", "相同容量下，内存的价格比硬盘便宜"]}]}
{"classification": 1, "content": "为某种特定目的而设计的计算机属于（）。", "code": "", "answer": ["A"], "explanation": "为某种特定目的而设计的计算机属于专用计算机", "source": "C1310", "subproblem": [{"content": "", "choice": ["专用计算机", "数模混合计算机", "科学计算机", "电子模拟计算机"]}]}
{"classification": 1, "content": "计算机中的所有信息都是以二进制方式表示的，主要理由是（）。", "code": "", "answer": ["B"], "explanation": "计算机中的所有信息都是以二进制方式表示的，主要理由是所需的物理元件最简单", "source": "C1311", "subproblem": [{"content": "", "choice": ["运算速度快", "所需的物理元件最简单", "节约元件", "信息处理方便"]}]}
{"classification": 1, "content": "在计算机内部，数据加工﹑处理和传送的形式是（）。", "code": "", "answer": ["A"], "explanation": "数据加工、处理和传送的形式都是二进制码，然后再转化成相应的字符，让用户可以识别", "source": "C1312", "subproblem": [{"content": "", "choice": ["二进制码", "八进制码", "十六进制码", "ASCCI码"]}]}
{"classification": 1, "content": "计算机执行某种操作的命令被称为（）。", "code": "", "answer": ["B"], "explanation": "CPU通过指令来决定做什么操作", "source": "C1313", "subproblem": [{"content": "", "choice": ["软件", "指令", "操作系统", "程序设计语言"]}]}
{"classification": 1, "content": "在计算机领域中，英文单词“bit”的含义是（）。", "code": "", "answer": ["C"], "explanation": "bit代表位，byte代表字节", "source": "C1314", "subproblem": [{"content": "", "choice": ["字", "字长", "位", "比特"]}]}
{"classification": 1, "content": "为解决某一特定的问题而设计的指令序列称为（）。", "code": "", "answer": ["A"], "explanation": "程序是为解决某一特定的问题而设计的指令序列", "source": "C1315", "subproblem": [{"content": "", "choice": ["程序", "文档", "系统", "语言"]}]}
{"classification": 1, "content": "用高级程序设计语言编写的程序称为源程序，它（）。", "code": "", "answer": ["D"], "explanation": "比如C代码就具有可读性和可移植性", "source": "C1316", "subproblem": [{"content": "", "choice": ["只能在专门的机器上运行", "无需编译或解释，可直接在机器上运行", "不可读", "具有可读性和可移植性"]}]}
{"classification": 1, "content": "算式 7-2*3+5 的后缀表达式是？", "code": "", "answer": ["A"], "explanation": "算式 7-2*3+5 的后缀表达式是 7 2 3 * - 5 + 算式 7-2*3+5 的后缀表达式是 7 2 3 * - 5 + ", "source": "C1317", "subproblem": [{"content": "", "choice": ["7 2 3 * - 5 +", "7 2 3 * 5 + - ", "7 - 2 3 * 5 + ", "7 2 * 3 - 5 +   "]}]}
{"classification": 1, "content": "算式 7 * 2 - 4+1 的后缀表达式是？", "code": "", "answer": ["B"], "explanation": " 算式 7 * 2 - 4+1 的后缀表达式是 7 2 * 4 - 1 +", "source": "C1318", "subproblem": [{"content": "", "choice": ["7 2  4 1 * - +  ", "7 2 * 4 - 1 +", "7 2 * 3 - 1 + ", "7 * 2  4 - 1 +"]}]}
{"classification": 1, "content": " 后缀表达式 4 5 6 7 + - + 的中缀表达式是？", "code": "", "answer": ["C"], "explanation": "后缀表达式 4 5 6 7 + - + 的中缀表达式是 4 + ( 5 - ( 6 + 7 ) ) ，注意运算顺序。", "source": "C1319", "subproblem": [{"content": "", "choice": ["(4 + 5) -  (6 + 7) ", "((4 + 5) -  6) + 7 ", "4 + ( 5 - ( 6 + 7 ) )", "+ - + 7 6 5 4"]}]}
{"classification": 1, "content": "后缀表达式 1 3 2 + 7 *  - 的中缀表达式是？", "code": "", "answer": ["D"], "explanation": "后缀表达式 1 3 2 + 7 *  - 的中缀表达式是 1 -  (3 + 2) * 7", "source": "C1320", "subproblem": [{"content": "", "choice": ["1 -  3 + 2 * 7  ", "3 -  (1 + 2) * 7", "1 +  3 * 2 - 7", "1 -  (3 + 2) * 7"]}]}
{"classification": 1, "content": "表达式 a - b * c * d 的后缀形式是？", "code": "", "answer": ["A"], "explanation": "表达式 a - b * c * d 的后缀形式是 a b c * d * -", "source": "C1321", "subproblem": [{"content": "", "choice": ["a b c * d * -", "a b c d * * -", "a - b c d * *  ", "- * d * c b a "]}]}
{"classification": 1, "content": "2021 年 7 月 1 日是星期四，1921 年 7 月 1 日是（ ）。", "code": "", "answer": ["B"], "explanation": "平年 365 天，模7余1，闰年366天，模7余2，这一百年恰好25个闰年，因此相差的日期模7同余125，同余6，因此星期四倒过去 6 天就是星期五。", "source": "C1322", "subproblem": [{"content": "", "choice": ["星期四", "星期五", "星期六", "星期日"]}]}
{"classification": 1, "content": "设 G 是有 10 个结点、20 条边的连通图，必须删去 G 的（ ）条边，才能使得 G 变成一棵树。", "code": "", "answer": ["B"], "explanation": "树有 n-1 条边，连通图变树只需删去多余边即可。", "source": "C1323", "subproblem": [{"content": "", "choice": ["10", "11", "12", "20"]}]}
{"classification": 1, "content": "对于给定的序列{ak}，我们把 (i, j) 称为顺序对当且仅当 i < j 且 ai < aj。那么 序列 1, 7, 2, 3, 5, 4 的顺序对数为（ ）个。", "code": "", "answer": ["D"], "explanation": " (1,7) (1,2) (1,3) (1,4) (1,5) (2,3) (2,5) (2,4) (3,5) (3,4)", "source": "C1324", "subproblem": [{"content": "", "choice": ["5", "6", "9", "10"]}]}
{"classification": 1, "content": "设简单无向图 G 有 10 条边且每个顶点的度数都是 2，则图 G 有( )个顶点。", "code": "", "answer": ["D"], "explanation": " 无向图每个顶点度数是 2 ，则只能是环，于是有 10 个顶点。", "source": "C1325", "subproblem": [{"content": "", "choice": ["5", "8", "9", "10"]}]}
{"classification": 1, "content": "前缀表达式 * + a b + a b与下列哪个后缀表达式等价？", "code": "", "answer": ["D"], "explanation": "化为中缀表达式，即(a+b)*(a+b)=a*a+2*a*b+b*b", "source": "C1330", "subproblem": [{"content": "", "choice": ["a a * b b * +", "a b * b a * +", "a b * a a * + b b * +", "a a * 2 a * b * + b b * +"]}]}
{"classification": 1, "content": "能用二分法进行查找的数据结构一般要求（)。", "code": "", "answer": ["A"], "explanation": "二分的算法要求数据结构有序；每次查找需要快速进行随机访问，因此要求顺序存储", "source": "C1331", "subproblem": [{"content": "", "choice": ["有序、顺序存储", "有序、链接存储", "无序、顺序存储", "无序、链接存储"]}]}
{"classification": 1, "content": "预先给定一个不超过1023的正整数x，每猜一次都会提示“大了”“小了”或“猜中”。若猜测方法确定，至少猜多少次可以保证猜中？", "code": "", "answer": ["C"], "explanation": "用二分法进行查找。可以构建一棵高度为10的满二叉树，恰好有1023个结点", "source": "C1332", "subproblem": [{"content": "", "choice": ["12", "11", "10", "9"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】独根树的高度为 1。具有 61 个结点的完全二叉树的高度为（ ）。", "code": "", "answer": ["D"], "explanation": "一棵高度为h的树，能拥有2^h - 1个节点，所以61个节点，只需要高度为6的树就可以了。因为高度为6的树可以最多放63个节点。", "source": "C1334", "subproblem": [{"content": "", "choice": ["7", "8", "5", "6"]}]}
{"classification": 1, "content": "有27个外表相同的乒乓球，其中1个球不合格（质量较轻），其他球质量相等。现有一架托盘天平，至少要称多少次可以确定那个球？", "code": "", "answer": ["C"], "explanation": "第一次分成9+9+9三堆，拿其中两堆到天平比较，若天平倾斜，则球在轻的那边，若不倾斜，在剩下那堆中。第二次，继续拿9个球分成3+3+3，第三次3个球分成1+1+1，所以三次就可以得出结果。", "source": "C1336", "subproblem": [{"content": "", "choice": ["5", "4", "3", "2"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】10 个三好学生名额分配到 7 个班级，每个班级至少有一个名额，一共有（ ）种不同的分配方案。", "code": "", "answer": ["A"], "explanation": "因为每个班级至少有一个名额，所以还剩3个名额。考虑三种情况：三个名额分配个三个班级、三个名额分配给两个班级、三个名额全分配给一个班级，方案数为35 + 42 + 7 = 84。", "source": "C1337", "subproblem": [{"content": "", "choice": ["84", "72", "56", "504"]}]}
{"classification": 1, "content": "每台计算机必须知道对方的（）才能在Internet上与之通信。", "code": "", "answer": ["C"], "explanation": "每台计算机必须知道对方的IP地址就可以在Internet上进行网络通信了。例如说，属于同一子网的可以直接进行IP通信。", "source": "C1460", "subproblem": [{"content": "", "choice": ["电话号码", "主机号", "IP地址", "邮编与通信地址"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】有五副不同颜色的手套（共 10 只手套，每副手套左右手各 1 只），一次性从中取 6 只手套，请问恰好能配成两副手套的不同取法有（ ）种。", "code": "", "answer": ["A"], "explanation": "首先，要恰好配成两副手套，所以得是C(5,2)=10，然后一共得取6只，所以还有一副不能配成手套，而且手套又有左右手，所以方案数是4*C(3,2)=12，所以总的方案数是10*12=120。", "source": "C1338", "subproblem": [{"content": "", "choice": ["120", "180", "150", "30"]}]}
{"classification": 1, "content": "冒泡排序算法的伪代码如下。若原序列为 1 9 2 6 0 8 1 7，则当循环体执行2次后，序列变为（）。", "code": "```C++\n<p>输入：数组L,&nbsp;n&nbsp;≥&nbsp;k。输出：按非递减顺序排序的&nbsp;L。<br>\n&nbsp;&nbsp;&nbsp;&nbsp;算法&nbsp;BubbleSort：<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;FLAG&nbsp;←&nbsp;n&nbsp;//标记被交换的最后元素位置<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;while&nbsp;FLAG&nbsp;&gt;&nbsp;1&nbsp;do<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3・&nbsp;k&nbsp;←&nbsp;FLAG&nbsp;-1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4・&nbsp;FLAG&nbsp;←&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5・&nbsp;for&nbsp;j=1&nbsp;to&nbsp;k&nbsp;do<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.&nbsp;&nbsp;&nbsp;if&nbsp;L(j)&nbsp;&gt;&nbsp;L(j+1)&nbsp;then&nbsp;do<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7・&nbsp;&nbsp;&nbsp;&nbsp;L(j)&nbsp;&nbsp;↔&nbsp;L(j+1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8・&nbsp;&nbsp;&nbsp;&nbsp;FLAG&nbsp;←&nbsp;j</p>", "answer": ["C"], "explanation": "按伪代码模拟即可", "source": "C1339", "subproblem": [{"content": "", "choice": ["1 9 2 6 0 8 1 7", "1 2 6 0 8 1 7 9", "1 2 0 6 1 7 8 9", "1 0 2 1 6 7 8 9"]}]}
{"classification": 1, "content": "下列属于稳定排序的是（）。", "code": "", "answer": ["D"], "explanation": "堆排序 、 快速排序 、 希尔排序 、 直接选择排序 是不稳定的排序算法，而 冒泡排序 、 直接插入排序 、 折半插入排序 、 归并排序 是稳定的排序算法。", "source": "C1340", "subproblem": [{"content": "", "choice": ["堆排序", "快速排序", "希尔排序", "归并排序"]}]}
{"classification": 1, "content": "下列属于不稳定排序的是（）。", "code": "", "answer": ["D"], "explanation": "选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。", "source": "C1341", "subproblem": [{"content": "", "choice": ["冒泡排序", "插入排序", "基数排序", "选择排序"]}]}
{"classification": 1, "content": "下列排序算法中，平均而言时间复杂度最低的是（）。", "code": "", "answer": ["D"], "explanation": "上述排序算法平均时间复杂度分别为O(n^2), O(nlog n), O(n^1.25), O(n)", "source": "C1342", "subproblem": [{"content": "", "choice": ["选择排序", "快速排序", "希尔排序", "基数排序"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】若输出的字符串为“ABCABCABCA”，则下列说法正确的是（ ）", "code": "```c++\n#include&nbsp;&lt;cstdlib&gt;<br>\n#include&nbsp;&lt;iostream&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nchar&nbsp;encoder[26]&nbsp;=&nbsp;{&#39;C&#39;,&nbsp;&#39;S&#39;,&nbsp;&#39;P&#39;,&nbsp;0};<br>\nchar&nbsp;decoder[26];<br>\n<br>\nstring&nbsp;st;<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;k&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;26;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(encoder[i]&nbsp;!=&nbsp;0)&nbsp;++k;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(char&nbsp;x&nbsp;=&nbsp;&#39;A&#39;;&nbsp;x&nbsp;&lt;=&nbsp;&#39;Z&#39;;&nbsp;++x)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;flag&nbsp;=&nbsp;true;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;26;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(encoder[i]&nbsp;==&nbsp;x)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;false;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(flag)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encoder[k]&nbsp;=&nbsp;x;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++k;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;26;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decoder[encoder[i]&nbsp;-&nbsp;&#39;A&#39;]&nbsp;=&nbsp;i&nbsp;+&nbsp;&#39;A&#39;;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;st;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;st.length();&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;st[i]&nbsp;=&nbsp;decoder[st[i]&nbsp;-&nbsp;&#39;A&#39;];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;st;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["A"], "explanation": "输出的字符串为“ABCABCABCA”，所以输入需要有CSP。", "source": "C1343", "subproblem": [{"content": "", "choice": ["输入的字符串中既有S又有P", "输入的字符串中既有S又有B", "输入的字符串中既有A又有P", "输入的字符串中既有A又有B"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】若输出的字符串为“CSPCSPCSPCSP”，则下列说法正确的是（ ）", "code": "```C++\n#include&nbsp;&lt;cstdlib&gt;<br>\n#include&nbsp;&lt;iostream&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nchar&nbsp;encoder[26]&nbsp;=&nbsp;{&#39;C&#39;,&nbsp;&#39;S&#39;,&nbsp;&#39;P&#39;,&nbsp;0};<br>\nchar&nbsp;decoder[26];<br>\n<br>\nstring&nbsp;st;<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;k&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;26;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(encoder[i]&nbsp;!=&nbsp;0)&nbsp;++k;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(char&nbsp;x&nbsp;=&nbsp;&#39;A&#39;;&nbsp;x&nbsp;&lt;=&nbsp;&#39;Z&#39;;&nbsp;++x)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;flag&nbsp;=&nbsp;true;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;26;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(encoder[i]&nbsp;==&nbsp;x)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;false;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(flag)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encoder[k]&nbsp;=&nbsp;x;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++k;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;26;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decoder[encoder[i]&nbsp;-&nbsp;&#39;A&#39;]&nbsp;=&nbsp;i&nbsp;+&nbsp;&#39;A&#39;;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;st;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;st.length();&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;st[i]&nbsp;=&nbsp;decoder[st[i]&nbsp;-&nbsp;&#39;A&#39;];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;st;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["D"], "explanation": "因为输出的字符串带“CSP”，由于decoder序列是\"DEAFGHIJKLMNOPQCRSBTUVWXYZ”\t所以我们不难发现对应CSP这三位的是：PRN。", "source": "C1344", "subproblem": [{"content": "", "choice": ["输入的字符串中既有P又有K", "输入的字符串中既有J又有R", "输入的字符串中既有J又有K", "输入的字符串中既有P又有R"]}]}
{"classification": 1, "content": "有多少三位数，是11的倍数且三位数字都不同？", "code": "", "answer": ["D"], "explanation": "一个数被11整除，当且仅当奇数位的和与偶数位的和之差为11的倍数\n设三位数为abc，则a-b+c为11的倍数，又因为1-9+0<=a-b+c<=9-0+9=18\n所以a-b+c=0或a-b+c=11\n若a-b+c=0，即b=a+c，则a,c不为0，只要a,c不同且和不超过9即可，有2+2+4+4+6+6+8=32种\n若a-b+c=11，即11+b=a+c，则a,c不为0（否则不存在b），只要a,c不同且和大于10即可，有\n11：a=2,3,4,5,6,7,8,9，共8种\n12：a=3,4,5,7,8,9，共6种\n13：a=4,5,6,7,8,9，共6种\n14：a=5,6,8,9，共4种\n15：a=6,7,8,9，共4种\n16：a=7,9，共2种\n17：a=8,9，共2种\n一共32种\n综上所述，共32+32=64种\n", "source": "C1345", "subproblem": [{"content": "", "choice": ["24", "32", "56", "以上三项都不对"]}]}
{"classification": 1, "content": "小鸣和小明玩取石子游戏，每次可以取1或2或3或4个，取到最后一个石子的人获胜，开始有19个石子，小明取了3个，则小鸣下一步要取__个可以保证必胜", "code": "", "answer": ["A"], "explanation": "取1个，剩下15个，小明取a个则小鸣取5-a个\n其他取法，小明都有策略必胜\n", "source": "C1346", "subproblem": [{"content": "", "choice": ["1", "2", "3", "4"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】假设输入的 n 是不超过 2^{62} 的正整数，k 都是不超过10000 的正整数。\n\n若输入的 n 等于 10^{15} ，输入的 k 为 1，则输出等于（ ）。", "code": "```C++\n#include&nbsp;&lt;iostream&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nlong&nbsp;long&nbsp;n,&nbsp;ans;<br>\nint&nbsp;k,&nbsp;len;<br>\nlong&nbsp;long&nbsp;d[1000000];<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;n&nbsp;&gt;&gt;&nbsp;k;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;d[0]&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(long&nbsp;long&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++d[0];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;+&nbsp;1&nbsp;&lt;&nbsp;len;&nbsp;++j)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d[j]&nbsp;==&nbsp;k)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j]&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j&nbsp;+&nbsp;1]&nbsp;+=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ans;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d[len&nbsp;-&nbsp;1]&nbsp;==&nbsp;k)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[len&nbsp;-&nbsp;1]&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[len]&nbsp;=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++len;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ans;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;ans&nbsp;&lt;&lt;&nbsp;endl;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["D"], "explanation": "当k=1的时候，实际上就是不断的累加d[0]产生的贡献，因为每一次只有d[0]都等于1（即等于k），但是d[1]会变成2，然后不断的做累加。", "source": "C1347", "subproblem": [{"content": "", "choice": ["1", "(10^{30} - 10^{15})/2", "(10^{30} + 10^{15})/2", "10^{15}"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】假设输入的 n 是不超过 2^{62} 的正整数，k 都是不超过 10000 的正整数。\n\n若输入的 n 等于 205,891,132,094,649205,891,132,094,649（即 3^{30} ），输入的 k 为 3，则输出等于（ ）。", "code": "```C++\n#include&nbsp;&lt;iostream&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nlong&nbsp;long&nbsp;n,&nbsp;ans;<br>\nint&nbsp;k,&nbsp;len;<br>\nlong&nbsp;long&nbsp;d[1000000];<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;n&nbsp;&gt;&gt;&nbsp;k;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;d[0]&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(long&nbsp;long&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++d[0];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;+&nbsp;1&nbsp;&lt;&nbsp;len;&nbsp;++j)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d[j]&nbsp;==&nbsp;k)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j]&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j&nbsp;+&nbsp;1]&nbsp;+=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ans;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d[len&nbsp;-&nbsp;1]&nbsp;==&nbsp;k)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[len&nbsp;-&nbsp;1]&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[len]&nbsp;=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++len;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ans;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;ans&nbsp;&lt;&lt;&nbsp;endl;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["B"], "explanation": "因为k>1，所以ans=n/k+n/(k^{2})+n/(k^{3})+……。然后我们会发现，该式子是一个等比数列，利用等比数列求和公式，就可以求得答案。", "source": "C1348", "subproblem": [{"content": "", "choice": ["3^{30}", "(3^{30} - 1) / 2", "3^{30} - 1", "(3^{30} + 1) / 2"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】假设输入的 n 是不超过 2^{62} 的正整数，k 都是不超过 10000 的正整数。\n\n若输入的 n 等于 100,010,002,000,090，输入的 k 等于 10，则输出等于（ ）。", "code": "```C++\n#include&nbsp;&lt;iostream&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nlong&nbsp;long&nbsp;n,&nbsp;ans;<br>\nint&nbsp;k,&nbsp;len;<br>\nlong&nbsp;long&nbsp;d[1000000];<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;n&nbsp;&gt;&gt;&nbsp;k;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;d[0]&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(long&nbsp;long&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++d[0];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;+&nbsp;1&nbsp;&lt;&nbsp;len;&nbsp;++j)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d[j]&nbsp;==&nbsp;k)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j]&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j&nbsp;+&nbsp;1]&nbsp;+=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ans;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d[len&nbsp;-&nbsp;1]&nbsp;==&nbsp;k)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[len&nbsp;-&nbsp;1]&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[len]&nbsp;=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++len;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ans;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;ans&nbsp;&lt;&lt;&nbsp;endl;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["D"], "explanation": "答案等于10001000200009 + 1000100020000 + 100010002000 + 10001000200 + 1000100020 + 100010002  + 10001000 + 1000100 + 100010 + 10001 + 1000 + 100 + 10 + 1。", "source": "C1349", "subproblem": [{"content": "", "choice": ["11,112,222,444,543", "11,122,222,444,453", "11,122,222,444,543", "11,112,222,444,453"]}]}
{"classification": 1, "content": "以下数据结构中哪个是线性结构？", "code": "", "answer": ["B"], "explanation": "B", "source": "C1350", "subproblem": [{"content": "", "choice": ["有向图", "栈", "线索二叉树", "B树"]}]}
{"classification": 1, "content": "以下哪一个不是栈的基本运算", "code": "", "answer": ["B"], "explanation": "B", "source": "C1351", "subproblem": [{"content": "", "choice": ["删除栈顶元素", "删除栈底元素", "判断栈是否为空", "将栈置为空栈"]}]}
{"classification": 1, "content": "为了缓解计算机主机与打印机之间速度不匹配，通常设置一个打印数据缓冲区，主要将要输出的打印的数据依次写入该缓冲区，而打印机从该缓冲区中取出数据打印。该缓冲区是一个___结构", "code": "", "answer": ["C"], "explanation": "有一个入口一个出口，为队列", "source": "C1352", "subproblem": [{"content": "", "choice": ["堆栈", "数组", "队列", "链表"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】假设输入的 n 是不超过 50 的正整数，d[i][0]、d[i][1] 都是不超过 10000 的正整数。\n\n若输入的 n 为 20，接下来跌输入是 20 个 9 和 20 个 0，则输出为（ ）", "code": "```C++\n#include&nbsp;&lt;algorithm&gt;<br>\n#include&nbsp;&lt;iostream&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nint&nbsp;n;<br>\nint&nbsp;d[50][2];<br>\nint&nbsp;ans;<br>\n<br>\nvoid&nbsp;dfs(int&nbsp;n,&nbsp;int&nbsp;sum)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;1)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;max(sum,&nbsp;ans);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;d[i&nbsp;-&nbsp;1][0],&nbsp;b&nbsp;=&nbsp;d[i&nbsp;-&nbsp;1][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;d[i][0],&nbsp;y&nbsp;=&nbsp;d[i][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i&nbsp;-&nbsp;1][0]&nbsp;=&nbsp;a&nbsp;+&nbsp;x;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i&nbsp;-&nbsp;1][1]&nbsp;=&nbsp;b&nbsp;+&nbsp;y;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;i;&nbsp;j&nbsp;&lt;&nbsp;n&nbsp;-&nbsp;1;&nbsp;++j)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j][0]&nbsp;=&nbsp;d[j&nbsp;+&nbsp;1][0],&nbsp;d[j][1]&nbsp;=&nbsp;d[j&nbsp;+&nbsp;1][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;s&nbsp;=&nbsp;a&nbsp;+&nbsp;x&nbsp;+&nbsp;abs(b&nbsp;-&nbsp;y);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs(n&nbsp;-&nbsp;1,&nbsp;sum&nbsp;+&nbsp;s);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;n&nbsp;-&nbsp;1;&nbsp;j&nbsp;&gt;&nbsp;i;&nbsp;--j)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j][0]&nbsp;=&nbsp;d[j&nbsp;-&nbsp;1][0],&nbsp;d[j][1]&nbsp;=&nbsp;d[j&nbsp;-&nbsp;1][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i&nbsp;-&nbsp;1][0]&nbsp;=&nbsp;a,&nbsp;d[i&nbsp;-&nbsp;1][1]&nbsp;=&nbsp;b;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i][0]&nbsp;=&nbsp;x,&nbsp;d[i][1]&nbsp;=&nbsp;y;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n}<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;n;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;d[i][0];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;d[i][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dfs(n,&nbsp;0);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;ans&nbsp;&lt;&lt;&nbsp;endl;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["B"], "explanation": "当d[i][0]都等于9时候，n=2时，可以看成是2*9；n=3时，是5*9；n=4时，是9*9；假设，为n时候答案是ans[n]，则有ans[n + 1] = ans[n] + (n + 1) * 9。所以，答案等于(2+3+4+……+20)*9=19 * (20 + 2) / 2 * 9 = 1881。", "source": "C1353", "subproblem": [{"content": "", "choice": ["1890", "1881", "1908", "1917"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】假设输入的 n 是不超过 50 的正整数，d[i][0]、d[i][1] 都是不超过 10000 的正整数。\n\n若输入的 n 为 30，接下来的输入是 30 个 0 和 30 个 5，则输出为（ ）。", "code": "```C++\n#include&nbsp;&lt;algorithm&gt;<br>\n#include&nbsp;&lt;iostream&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nint&nbsp;n;<br>\nint&nbsp;d[50][2];<br>\nint&nbsp;ans;<br>\n<br>\nvoid&nbsp;dfs(int&nbsp;n,&nbsp;int&nbsp;sum)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;1)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;max(sum,&nbsp;ans);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;d[i&nbsp;-&nbsp;1][0],&nbsp;b&nbsp;=&nbsp;d[i&nbsp;-&nbsp;1][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;d[i][0],&nbsp;y&nbsp;=&nbsp;d[i][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i&nbsp;-&nbsp;1][0]&nbsp;=&nbsp;a&nbsp;+&nbsp;x;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i&nbsp;-&nbsp;1][1]&nbsp;=&nbsp;b&nbsp;+&nbsp;y;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;i;&nbsp;j&nbsp;&lt;&nbsp;n&nbsp;-&nbsp;1;&nbsp;++j)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j][0]&nbsp;=&nbsp;d[j&nbsp;+&nbsp;1][0],&nbsp;d[j][1]&nbsp;=&nbsp;d[j&nbsp;+&nbsp;1][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;s&nbsp;=&nbsp;a&nbsp;+&nbsp;x&nbsp;+&nbsp;abs(b&nbsp;-&nbsp;y);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs(n&nbsp;-&nbsp;1,&nbsp;sum&nbsp;+&nbsp;s);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;n&nbsp;-&nbsp;1;&nbsp;j&nbsp;&gt;&nbsp;i;&nbsp;--j)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j][0]&nbsp;=&nbsp;d[j&nbsp;-&nbsp;1][0],&nbsp;d[j][1]&nbsp;=&nbsp;d[j&nbsp;-&nbsp;1][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i&nbsp;-&nbsp;1][0]&nbsp;=&nbsp;a,&nbsp;d[i&nbsp;-&nbsp;1][1]&nbsp;=&nbsp;b;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i][0]&nbsp;=&nbsp;x,&nbsp;d[i][1]&nbsp;=&nbsp;y;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n}<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;n;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;d[i][0];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;d[i][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dfs(n,&nbsp;0);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;ans&nbsp;&lt;&lt;&nbsp;endl;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["C"], "explanation": "不难发现，当n≤2时，ans=0。再看，当n>2时候，n=3时，ans=1*5=5；n=4时，ans=3*5=15；ans=5时，ans=6*5=30。所以不难推出递推式，如果为n时候答案为ans[n]，则有ans[n+1] = ans[n] + (n - 2) * 5。这时候可以写个程序推出，ans[30] = 2030。\nfor(int i = 3; i <= 30; i ++) ans[i] = ans[i - 1] + (i - 2) * 5;", "source": "C1354", "subproblem": [{"content": "", "choice": ["2000", "2010", "2030", "2020"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】假设输入的 n 是不超过 50 的正整数，d[i][0]、d[i][1] 都是不超过 10000 的正整数。\n\n若输入的 n 为 15，接下来输入是 15 到 1，以及 15 到 1，则输出为（ ）。", "code": "```C++\n#include&nbsp;&lt;algorithm&gt;<br>\n#include&nbsp;&lt;iostream&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nint&nbsp;n;<br>\nint&nbsp;d[50][2];<br>\nint&nbsp;ans;<br>\n<br>\nvoid&nbsp;dfs(int&nbsp;n,&nbsp;int&nbsp;sum)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;1)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;max(sum,&nbsp;ans);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;d[i&nbsp;-&nbsp;1][0],&nbsp;b&nbsp;=&nbsp;d[i&nbsp;-&nbsp;1][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;d[i][0],&nbsp;y&nbsp;=&nbsp;d[i][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i&nbsp;-&nbsp;1][0]&nbsp;=&nbsp;a&nbsp;+&nbsp;x;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i&nbsp;-&nbsp;1][1]&nbsp;=&nbsp;b&nbsp;+&nbsp;y;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;i;&nbsp;j&nbsp;&lt;&nbsp;n&nbsp;-&nbsp;1;&nbsp;++j)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j][0]&nbsp;=&nbsp;d[j&nbsp;+&nbsp;1][0],&nbsp;d[j][1]&nbsp;=&nbsp;d[j&nbsp;+&nbsp;1][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;s&nbsp;=&nbsp;a&nbsp;+&nbsp;x&nbsp;+&nbsp;abs(b&nbsp;-&nbsp;y);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs(n&nbsp;-&nbsp;1,&nbsp;sum&nbsp;+&nbsp;s);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;n&nbsp;-&nbsp;1;&nbsp;j&nbsp;&gt;&nbsp;i;&nbsp;--j)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[j][0]&nbsp;=&nbsp;d[j&nbsp;-&nbsp;1][0],&nbsp;d[j][1]&nbsp;=&nbsp;d[j&nbsp;-&nbsp;1][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i&nbsp;-&nbsp;1][0]&nbsp;=&nbsp;a,&nbsp;d[i&nbsp;-&nbsp;1][1]&nbsp;=&nbsp;b;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i][0]&nbsp;=&nbsp;x,&nbsp;d[i][1]&nbsp;=&nbsp;y;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n}<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;n;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;d[i][0];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;++i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;d[i][1];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dfs(n,&nbsp;0);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;ans&nbsp;&lt;&lt;&nbsp;endl;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["C"], "explanation": "我们可以通过找规律的方式，分别枚举n=1、2、3、4、5的情况，会发现ans[n] = (n - 1) * n * (n + 1) / 6 * 4。则，可以发现ans[15] = 2240。", "source": "C1355", "subproblem": [{"content": "", "choice": ["2440", "2220", "2240", "2420"]}]}
{"classification": 1, "content": "CSP2021依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["B"], "explanation": "B", "source": "C1356", "subproblem": [{"content": "", "choice": ["CSP0221", "CSP1220", "CSP2201", "CSP2210"]}]}
{"classification": 1, "content": "CSP2021依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["D"], "explanation": "D", "source": "C1357", "subproblem": [{"content": "", "choice": ["PSC2021", "C20P21S", "PSC2201", "PSC1022"]}]}
{"classification": 1, "content": "CSP2021依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["D"], "explanation": "D", "source": "C1358", "subproblem": [{"content": "", "choice": ["PSC2012", "2012PSC", "02PS2C1", "2PS21C0"]}]}
{"classification": 1, "content": "CSP2021依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["C"], "explanation": "C", "source": "C1359", "subproblem": [{"content": "", "choice": ["2PC12S0", "P22C0S1", "02P2SC1", "SC22P01"]}]}
{"classification": 1, "content": "CSP2021依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["C"], "explanation": "C", "source": "C1360", "subproblem": [{"content": "", "choice": ["0S2P1C2", "122CPS0", "20PSC21", "P22S01C"]}]}
{"classification": 1, "content": "CSP2021依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["D"], "explanation": "D", "source": "C1361", "subproblem": [{"content": "", "choice": ["C20P1S2", "C20S12P", "P2SC102", "P2SC120"]}]}
{"classification": 1, "content": "CSP2022依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["A"], "explanation": "A", "source": "C1362", "subproblem": [{"content": "", "choice": ["02PCS22", "2PS022C", "CS2022P", "P202SC2"]}]}
{"classification": 1, "content": "CSP2022依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["B"], "explanation": "B", "source": "C1363", "subproblem": [{"content": "", "choice": ["02P22SC", "C20S22P", "02PSC22", "2P220SC"]}]}
{"classification": 1, "content": "CSP2022依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["C"], "explanation": "C", "source": "C1364", "subproblem": [{"content": "", "choice": ["C022P2S", "C20P2S2", "P0C222S", "P02SC22"]}]}
{"classification": 1, "content": "CSP2022依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["C"], "explanation": "C", "source": "C1365", "subproblem": [{"content": "", "choice": ["20PC22S", "22C2P0S", "20PS2C2", "22PC2S0"]}]}
{"classification": 1, "content": "CSP2022依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["B"], "explanation": "B", "source": "C1366", "subproblem": [{"content": "", "choice": ["2C202PS", "2220PSC", "022CP2S", "0222PCS"]}]}
{"classification": 1, "content": "CSP2022依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["D"], "explanation": "D", "source": "C1367", "subproblem": [{"content": "", "choice": ["CS22P20", "CP0S222", "202S2CP", "20P2S2C"]}]}
{"classification": 1, "content": "wabjtam依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["C"], "explanation": "C", "source": "C1368", "subproblem": [{"content": "", "choice": ["abjatwm", "atjbawm", "batamwj", "tajmbaw"]}]}
{"classification": 1, "content": "wabjtam依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["D"], "explanation": "D", "source": "C1369", "subproblem": [{"content": "", "choice": ["amwbjat", "btjwaam", "jwbaatm", "tamjbaw"]}]}
{"classification": 1, "content": "wabjtam依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["B"], "explanation": "B", "source": "C1370", "subproblem": [{"content": "", "choice": ["aatjbmw", "amtjbwa", "batmjaw", "wajtamb"]}]}
{"classification": 1, "content": "ioi2022依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["D"], "explanation": "D", "source": "C1371", "subproblem": [{"content": "", "choice": ["202io2i", "i202o2i", "ii2220o", "oi222i0"]}]}
{"classification": 1, "content": "ioi2022依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["B"], "explanation": "B", "source": "C1372", "subproblem": [{"content": "", "choice": ["i202io2", "ii0o222", "ioi0222", "oi0222i"]}]}
{"classification": 1, "content": "ioi2022依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["A"], "explanation": "A", "source": "C1373", "subproblem": [{"content": "", "choice": ["2ioi220", "2o02ii2", "i0o222i", "io22i20"]}]}
{"classification": 1, "content": "bilibili依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["C"], "explanation": "C", "source": "C1374", "subproblem": [{"content": "", "choice": ["bliiliib", "bilbilii", "bbiiiill", "libiibli"]}]}
{"classification": 1, "content": "bilibili依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["B"], "explanation": "B", "source": "C1375", "subproblem": [{"content": "", "choice": ["liliibib", " lbliibii", "ibibilli", "biblliii"]}]}
{"classification": 1, "content": "bilibili依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["C"], "explanation": "C", "source": "C1376", "subproblem": [{"content": "", "choice": ["lbbiilii", "lilbbiii", "iiliblib", "lblibiii"]}]}
{"classification": 1, "content": "apple依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["C"], "explanation": "C", "source": "C1377", "subproblem": [{"content": "", "choice": ["aplep", "lppea", "pealp", "pplea"]}]}
{"classification": 1, "content": "apple依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["B"], "explanation": "B", "source": "C1378", "subproblem": [{"content": "", "choice": ["aeplp", "lppae", "apepl", "peapl"]}]}
{"classification": 1, "content": "banana依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["D"], "explanation": "D", "source": "C1379", "subproblem": [{"content": "", "choice": ["aaannb", "abnnaa", "banaan", "naaabn"]}]}
{"classification": 1, "content": "banana依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["C"], "explanation": "C", "source": "C1380", "subproblem": [{"content": "", "choice": ["aannba", "anaban", "nbaaan", "nnaaab"]}]}
{"classification": 1, "content": "banana依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["B"], "explanation": "B", "source": "C1381", "subproblem": [{"content": "", "choice": ["aabann", "annaab", "nanbaa", "nnbaaa"]}]}
{"classification": 1, "content": "sheep依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["D"], "explanation": "D", "source": "C1382", "subproblem": [{"content": "", "choice": ["eehps", "heeps", "peehs", "pshee"]}]}
{"classification": 1, "content": "sheep依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["B"], "explanation": "B", "source": "C1383", "subproblem": [{"content": "", "choice": ["eehsp", "eesph", "ehspe", "heesp"]}]}
{"classification": 1, "content": "sheep依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["A"], "explanation": "A", "source": "C1384", "subproblem": [{"content": "", "choice": ["sehpe", "ehpse", "epshe", "phsee"]}]}
{"classification": 1, "content": "CCFCSP依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["D"], "explanation": "D", "source": "C1385", "subproblem": [{"content": "", "choice": ["CCCFPS", "CFCSPC", "CSCFPC", "CSPCCF"]}]}
{"classification": 1, "content": "CCFCSP依次入栈，则下列不可能的出栈序列为", "code": "", "answer": ["C"], "explanation": "C", "source": "C1386", "subproblem": [{"content": "", "choice": ["CCSCFP", "FCPSCC", "FCCPCS", "SCFCCP"]}]}
{"classification": 1, "content": "CCFCSP依次入栈，则下列可能的出栈序列为", "code": "", "answer": ["B"], "explanation": "B", "source": "C1387", "subproblem": [{"content": "", "choice": ["CFPCCS", "FSCPCC", "PCFCSC", "SFPCCC"]}]}
{"classification": 1, "content": "逻辑运算符中，运算优先级按从高到低依次为", "code": "", "answer": ["D"], "explanation": "考察逻辑运算符优先级", "source": "C1388", "subproblem": [{"content": "", "choice": ["&& ！ ||", "|| && ！", "&& || ！", "! && ||"]}]}
{"classification": 1, "content": "CCFCSP依次入栈，出栈序列也是CCFCSP，存在方案恰好使用大小为k的栈（“恰好”指k个位置都用过），则k=", "code": "", "answer": ["C"], "explanation": "一共4种方案，分别使用1,2,3,3栈空间", "source": "C1389", "subproblem": [{"content": "", "choice": ["1或2", "1或3", "1或2或3", "1或2或3或4"]}]}
{"classification": 1, "content": "CCFCSP依次入栈，栈的大小为3，则下列不可能的出栈序列为", "code": "", "answer": ["B"], "explanation": "B", "source": "C1390", "subproblem": [{"content": "", "choice": ["CCFPSC", "CCPSFC", "CFSCPC", "CFCCSP"]}]}
{"classification": 1, "content": "表达式!x||a==b 等效于", "code": "", "answer": ["D"], "explanation": "! 的优先级比 == 要高，== 优先级比 || 高，所以D中括号是可有可无的，", "source": "C1391", "subproblem": [{"content": "", "choice": ["!((x||a)==b)", "!(x||a)==b", "!(x||(a==b))", "(!x)||(a==b)"]}]}
{"classification": 1, "content": "ioi2022依次入栈，出栈序列是i2202oi，存在方案恰好使用大小为k的栈（“恰好”指k个位置都用过），则k不等于", "code": "", "answer": ["A"], "explanation": "一共3种方案，分别用了4,5,6栈空间", "source": "C1392", "subproblem": [{"content": "", "choice": ["3", "4", "5", "6"]}]}
{"classification": 1, "content": "ioi2022依次入栈，栈的大小为4，则下列不可能的出栈序列为", "code": "", "answer": ["D"], "explanation": "D至少用5", "source": "C1393", "subproblem": [{"content": "", "choice": ["i02oi22", "i2202oi", "i2o220i", "2220ioi"]}]}
{"classification": 1, "content": "ioi2022依次入栈，出栈序列是oi2022i，存在方案恰好使用大小为k的栈（“恰好”指k个位置都用过），则k不等于", "code": "", "answer": ["D"], "explanation": "存在恰使用2,3,4空间的方案", "source": "C1394", "subproblem": [{"content": "", "choice": ["2", "3", "4", "5"]}]}
{"classification": 1, "content": "ioi2022依次入栈，出栈序列是o2202ii，则栈的大小至少为__", "code": "", "answer": ["B"], "explanation": "B", "source": "C1395", "subproblem": [{"content": "", "choice": ["3", "4", "5", "6"]}]}
{"classification": 1, "content": "设整型变量 m,n,a,b,c,d 均为1，执行 ans=(m=a>b)&&(n=c>d)，后m,n的值是", "code": "", "answer": ["C"], "explanation": "先执行a>b，为0，所以m=0,&&前面是0后，&&后面的就不会执行了。", "source": "C1396", "subproblem": [{"content": "", "choice": ["0,0", "1,0", "0,1", "1,1"]}]}
{"classification": 1, "content": "设有语句 int a=3; 则执行语句 a+=a-=a*=a,后a的值是多少", "code": "", "answer": ["B"], "explanation": "从右往左计算，第一次运算 a=a*a,a的值等于9.第二个次运算后a的值为0，后面相加还是等于0", "source": "C1397", "subproblem": [{"content": "", "choice": ["3", "0", "9", "12"]}]}
{"classification": 1, "content": "在以下一组运算符中，优先级最低的运算符是", "code": "", "answer": ["D"], "explanation": "考察运算符的优先级", "source": "C1398", "subproblem": [{"content": "", "choice": ["*", "!=", "+", "="]}]}
{"classification": 1, "content": "设整型变量x=2,y=0,z=0，a,并且a=x||y&&z，那么a得值是多少", "code": "", "answer": ["B"], "explanation": "&&得优先级比||高", "source": "C1399", "subproblem": [{"content": "", "choice": ["0", "1", "2", "不确定"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】（质因数分解）给出正整数n，请输出将 n 质因数分解的结果，结果从小到大输出。\n\n例如：输入 n=120，程序应该输出 2 2 2 3 5，表示 120=2×2×2×3×5。输入保证 2 ≤ n ≤ 10^9 。提示：先从小到大枚举变量 i，然后用 i 不停试除 n 来寻找所有的质因子。\n\n试补全程序。\n①处应填（ ）", "code": "```C++\n#include&nbsp;&lt;cstdio&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nint&nbsp;n,&nbsp;i;<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;scanf(&quot;%d&quot;,&nbsp;&amp;n);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;①;&nbsp;②&nbsp;&lt;=&nbsp;n;&nbsp;i&nbsp;++)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&nbsp;&quot;,&nbsp;i);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;n&nbsp;/&nbsp;i;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(④)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&nbsp;&quot;,&nbsp;⑤);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["C"], "explanation": "要寻找质因子，所以我们应该从第一个质数2，开始进行循环遍历。", "source": "C1400", "subproblem": [{"content": "", "choice": ["1", "n - 1", "2", "0"]}]}
{"classification": 1, "content": "设整型变量a=0，b=0，c=a||b+2 的结果为", "code": "", "answer": ["B"], "explanation": "+运算符得优先级比||得优先级高，先进行加法计算，0||2结果为真。所以值为1", "source": "C1401", "subproblem": [{"content": "", "choice": ["0", "1", "2", "无法确定"]}]}
{"classification": 1, "content": "有如下逻辑表达式：!a||b&&!c||d的值，其中a=3,b=0,c=0,d=2", "code": "", "answer": ["B"], "explanation": "考察基本的逻辑运算，注意优先级就好", "source": "C1402", "subproblem": [{"content": "", "choice": ["0", "1", "2", "3"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】（质因数分解）给出正整数n，请输出将 n 质因数分解的结果，结果从小到大输出。\n\n例如：输入 n=120，程序应该输出 2 2 2 3 5，表示 120=2×2×2×3×5。输入保证 2 ≤ n ≤ 10^9 。提示：先从小到大枚举变量 i，然后用 i 不停试除 n 来寻找所有的质因子。\n\n试补全程序。\n②处应填（ ）", "code": "```C++\n#include&nbsp;&lt;cstdio&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nint&nbsp;n,&nbsp;i;<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;scanf(&quot;%d&quot;,&nbsp;&amp;n);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;①;&nbsp;②&nbsp;&lt;=&nbsp;n;&nbsp;i&nbsp;++)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&nbsp;&quot;,&nbsp;i);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;n&nbsp;/&nbsp;i;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(④)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&nbsp;&quot;,&nbsp;⑤);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["C"], "explanation": "n的最大的可能的质因子是sqrt(n)，否则就说明n是一个质数，或者说n=1。所以，我们只需要查质因子查到sqrt(n)就可以了。", "source": "C1403", "subproblem": [{"content": "", "choice": ["n / i", "n / (i * i)", "i * i", "i * i * i"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】（质因数分解）给出正整数n，请输出将 n 质因数分解的结果，结果从小到大输出。\n\n例如：输入 n=120，程序应该输出 2 2 2 3 5，表示 120=2×2×2×3×5。输入保证 2 ≤ n ≤ 10^9 。提示：先从小到大枚举变量 i，然后用 i 不停试除 n 来寻找所有的质因子。\n\n试补全程序。\n③处应填（ ）", "code": "```C++\n#include&nbsp;&lt;cstdio&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nint&nbsp;n,&nbsp;i;<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;scanf(&quot;%d&quot;,&nbsp;&amp;n);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;①;&nbsp;②&nbsp;&lt;=&nbsp;n;&nbsp;i&nbsp;++)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&nbsp;&quot;,&nbsp;i);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;n&nbsp;/&nbsp;i;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(④)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&nbsp;&quot;,&nbsp;⑤);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["C"], "explanation": "当i是当前n的质因子的时候，我们就需要不断的将n除去当前的i，并且输出这个i，表示i是n的一个质因子。", "source": "C1404", "subproblem": [{"content": "", "choice": ["if(n % i == 0)", "if(i * i <= n)", "while(n % i == 0)", "While(i * i <= n)"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】（质因数分解）给出正整数n，请输出将 n 质因数分解的结果，结果从小到大输出。\n\n例如：输入 n=120，程序应该输出 2 2 2 3 5，表示 120=2×2×2×3×5。输入保证 2 ≤ n ≤ 10^9 。提示：先从小到大枚举变量 i，然后用 i 不停试除 n 来寻找所有的质因子。\n\n试补全程序。\n④处应填（ ）", "code": "```C++\n#include&nbsp;&lt;cstdio&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nint&nbsp;n,&nbsp;i;<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;scanf(&quot;%d&quot;,&nbsp;&amp;n);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;①;&nbsp;②&nbsp;&lt;=&nbsp;n;&nbsp;i&nbsp;++)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&nbsp;&quot;,&nbsp;i);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;n&nbsp;/&nbsp;i;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(④)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&nbsp;&quot;,&nbsp;⑤);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["A"], "explanation": "如果最后得到的n是一个大于1的数，说明现在的n本身是一个质数，我们需要将它输出。", "source": "C1405", "subproblem": [{"content": "", "choice": ["n > 1", "n <= 1", "i + i <= n", "i < n / i"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】（质因数分解）给出正整数n，请输出将 n 质因数分解的结果，结果从小到大输出。\n\n例如：输入 n=120，程序应该输出 2 2 2 3 5，表示 120=2×2×2×3×5。输入保证 2 ≤ n ≤ 10^9 。提示：先从小到大枚举变量 i，然后用 i 不停试除 n 来寻找所有的质因子。\n\n试补全程序。\n⑤处应填（ ）", "code": "```C++\n#include&nbsp;&lt;cstdio&gt;<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nint&nbsp;n,&nbsp;i;<br>\n<br>\nint&nbsp;main()&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;scanf(&quot;%d&quot;,&nbsp;&amp;n);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;①;&nbsp;②&nbsp;&lt;=&nbsp;n;&nbsp;i&nbsp;++)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&nbsp;&quot;,&nbsp;i);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;n&nbsp;/&nbsp;i;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(④)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&nbsp;&quot;,&nbsp;⑤);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["C"], "explanation": "如果n>1，说明最后剩下的n是一个质数，那么，我们最后只需要输出n就可以了。", "source": "C1406", "subproblem": [{"content": "", "choice": ["2", "n / i", "n", "i"]}]}
{"classification": 1, "content": "有如下逻辑表达式：a||b的值，其中a=3,b=0", "code": "", "answer": ["B"], "explanation": "逻辑运算符 || 当左右两边有一个为真时答案就是真，整数只要不是0都表示是真的", "source": "C1407", "subproblem": [{"content": "", "choice": ["0", "1", "2", "3"]}]}
{"classification": 1, "content": "有如下逻辑表达式：a&&b的值，其中a=3,b=0", "code": "", "answer": ["A"], "explanation": "逻辑运算符 && 当左右两边都为真时答案就是真，整数只要不是0都表示是真的", "source": "C1408", "subproblem": [{"content": "", "choice": ["0", "1", "2", "3"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】（最小区间覆盖）给出 nn 个区间，第 i 个区间的左右端点是[ai, bi]。现在要在这些区间中选出若干个，使得区间 [0,m] 被所选区间的并覆盖（即每一个 0≤i≤m 都在某个所选的区间中）。保证答案存在，求所选区间个数的最小值。\n\n输入第一行包含两个整数 n 和 m（1≤n≤5000, 1≤m≤10^{9} ）。\n\n接下来 n 行，每行两个证书ai, bi（0≤ai​，bi ≤m）。\n\n提示：使用贪心法解决这个问题。先用O(N^{2})的时间复杂度排序，然后贪心选择这些区间。\n\n试补全程序。\n①处应填（ ）。", "code": "```C++\n#include&nbsp;&lt;iostream&gt;<br>\n<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nconst&nbsp;int&nbsp;MAXN&nbsp;=&nbsp;5000;<br>\nint&nbsp;n,&nbsp;m;<br>\nstruct&nbsp;segment&nbsp;{&nbsp;int&nbsp;a,&nbsp;b;&nbsp;}&nbsp;A[MAXN];<br>\n<br>\nvoid&nbsp;sort()&nbsp;//&nbsp;排序<br>\n{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;j++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(①)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segment&nbsp;t&nbsp;=&nbsp;A[j];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n}<br>\n<br>\nint&nbsp;main()<br>\n{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;n&nbsp;&gt;&gt;&nbsp;m;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;A[i].a&nbsp;&gt;&gt;&nbsp;A[i].b;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;sort();<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;p&nbsp;=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(③)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[p++]&nbsp;=&nbsp;A[i];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;p;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ans&nbsp;=&nbsp;0,&nbsp;r&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;q&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(r&nbsp;&lt;&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(④)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q++;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans++;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;ans&nbsp;&lt;&lt;&nbsp;endl;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["B"], "explanation": "首先，要做的这个排序，是对这n个区间的左端点进行升序排列，也就是说，当A[j]的左端点要比A[j - 1]的左端点更左的时候，我们需要交换一下顺序。", "source": "C1409", "subproblem": [{"content": "", "choice": ["A[j].b > A[j - 1].b", "A[j].a < A[j - 1].a", "A[j].a > A[j - 1].a", "A[j].b < A[j - 1].b"]}]}
{"classification": 1, "content": "对图的遍历分为深度优先和广度优先，下面关于两种遍历方法的描述，错误的是", "code": "", "answer": ["A"], "explanation": "考虑对一个简单环的深度优先遍历，最后到达起点的相邻点", "source": "C1410", "subproblem": [{"content": "", "choice": ["深度优先遍历中，不计边权，最后到达的点距离起点最远", "广度优先遍历中，不计边权，最后到达的点距离起点最远", "对连通图作深度优先遍历时，在任一点处改为广度优先遍历，仍能遍历全图", "对连通图作广度优先遍历时，在某时刻改为从队列中各点分别深度优先遍历，仍能遍历全图"]}]}
{"classification": 1, "content": "设整型变量a=2，!!a 的值是多少", "code": "", "answer": ["B"], "explanation": "! 表示逻辑取反，只要a不为0，就是真，可以用1或者true表示，!取反为0，再取反为1，所以答案1。", "source": "C1411", "subproblem": [{"content": "", "choice": ["0", "1", "2", "无法确定"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】（最小区间覆盖）给出 nn 个区间，第 i 个区间的左右端点是[ai, bi]。现在要在这些区间中选出若干个，使得区间 [0,m] 被所选区间的并覆盖（即每一个 0≤i≤m 都在某个所选的区间中）。保证答案存在，求所选区间个数的最小值。\n\n输入第一行包含两个整数 n 和 m（1≤n≤5000, 1≤m≤10^{9} ）。\n\n接下来 n 行，每行两个证书ai, bi（0≤ai​，bi ≤m）。\n\n提示：使用贪心法解决这个问题。先用O(N^{2})的时间复杂度排序，然后贪心选择这些区间。\n\n试补全程序。\n②处应填（ ）。", "code": "```C++\n#include&nbsp;&lt;iostream&gt;<br>\n<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nconst&nbsp;int&nbsp;MAXN&nbsp;=&nbsp;5000;<br>\nint&nbsp;n,&nbsp;m;<br>\nstruct&nbsp;segment&nbsp;{&nbsp;int&nbsp;a,&nbsp;b;&nbsp;}&nbsp;A[MAXN];<br>\n<br>\nvoid&nbsp;sort()&nbsp;//&nbsp;排序<br>\n{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;j++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(①)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segment&nbsp;t&nbsp;=&nbsp;A[j];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n}<br>\n<br>\nint&nbsp;main()<br>\n{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;n&nbsp;&gt;&gt;&nbsp;m;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;A[i].a&nbsp;&gt;&gt;&nbsp;A[i].b;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;sort();<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;p&nbsp;=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(③)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[p++]&nbsp;=&nbsp;A[i];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;p;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ans&nbsp;=&nbsp;0,&nbsp;r&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;q&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(r&nbsp;&lt;&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(④)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q++;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans++;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;ans&nbsp;&lt;&lt;&nbsp;endl;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["D"], "explanation": "首先，我们将A[j]的值存下来了，于是，就可以先把A[j-1]的值递给A[j]，然后我们再把之前存下来的A[j]值的t赋值给A[j-1]就可以了。", "source": "C1412", "subproblem": [{"content": "", "choice": ["A[j + 1] = A[j]; A[j] = t;", "A[j - 1] = A[j]; A[j] = t;", "A[j] = A[j + 1]; A[j + 1] = t;", "A[j] = A[j - 1]; A[j - 1] = t;"]}]}
{"classification": 1, "content": "以下伪代码\ndouble x,y;\nx=1;y=x+3/2;\ncout<<y<<endl;\n的输出为", "code": "", "answer": ["B"], "explanation": "3和2都是整型，相除后就是1，1+1=2，cout输出会输出2", "source": "C1413", "subproblem": [{"content": "", "choice": ["1", "2", "2.0", "2.5"]}]}
{"classification": 1, "content": "以下伪代码\ndouble x,y;\nx=1;y=x+3/2.0;\ncout<<y<<endl;\n的输出为", "code": "", "answer": ["D"], "explanation": "3是整型，2.0是浮点型，相除后是浮点数1.5，相加答案为2.5", "source": "C1414", "subproblem": [{"content": "", "choice": ["1", "2", "2.0", "2.5"]}]}
{"classification": 1, "content": "设a=1,b=2,c=3,d=4，则表达式：(a<b?a:c<d?a:d) 的结果为", "code": "", "answer": ["A"], "explanation": "三目运算符，第一个判断，a<b是满足的所以选择的是 : 前面的，所以答案是a及1", "source": "C1415", "subproblem": [{"content": "", "choice": ["1", "2", "3", "4"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】（最小区间覆盖）给出 nn 个区间，第 i 个区间的左右端点是[ai, bi]。现在要在这些区间中选出若干个，使得区间 [0,m] 被所选区间的并覆盖（即每一个 0≤i≤m 都在某个所选的区间中）。保证答案存在，求所选区间个数的最小值。\n\n输入第一行包含两个整数 n 和 m（1≤n≤5000, 1≤m≤10^{9} ）。\n\n接下来 n 行，每行两个证书ai, bi（0≤ai​，bi ≤m）。\n\n提示：使用贪心法解决这个问题。先用O(N^{2})的时间复杂度排序，然后贪心选择这些区间。\n\n试补全程序。\n③处应填（ ）。", "code": "```C++\n#include&nbsp;&lt;iostream&gt;<br>\n<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nconst&nbsp;int&nbsp;MAXN&nbsp;=&nbsp;5000;<br>\nint&nbsp;n,&nbsp;m;<br>\nstruct&nbsp;segment&nbsp;{&nbsp;int&nbsp;a,&nbsp;b;&nbsp;}&nbsp;A[MAXN];<br>\n<br>\nvoid&nbsp;sort()&nbsp;//&nbsp;排序<br>\n{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;j++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(①)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segment&nbsp;t&nbsp;=&nbsp;A[j];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n}<br>\n<br>\nint&nbsp;main()<br>\n{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;n&nbsp;&gt;&gt;&nbsp;m;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;A[i].a&nbsp;&gt;&gt;&nbsp;A[i].b;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;sort();<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;p&nbsp;=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(③)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[p++]&nbsp;=&nbsp;A[i];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;p;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ans&nbsp;=&nbsp;0,&nbsp;r&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;q&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(r&nbsp;&lt;&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(④)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q++;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans++;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;ans&nbsp;&lt;&lt;&nbsp;endl;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["A"], "explanation": "对于已经排好序的n个区间，现在要做的是将右端点比当前右端点更大的区间放进新的集合里。", "source": "C1416", "subproblem": [{"content": "", "choice": ["A[i].b > A[p - 1].b", "A[i].b < A[i - 1].b", "A[i].b > A[i - 1].b", "A[i].b < A[p - 1].b"]}]}
{"classification": 1, "content": "栈是常见的线性表，支持 push 和 pop 操作且均可在 O(1) 的时间内完成，现在为栈提供一系列新的操作 pop_k，执行 pop_k 操作将会连续执行 k 次 pop 操作（或在栈空时停止），现对一空栈作 n 次 push，pop 或 pop_k 操作（k是任意正整数），则执行这一操作序列的时间复杂度是", "code": "", "answer": ["D"], "explanation": "至多发生了n次push因此至多由n次pop，事实上A和B选项对应了相同的函数集合", "source": "C1417", "subproblem": [{"content": "", "choice": ["O(n^2)", "O(2 n^2)", "O(n log n)", "O(n)"]}]}
{"classification": 1, "content": "以下运算符中，结合性与其他运算符不同的是", "code": "", "answer": ["A"], "explanation": "++是自增，其他都是四则运算", "source": "C1418", "subproblem": [{"content": "", "choice": ["++", "*", "/", "+"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】（最小区间覆盖）给出 nn 个区间，第 i 个区间的左右端点是[ai, bi]。现在要在这些区间中选出若干个，使得区间 [0,m] 被所选区间的并覆盖（即每一个 0≤i≤m 都在某个所选的区间中）。保证答案存在，求所选区间个数的最小值。\n\n输入第一行包含两个整数 n 和 m（1≤n≤5000, 1≤m≤10^{9} ）。\n\n接下来 n 行，每行两个证书ai, bi（0≤ai​，bi ≤m）。\n\n提示：使用贪心法解决这个问题。先用O(N^{2})的时间复杂度排序，然后贪心选择这些区间。\n\n试补全程序。\n④处应填（ ）。", "code": "```C++\n#include&nbsp;&lt;iostream&gt;<br>\n<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nconst&nbsp;int&nbsp;MAXN&nbsp;=&nbsp;5000;<br>\nint&nbsp;n,&nbsp;m;<br>\nstruct&nbsp;segment&nbsp;{&nbsp;int&nbsp;a,&nbsp;b;&nbsp;}&nbsp;A[MAXN];<br>\n<br>\nvoid&nbsp;sort()&nbsp;//&nbsp;排序<br>\n{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;j++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(①)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segment&nbsp;t&nbsp;=&nbsp;A[j];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n}<br>\n<br>\nint&nbsp;main()<br>\n{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;n&nbsp;&gt;&gt;&nbsp;m;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;A[i].a&nbsp;&gt;&gt;&nbsp;A[i].b;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;sort();<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;p&nbsp;=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(③)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[p++]&nbsp;=&nbsp;A[i];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;p;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ans&nbsp;=&nbsp;0,&nbsp;r&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;q&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(r&nbsp;&lt;&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(④)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q++;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans++;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;ans&nbsp;&lt;&lt;&nbsp;endl;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["A"], "explanation": "为了满足中间不间断，所以已经填满的区间的最右端点为r，那么现在需要放进去一个区间，它必须满足它的左端点是小于等于r的，不然会存在中间存在没有被覆盖的点。又因为下标是从0开始到n-1的，所以需要满足q + 1 < n并且我们最好选择更优的点，而现在的集合中，右端点也是升序的存下来的，所以我们贪心的想，如果q + 1也满足条件的话，我们最好选择下一位，所以选择A。", "source": "C1419", "subproblem": [{"content": "", "choice": ["q + 1 < n && A[q + 1].a <= r", "q + 1 < n && A[q + 1].b <= r", "q < n && A[q].a <= r", "q < n && A[q].b <= r"]}]}
{"classification": 1, "content": "【2020CSP-J1入门级初赛】（最小区间覆盖）给出 nn 个区间，第 i 个区间的左右端点是[ai, bi]。现在要在这些区间中选出若干个，使得区间 [0,m] 被所选区间的并覆盖（即每一个 0≤i≤m 都在某个所选的区间中）。保证答案存在，求所选区间个数的最小值。\n\n输入第一行包含两个整数 n 和 m（1≤n≤5000, 1≤m≤10^{9} ）。\n\n接下来 n 行，每行两个证书ai, bi（0≤ai​，bi ≤m）。\n\n提示：使用贪心法解决这个问题。先用O(N^{2})的时间复杂度排序，然后贪心选择这些区间。\n\n试补全程序。\n⑤处应填（ ）。", "code": "```C++\n#include&nbsp;&lt;iostream&gt;<br>\n<br>\nusing&nbsp;namespace&nbsp;std;<br>\n<br>\nconst&nbsp;int&nbsp;MAXN&nbsp;=&nbsp;5000;<br>\nint&nbsp;n,&nbsp;m;<br>\nstruct&nbsp;segment&nbsp;{&nbsp;int&nbsp;a,&nbsp;b;&nbsp;}&nbsp;A[MAXN];<br>\n<br>\nvoid&nbsp;sort()&nbsp;//&nbsp;排序<br>\n{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;j++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(①)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segment&nbsp;t&nbsp;=&nbsp;A[j];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n}<br>\n<br>\nint&nbsp;main()<br>\n{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;n&nbsp;&gt;&gt;&nbsp;m;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;A[i].a&nbsp;&gt;&gt;&nbsp;A[i].b;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;sort();<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;p&nbsp;=&nbsp;1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(③)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[p++]&nbsp;=&nbsp;A[i];<br>\n&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;p;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ans&nbsp;=&nbsp;0,&nbsp;r&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;q&nbsp;=&nbsp;0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(r&nbsp;&lt;&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(④)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q++;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans++;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;ans&nbsp;&lt;&lt;&nbsp;endl;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>\n}", "answer": ["B"], "explanation": "不难发现，第q个区间是我们此时的最优解，于是我们需要用它来更新r值，区间覆盖从原来的r变成了max(r, A[q].b)。", "source": "C1420", "subproblem": [{"content": "", "choice": ["r = max(r, A[q + 1].b)", "r = max(r, A[q].b)", "r = max(r, A[q + 1].a)", "q++"]}]}
{"classification": 1, "content": "请求出以下伪代码的输出结果:\nint a=b=1;\ncout<<(a==b)<<endl;", "code": "", "answer": ["C"], "explanation": "a和b相等，答案就是1", "source": "C1421", "subproblem": [{"content": "", "choice": ["true", "flase", "1", "0"]}]}
{"classification": 1, "content": "设a=1,b=1,c=1,d=0,以下逻辑运算表达式值为假的是", "code": "", "answer": ["C"], "explanation": "逻辑表达，注意审题，和计算优先级", "source": "C1422", "subproblem": [{"content": "", "choice": ["a&&(d||!c)||b", "a&&d||!c||b", "a&&d||!c||!b", "!a&&d||!c||b"]}]}
{"classification": 1, "content": "在找零时，我们通常不断地选取可用的最大面额来得到一个方案，例如需要找零27元，可用面额有1，5，10元时，我们依次选取了10，10，5，1，1得到找零方案。假设每种面额的可用数量足够多，对于这一策略，对于选项中给出的面额，对某个金额进行用上述策略找零，下面的说法正确的是", "code": "", "answer": ["C"], "explanation": "以C选项的面额找零10元时会得到方案6，1，1，1，1，但是显然可以通过两张5得到10元", "source": "C1423", "subproblem": [{"content": "", "choice": ["此方案总是最优的，即所用的钱币数量是最少的", "此方案不一定是最优的，面额1，2，4，8可以作为反例", "此方案不一定是最优的，面额1，5，6，25可以作为反例", "此方案不一定是最优的，面额1，5，10，25可以作为反例"]}]}
{"classification": 1, "content": "对二叉树可以进行前序，中序或后序遍历，关于这些遍历序，以下说法正确的有\n    ①已知中序和后序遍历，可以求前序遍历\n    ②已知前序和后序遍历，可以求中序遍历\n    ③已知前序和中序遍历，可以求后序遍历", "code": "", "answer": ["B"], "explanation": "已知前序和中序时，可以首先确定根节点，随后递归的研究一个子树的前序和中序，即可得到树结构，对于B，考虑前序遍历12，后序遍历21，则无法确定根节点。", "source": "C1424", "subproblem": [{"content": "", "choice": ["①②", "①③", "②③", "①②③"]}]}
{"classification": 1, "content": "7枚硬币有5枚重量相等，2枚假币要重一些。现有一台无砝码的天平（即给定两组硬币，可以判断哪边重或者一样重），则至少要称几次才能找到两枚假币？", "code": "", "answer": ["B"], "explanation": "第一次在两边各放3个\n如果一样重，说明各有一枚假币和2枚真币。对于每一组，取两枚称量，如果一样重则剩下的那枚是假币，否则重的一枚是假币。这种情况要称3次。\n如果不一样重，要么重的一边有1枚假币，剩下的1枚是假币（情况1）；要么重的一边有2枚假币（情况2）。\n用剩下的一枚和轻的那边的一枚互换，如果两边一样重则是情况1，再称一次得到另一边的假币；如果仍然是另一边重则是情况2，再称一次可以得到另一边的两枚假币。\n因此3次可以称出假币。\n\n2次不能称出假币。可以令两边数量不相等的时候总是多的一边重，则只有两边一样多时才能获得信息。\n4枚硬币含一枚假币，则1次不能保证称出假币。\n4枚含2枚假币，1次不能称出假币。\n假设第一次每边称了a个，如果a=1，假设第一次取的都是真币，则剩下的硬币1次不能找到2枚假币；\n如果a=2，假设第一次取的每边一真一假，则再一次不能区分每边的假币；\n如果a=3，假设第一次取的每边有2真1假，则再一次不能区分每边的假币。\n", "source": "C1425", "subproblem": [{"content": "", "choice": ["2", "3", "4", "5"]}]}
{"classification": 1, "content": "定义二叉树的高度为根的左右子树高度的最大值+1，空树高度为0，则高度为13的二叉树最多有（）个结点。", "code": "", "answer": ["C"], "explanation": "可用数学归纳法证明，高度为n的二叉树最多有2^n-1个结点", "source": "C1426", "subproblem": [{"content": "", "choice": ["4095", "4096", "8191", "8192"]}]}
{"classification": 1, "content": "19个节点的二叉树最多有（）个叶子节点。", "code": "", "answer": ["B"], "explanation": "节点的度：一个节点拥有的子树数\n叶子节点：度为0的节点\n排成完全二叉树时的叶子节点最多，n个点的完全二叉树的非叶节点有 [n/2] 个。", "source": "C1427", "subproblem": [{"content": "", "choice": ["9", "10", "11", "18"]}]}
{"classification": 1, "content": "996个节点的完全二叉树有（）个叶子结点。", "code": "", "answer": ["B"], "explanation": "n个节点的完全二叉树有[n/2]个非叶节点和n-[n/2]个叶节点。", "source": "C1428", "subproblem": [{"content": "", "choice": ["497", "498", "499", "500"]}]}
{"classification": 1, "content": "100个节点的连通图至少有（）条边。", "code": "", "answer": ["B"], "explanation": "n 个点的连通图至少有 n-1 条边（构成一棵树），可以利用数学归纳法证明", "source": "C1430", "subproblem": [{"content": "", "choice": ["50", "99", "100", "4950"]}]}
{"classification": 1, "content": "图G有6个点，度数分别为5,3,2,2,1,1，则G有（）条边。", "code": "", "answer": ["B"], "explanation": "边数=度数之和/2", "source": "C1431", "subproblem": [{"content": "", "choice": ["5", "7", "12", "14"]}]}
{"classification": 1, "content": "A,B,C,D四个班级一共派出15个同学参加CSP，每班派出的人数各不相同，A班和B班一共派出6人，B班和C班一共派出7人，有一个班级派出了4人，是__班", "code": "", "answer": ["B"], "explanation": "若A=4则B=2,C=5,D=4不符合\n若B=4则A=2,C=3,D=6\n若C=4则B=3=A不符合\n若D=4则A+B+C=11，C=5,A=4不符合\n", "source": "C1432", "subproblem": [{"content": "", "choice": ["A", "B", "C", "D"]}]}
{"classification": 1, "content": "A,B,C,D四个班级一共派出15个同学参加CSP，每班派出的人数各不相同，A班和B班一共派出6人，B班和C班一共派出7人，有一个班级派出了4人，是__班", "code": "", "answer": ["B"], "explanation": "若A=4则B=2,C=5,D=4不符合\n若B=4则A=2,C=3,D=6\n若C=4则B=3=A不符合\n若D=4则A+B+C=11，C=5,A=4不符合\n", "source": "C1433", "subproblem": [{"content": "", "choice": ["A", "B", "D", "B或D"]}]}
{"classification": 1, "content": "独根树高度为1，则具有114514个节点的完全二叉树高度为（）。", "code": "", "answer": ["B"], "explanation": "节点数在 [2^n, 2^{n+1}-1] 范围内的二叉树高度为 n+1", "source": "C1434", "subproblem": [{"content": "", "choice": ["16", "17", "18", "1919810"]}]}
{"classification": 1, "content": "若无向图 G=(V, E) 中含11个顶点，要保证G在任何情况下都是连通的，则需要的边数至少是（）。", "code": "", "answer": ["C"], "explanation": "若G不连通，则边数一定不超过一个 k 阶完全图和一个 11-k 阶完全图的边数之和，即不超过45。因此当边数>=46时一定连通。", "source": "C1435", "subproblem": [{"content": "", "choice": ["55", "50", "46", "10"]}]}
{"classification": 1, "content": "n个点的完全图有（）条边。", "code": "", "answer": ["B"], "explanation": "两两之间连一条边，共C(n,2)=n(n-1)/2条边。", "source": "C1439", "subproblem": [{"content": "", "choice": ["n-1", "n(n-1)/2", "n(n+1)/2", "n^2"]}]}
{"classification": 1, "content": "n个点的完全有向图有（）条边。", "code": "", "answer": ["C"], "explanation": "边数为完全图边数的2倍", "source": "C1440", "subproblem": [{"content": "", "choice": ["n-1", "n", "n(n-1)", "n(n+1)"]}]}
{"classification": 1, "content": "独根树高度为1。一棵高度为 h 的满 k 叉树结点数为（）。", "code": "", "answer": ["B"], "explanation": "第 i 层结点数为 k^{i-1}，利用等比数列求和公式可求得总结点数。", "source": "C1441", "subproblem": [{"content": "", "choice": ["(k^{h+1}-1)/(k-1)", "(k^h-1)/(k-1)", "k^{h-1}", "k^h-k+1"]}]}
{"classification": 1, "content": "给一张 n 个点的完全图的边染色，每条边能且只能染红、蓝两种颜色之一。当 n 至少为（）时，可以确保图中存在一个同色三角形。", "code": "", "answer": ["B"], "explanation": "这是Ramsey问题最简单的一种情况。5阶完全图的反例可以构造一个红色五边形套蓝色五角星，6阶完全图可以用鸽笼原理证明。", "source": "C1442", "subproblem": [{"content": "", "choice": ["5", "6", "8", "18"]}]}
{"classification": 1, "content": "一棵7层的满二叉树有（）个结点。", "code": "", "answer": ["B"], "explanation": "n 层满二叉树有 2^n-1 个结点", "source": "C1443", "subproblem": [{"content": "", "choice": ["128", "127", "64", "63"]}]}
{"classification": 1, "content": "有向图中所有顶点的入度之和等于（）。", "code": "", "answer": ["A"], "explanation": "每条边贡献1个入度和1个出度", "source": "C1444", "subproblem": [{"content": "", "choice": ["所有顶点的出度之和", "所有顶点的入度与出度之差", "所有顶点的入度与出度之和", "所有顶点的度数之和"]}]}
{"classification": 1, "content": "中缀表达式与表达式树的（）遍历对应。", "code": "", "answer": ["B"], "explanation": "中缀表达式对应中序，前缀表达式对应前序，后缀表达式对应后序", "source": "C1445", "subproblem": [{"content": "", "choice": ["前序", "中序", "后序", "层序"]}]}
{"classification": 1, "content": "以下哪种排序算法不是基于比较的?", "code": "", "answer": ["D"], "explanation": "桶排序的工作原理是将数组分配到有限数量的桶里,每个桶再个别排序。它不受比较排序 O(n log n) 下限的影响", "source": "C1446", "subproblem": [{"content": "", "choice": ["快速排序", "插入排序", "堆排序", "桶排序"]}]}
{"classification": 1, "content": "以下搜索不属于分支限界法的是（）。", "code": "", "answer": ["D"], "explanation": "分支限界法的策略是：每次在扩展结点处，先生成所有的子结点(分支)，然后从当前的活结点表中选择下一个扩展结点。而深度优先是采用回溯法。", "source": "C1447", "subproblem": [{"content": "", "choice": ["最小损耗优先", "广度优先", "最大效益优先", "深度优先"]}]}
{"classification": 1, "content": "下列排序算法中，使用额外空间最多的是（）。", "code": "", "answer": ["B"], "explanation": "归并排序需要使用 O(n) 的额外空间", "source": "C1448", "subproblem": [{"content": "", "choice": ["插入排序", "归并排序", "快速排序", "希尔排序"]}]}
{"classification": 1, "content": "二叉树T，已知其先根遍历是1 2 5 4 3 7 6（数字为结点的编号，以下同），中根遍历是2 5 1 3 7 4 6，则该二叉树的后根遍历是（ ）。", "code": "", "answer": ["B"], "explanation": "根据前序和中序遍历，构建出树的形态，再求出后序遍历", "source": "C1449", "subproblem": [{"content": "", "choice": ["5 2 3 7 6 4 1", "5 2 7 3 6 4 1", "7 5 2 4 6 3 1", "5 2 7 6 3 4 1"]}]}
{"classification": 1, "content": "对有序数组{5, 13, 19, 21, 37, 56, 64, 75, 88, 92,100, 114, 514, 810, 1919}进行二分查找，成功查找元素100的查找长度（比较次数）是（ ）", "code": "", "answer": ["C"], "explanation": "模拟二分答案的过程，第4次恰好查找到", "source": "C1450", "subproblem": [{"content": "", "choice": ["2", "3", "4", "5"]}]}
{"classification": 1, "content": "下列算法中，采用自底向上的方法求解的是（）。", "code": "", "answer": ["A"], "explanation": "动态规划法先解决子问题，再解决父问题", "source": "C1451", "subproblem": [{"content": "", "choice": ["动态规划", "贪心", "回溯", "备忘录法"]}]}
{"classification": 1, "content": "（）是贪心算法和动态规划算法的共同点。", "code": "", "answer": ["B"], "explanation": "A, B是DP的性质，B, C是贪心的性质", "source": "C1452", "subproblem": [{"content": "", "choice": ["重叠子问题", "最优子结构", "贪心选择性质", "定义最优解"]}]}
{"classification": 1, "content": "下列排序算法中，时间复杂度上限为 O(n log n) 的是（）。", "code": "", "answer": ["C"], "explanation": "归并排序的均摊和最坏复杂度都是 O(n log n)", "source": "C1453", "subproblem": [{"content": "", "choice": ["快速排序", "桶排序", "归并排序", "希尔排序"]}]}
{"classification": 1, "content": "独根树高度为1，则高度为 11 的完全二叉树至少有（）个节点。", "code": "", "answer": ["B"], "explanation": "高度 n ，至少 2^{n-1} 个节点", "source": "C1454", "subproblem": [{"content": "", "choice": ["1023", "1024", "2047", "2048"]}]}
{"classification": 1, "content": "在程序运行过程中，如果递归调用的层数过多，会因为（ ）引发错误。", "code": "", "answer": ["B"], "explanation": "递归在系统内部是利用栈空间实现的", "source": "C1455", "subproblem": [{"content": "", "choice": ["系统堆溢出", "系统栈溢出", "系统队列溢出", "系统树溢出"]}]}
{"classification": 1, "content": "设a=1,b=0,c=1,d=0,以下逻辑运算表达式值为真的是", "code": "", "answer": ["B"], "explanation": "考察逻辑运算计算，一步一步计算就好", "source": "C1456", "subproblem": [{"content": "", "choice": ["(a&&b)||(c&&d||!a)", "((!a&&b)||c)&&!d", "(b||c||d)&&d&&a", "a&&(d||!c)&&b"]}]}
{"classification": 1, "content": "设a=1,b=0,c=1,d=0,以下逻辑运算表达式值为真的是", "code": "", "answer": ["D"], "explanation": "考察逻辑表达式，注意优先级，仔细运算", "source": "C1457", "subproblem": [{"content": "", "choice": ["(!a&&!b)||(c&&d||!a)", "(!a||b)||(c&&d||!a)", "(a&&b)||(c&&d&&!a)", "(!a||!b)||(c&&d||!a)"]}]}
{"classification": 1, "content": "设a=1,b=0,c=1,d=0,以下逻辑运算表达式值为假的是", "code": "", "answer": ["C"], "explanation": "逻辑表达式的计算，注意!!表示两次取反，两次取反的值和原来的结果是一样的", "source": "C1458", "subproblem": [{"content": "", "choice": ["((!a&&b)||c)&&!d", "(!a&&b&&c)||!d", "(!a&&b||c)&&!!d", "(!a&&b&&c)||!!d"]}]}
{"classification": 1, "content": "以下逻辑表达式的值恒为真的是", "code": "", "answer": ["D"], "explanation": "逻辑表达式恒真式，最暴力的方法就是直接考虑当ij为0或者1的时候计算结果。", "source": "C1461", "subproblem": [{"content": "", "choice": ["i||!j||(i&&!j)||(!i&&!j)\n", "i||j||(i&&!j)||(!i&&j)", "j||(!i&&j)||(i&&!j)", "i||(!i&&j)||(!i&&!j)"]}]}
{"classification": 1, "content": "以下逻辑表达式的值不可能为假的是", "code": "", "answer": ["A"], "explanation": "逻辑表达式恒真的计算，最直接的方式就是把所有情况", "source": "C1462", "subproblem": [{"content": "", "choice": ["i||!j||(i&&!j)||(!i&&j)", "i||j||(i&&!j)||(!i&&j)", "!i||j||(!i&&!j)||(i&&j)", "i||j||(i&&!j)||(!i&&j)"]}]}
{"classification": 1, "content": "下列那个逻辑表达式的值与变量 A 的真假无关", "code": "", "answer": ["C"], "explanation": "对于C，a和!a一真一假，表达式的真假只与b有关", "source": "C1463", "subproblem": [{"content": "", "choice": ["(a||b)&&!a", "(a||b)&&!b", "(a&&b)||(!a&&b)", "(a||b)&&!a&&b"]}]}
{"classification": 1, "content": "能正确表示逻辑关系:\" a≥10或a≤0 \"的C语言表达式是", "code": "", "answer": ["D"], "explanation": "转化为C语言的表达式即可", "source": "C1464", "subproblem": [{"content": "", "choice": ["a>=0 | a<=10", "a>=10 or a<=0", "a>=10 && a<=0", "a>=10 || a<=0"]}]}
{"classification": 1, "content": "C语言中,逻辑\"真\"等价于", "code": "", "answer": ["C"], "explanation": "非零的数就可以表示逻辑真", "source": "C1465", "subproblem": [{"content": "", "choice": ["非零的整数", "大于零的整数", "非零的数", "大于零的数"]}]}
{"classification": 1, "content": "当a=0，b=1时，以下逻辑表达式，执行后a和b的结果分别是多少，\nb=a+2||(a+=1)", "code": "", "answer": ["B"], "explanation": "a+2是真，||后面的就不会执行了", "source": "C1467", "subproblem": [{"content": "", "choice": ["0,0", "0,1", "1,0", "1,1"]}]}
{"classification": 1, "content": "下列逻辑表达式不能判断a和b都是1-10之间的数字的是", "code": "", "answer": ["C"], "explanation": "C,应该是(a>1 and a<10 or a==1 or b==10 ) and ( b>1 and b<10 or b==10 or b==1 )", "source": "C1468", "subproblem": [{"content": "", "choice": ["a>=1 and a<=10 and b>=1 and b<=10", "a>=1 && a<=10 && b>=1 && b<=10", "a>1 and a<10 and b>1 and b<10 or (a==1 or b==10)", "a>0 && a<11 && b>0 && b<11"]}]}
{"classification": 1, "content": "下列逻辑表达式不能够判断ab都是非负数的是", "code": "", "answer": ["B"], "explanation": "B.and 的优先级比or的优先级高，正解为 (a>0 or a==0 )and  (b>0 or b==0 )", "source": "C1469", "subproblem": [{"content": "", "choice": ["a>=0 and  b>=0", "a>0 or a==0 and  b>0 or b==0 ", "b*a>=0 and  b>=0", "b*a>0 and  b>0 or a==0 and b==0"]}]}
{"classification": 1, "content": "下列逻辑表达式合法的是", "code": "", "answer": ["A"], "explanation": "两个|或者&中间不能有空格，!应该在前面", "source": "C1470", "subproblem": [{"content": "", "choice": ["a&&b", "a& &b", "a&&b!&&c", "a & &b"]}]}
{"classification": 1, "content": "二叉树的层序遍历指的是从左到右，一层一层写出的结果，层序遍历蕴含于以下哪种遍历方法", "code": "", "answer": ["D"], "explanation": "层序遍历本质上是从根节点开始，总是优先访问左子树的宽度优先遍历", "source": "C1473", "subproblem": [{"content": "", "choice": ["先序遍历", "中序遍历", "后序遍历", "广度优先遍历"]}]}
{"classification": 1, "content": "二叉树的之字形层序遍历指的是第一层从左到右，下一层从右到左，交替一层一层写出的结果，之字形层序遍历蕴含于以下哪种遍历方法", "code": "", "answer": ["A"], "explanation": "之字形层序遍历本质上就是从根节点开始的广度优先遍历，并在奇数层优先访问左子树，在偶数层优先访问右子树", "source": "C1474", "subproblem": [{"content": "", "choice": ["广度优先遍历", "先序遍历", "中序遍历", "后序遍历"]}]}
{"classification": 1, "content": "输入两个无环的单链表，下面的代码得到了什么", "code": "```cpp\n<p>ListNode*&nbsp;Func(&nbsp;ListNode*&nbsp;pHead1,&nbsp;ListNode*&nbsp;pHead2)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;*ta&nbsp;=&nbsp;pHead1,&nbsp;*tb&nbsp;=&nbsp;pHead2;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(ta&nbsp;!=&nbsp;tb)&nbsp;{<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ta&nbsp;=&nbsp;ta&nbsp;?&nbsp;ta-&gt;next&nbsp;:&nbsp;pHead2;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tb&nbsp;=&nbsp;tb&nbsp;?&nbsp;tb-&gt;next&nbsp;:&nbsp;pHead1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;}<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ta;<br>\n}</p>", "answer": ["B"], "explanation": "考虑第一个公共节点距离两个链表头相同时，从两个链表分别开始遍历总能找到此公共节点，于是将另一链表拼接在此链表头前，则公共节点距离两表头相同", "source": "C1475", "subproblem": [{"content": "", "choice": ["两个链表的最长公共后缀", "两个链表的第一个公共节点", "两个链表首尾相连后形成的循环链表", "以上选项都不对"]}]}
{"classification": 1, "content": "T是一棵二叉树，下面的代码计算了什么", "code": "```python\n<p>Func(&nbsp;T&nbsp;):<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;T&nbsp;is&nbsp;empty<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;else:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp1&nbsp;=&nbsp;Func(&nbsp;T.left_subtree&nbsp;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp2&nbsp;=&nbsp;Func(&nbsp;T.right_subtree&nbsp;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;max(temp1,&nbsp;temp2)&nbsp;+&nbsp;1<br>\nendFunc</p>", "answer": ["A"], "explanation": "计算树高的递归不变式是\nH(T) = max( H(T.l), H(T.r) ) + 1", "source": "C1476", "subproblem": [{"content": "", "choice": ["树的高度", "树的节点数", "树的叶子数", "以上选项都不对"]}]}
{"classification": 1, "content": "T是一棵二叉树，下面的代码计算了什么", "code": "```python\n<p>Func(&nbsp;T&nbsp;):<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;T&nbsp;is&nbsp;empty<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;else:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp1&nbsp;=&nbsp;Func(&nbsp;T.left_subtree&nbsp;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp2&nbsp;=&nbsp;Func(&nbsp;T.right_subtree&nbsp;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;temp1&nbsp;+&nbsp;temp2&nbsp;+&nbsp;1<br>\nendFunc</p>", "answer": ["B"], "explanation": "计算树节点数的递归不变式是\nS(T) = S(T.l) + S(T.r) + 1", "source": "C1477", "subproblem": [{"content": "", "choice": ["树的高度", "树的节点数", "树的叶子数", "以上选项都不对"]}]}
{"classification": 1, "content": "T是一棵二叉树，下面的代码计算了什么", "code": "```python\n<p>Func(&nbsp;T&nbsp;):<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;T&nbsp;is&nbsp;empty<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;else:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp1&nbsp;=&nbsp;Func(&nbsp;T.left_subtree&nbsp;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp2&nbsp;=&nbsp;Func(&nbsp;T.right_subtree&nbsp;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;temp1&nbsp;+&nbsp;temp2&nbsp;==&nbsp;0:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;temp1&nbsp;+&nbsp;temp2<br>\nendFunc</p>", "answer": ["C"], "explanation": "当节点没有左右儿子时返回1，否则将左右儿子的叶子数相加", "source": "C1478", "subproblem": [{"content": "", "choice": ["树的高度", "树的节点数", "树的叶子数", "以上选项都不对"]}]}
{"classification": 1, "content": "T是一棵二叉树，下面的代码计算了什么", "code": "```python\n<p>Func(&nbsp;T&nbsp;):<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;T&nbsp;is&nbsp;empty:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;False<br>\n&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;T&nbsp;is&nbsp;a&nbsp;single&nbsp;vertex.<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;True<br>\n&nbsp;&nbsp;&nbsp;&nbsp;else:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp1&nbsp;=&nbsp;Func(&nbsp;T.left_subtree&nbsp;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp2&nbsp;=&nbsp;Func(&nbsp;T.right_subtree&nbsp;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;temp1&nbsp;AND&nbsp;temp2<br>\nendFunc</p>", "answer": ["A"], "explanation": "满二叉树的递归定义：\n    单点是满二叉树\n    满二叉树根节点的左右子树都是满二叉树", "source": "C1479", "subproblem": [{"content": "", "choice": ["T是否是满二叉树", "T是否是完全二叉树", "T是否是退化的二叉树", "以上选项都不对"]}]}
{"classification": 1, "content": "T是一棵二叉树，下面的代码计算了什么", "code": "```python\n<p>Func(&nbsp;T,&nbsp;n&nbsp;=&nbsp;Height(&nbsp;T&nbsp;)&nbsp;):<br>\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;T&nbsp;is&nbsp;empty:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;n&nbsp;==&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;else:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp1&nbsp;=&nbsp;Func(&nbsp;T.left_subtree,&nbsp;n-1&nbsp;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp2&nbsp;=&nbsp;Func(&nbsp;T.right_subtree,&nbsp;n-1&nbsp;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;temp1&nbsp;AND&nbsp;temp2<br>\nendFunc</p>", "answer": ["A"], "explanation": "从上至下，假设整棵树有n层，那么左右子树必须都恰好有n-1层，所以是满二叉树", "source": "C1480", "subproblem": [{"content": "", "choice": ["T是否是满二叉树", "T是否是完全二叉树", "T是否是退化的二叉树", "以上选项都不对"]}]}
{"classification": 1, "content": "T是一棵二叉树，下面的代码计算了什么", "code": "<p>Func(&nbsp;T&nbsp;):<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;T&nbsp;is&nbsp;empty:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;True<br>&nbsp;&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp1&nbsp;=&nbsp;Func(&nbsp;T.left_subtree,&nbsp;n-1&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp2&nbsp;=&nbsp;Func(&nbsp;T.right_subtree,&nbsp;n-1&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case1&nbsp;=&nbsp;T.left_subtree&nbsp;is&nbsp;empty&nbsp;AND&nbsp;temp2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;2&nbsp;=&nbsp;T.right_subtree&nbsp;is&nbsp;empty&nbsp;AND&nbsp;temp1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;case1&nbsp;OR&nbsp;case2<br>endFunc</p>", "answer": ["C"], "explanation": "退化的二叉树，即每个节点度数至多为1，从而成为一条链", "source": "C1481", "subproblem": [{"content": "", "choice": ["T是否是满二叉树", "T是否是完全二叉树", "T是否是退化的二叉树", "以上选项都不对"]}]}
{"classification": 1, "content": "以下关于 n 阶简单无向图 G(V, E) 的叙述，正确的是", "code": "", "answer": ["C"], "explanation": "ABD的逆命题均正确.\nC中|E|的下界是n-1阶完全图的边数.", "source": "C1482", "subproblem": [{"content": "", "choice": ["若 |E| = n - 1，则 G 是一棵树", "若 |E| >= n - 1，则 G 是连通图", "若 |E| > (n-1)(n-2) / 2，则 G 是连通图", "若 G 是连通图，则 |E| > (n-1)(n-2) / 2"]}]}
{"classification": 1, "content": "杜牧在《阿房宫赋》中写道：“秦人不暇自哀，而后人哀之；后人哀之而不鉴之，亦使后人而复哀后人也。” 这体现了以下哪种算法思想。", "code": "", "answer": ["B"], "explanation": "“哀之而不鉴之”是触发递归的关键条件。", "source": "C1484", "subproblem": [{"content": "", "choice": ["枚举", "递归", "贪心", "分治"]}]}
{"classification": 1, "content": "苏洵在《六国论》中感叹道：“以赂秦之地封天下之谋臣，以事秦之心礼天下之奇才，并力西向，则吾恐秦人食之不得下咽也。” 由此看来，秦对于六国采取的策略暗合了哪种算法思想。", "code": "", "answer": ["C"], "explanation": "译文：（如果六国诸侯）用贿赂秦国的土地来封给天下的谋臣，用侍奉秦国的心来礼遇天下的奇才，齐心合力地向西（对付秦国），那么，我恐怕秦国人饭也不能咽下去。这表达了分而治之的思想，把大土地分成小土地，最后让天下的土地的力量都聚合起来，这就是把复杂问题划分成若干个相似的子问题解决的分治思想。", "source": "C1485", "subproblem": [{"content": "", "choice": ["贪心", "递归", "分治", "枚举"]}]}
{"classification": 1, "content": "设简单无向图 G 有 16 条边且每个顶点的度数都是 4，则图 G 有几个顶点。", "code": "", "answer": ["A"], "explanation": "4*|V| / 2 = |E|", "source": "C1488", "subproblem": [{"content": "", "choice": ["8", "10", "12", "16"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】中国的国家顶级域名是( )。", "code": "", "answer": ["A"], "explanation": "中国的国家顶级域名是.cn。", "source": "C1489", "subproblem": [{"content": "", "choice": [".cn", ".ch", ".chn", ".china"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】二进制数 11 1011 1001 0111 和 01 0110 1110 1011 进行逻辑与运算的结果是( )。", "code": "", "answer": ["D"], "explanation": "逻辑与运算是对于二进制位上，每一位进行均为1则为1，只要有一个0就为0，这样的操作的。", "source": "C1490", "subproblem": [{"content": "", "choice": ["01 0010 1000 1011", "01 0010 1001 0011", "01 0010 1000 0001", "01 0010 1000 0011"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】一个 32 位整型变量占用( )个字节。", "code": "", "answer": ["C"], "explanation": "一个字节占8位，所以32位的整型变量占用4个字节。", "source": "C1491", "subproblem": [{"content": "", "choice": ["32", "128", "4", "8"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】若有如下程序段，其中 s、a、b、c 均已定义为整型变量，且 a、c 均已赋值（c>0），则与上述程序段功能等价的赋值语句是（）。", "code": "```C++\ns&nbsp;=&nbsp;a;<br>\nfor&nbsp;(b&nbsp;=&nbsp;1;&nbsp;b&nbsp;&lt;=&nbsp;c;&nbsp;b++)&nbsp;s&nbsp;=&nbsp;s&nbsp;-&nbsp;1;", "answer": ["A"], "explanation": "因为s的初始值为a，然后经过了c次减1的操作，所以相当于是a - c。", "source": "C1492", "subproblem": [{"content": "", "choice": ["s = a - c;", "s = a - b;", "s = s - c;", "S = b - c;"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】设有 100 个已排好序的数据元素，采用折半查找时，最大比较次数为( )。", "code": "", "answer": ["A"], "explanation": "二分查找的运行次数为log2(n)+1，其中log2()运算是向下取整的。", "source": "C1493", "subproblem": [{"content": "", "choice": ["7", "10", "6", "8"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】链表不具有的特点是( )。", "code": "", "answer": ["D"], "explanation": "链表不能随机访问任一元素，得通过逐一遍历的方式去找到对应的元素。", "source": "C1494", "subproblem": [{"content": "", "choice": ["插入删除不需要移动元素", "不必事先估计存储空间", "所需空间与线性表长度成正比", "可随机访问任一元素"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】把 8 个同样的球放在 5 个同样的袋子里，允许有的袋子空着不放，问共有多少种不同的分法？( )\n\n提示：如果 8 个球都放在一个袋子里，无论是哪个袋子，都只算同一种分法", "code": "", "answer": ["C"], "explanation": "把问题合成，先思索5个袋子都不空的状况，再思索4个袋子不空的状况，以此类推，最后思索只运用一个袋子的状况（这种分法只要1种），把一切子状况的分法数相加求出总分法。\n进一步剖析，运用k个袋子装n个球（袋子不空），一共有几种分法的问题能够转化为k个数相加等于n的种数问题。\n运用5个袋子装8个球则有3种：\n1+1+1+1+4 = 8\n1+1+1+2+3 = 8\n1+1+2+2+2 = 8\n运用4个袋子分8个球则有5种：\n1+1+1+5=8\n1+1+2+4=8\n1+1+3+3=8\n1+2+2+3=8\n2+2+2+2=8\n运用3个袋子分8个球则有5种：\n1+1+6=8\n1+2+5=8\n1+3+4=8\n2+2+4=8\n2+3+3=8\n运用2个袋子分8个球则有4种：\n1+7=8\n2+6=8\n3+5=8\n4+4=8\n运用1个袋子装8个球则有1种：\n8=8\n因而该问题的答案即为一切子状况下的和，3+5+5+4+1 = 18。", "source": "C1495", "subproblem": [{"content": "", "choice": ["22", "24", "18", "20"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】100 以内的最大素数是( )。", "code": "", "answer": ["B"], "explanation": "97是100以内最大的素数。", "source": "C1497", "subproblem": [{"content": "", "choice": ["89", "97", "91", "93"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】319 和 377 的最大公约数是( )。", "code": "", "answer": ["C"], "explanation": "可以用代码写一个gcd函数，int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }。不难发现，他们的最大公约数是29。", "source": "C1498", "subproblem": [{"content": "", "choice": ["27", "33", "29", "31"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】新学期开学了，小胖想减肥，健身教练给小胖制定了两个训练方案。方案一：每次连续跑 3 公里可以消耗 300 千卡（耗时半小时）；方案二：每次连续跑 5 公里可以消耗 600 千卡（耗时 1 小时）。小胖每周周一到周四能抽出半小时跑步，周五到周日能抽出一小时跑步。另外，教练建议小胖每周最多跑 21 公里，否则会损伤膝盖，每周最多通过跑步消耗多少千卡( )。", "code": "", "answer": ["C"], "explanation": "如果贪心的选择，肯定要尽可能多的选择5公里的，因为它的能耗率高。所以，减去15公里之后还剩6公里，总共能消耗的能量就是600*3+300*2=2400。", "source": "C1499", "subproblem": [{"content": "", "choice": ["3000", "2500", "2400", "2520"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】一副纸牌除掉大小王有 52 张牌，四种花色，每种花色 13 张。假设从这 52 张牌中随机抽取 13 张纸牌，则至少( )张牌的花色一致。", "code": "", "answer": ["A"], "explanation": "根据抽屉定理，我们平摊花色，最少的时候是3+3+3+4=13，所以最少就是4张牌。", "source": "C1500", "subproblem": [{"content": "", "choice": ["4", "2", "3", "5"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】一些数字可以颠倒过来看，例如 0、1、8 颠倒过来还是本身，6 颠倒过来是 9，9 颠倒过来看还是 6，其他数字颠倒过来都不构成数字。类似的，一些多位数也可以颠倒过来看，比如 106 颠倒过来是 901。假设某个城市的车牌只由 5 位数字组成，每一位都可以取 0 到 9。请问这个城市最多有多少个车牌倒过来恰好还是原来的车牌？( )", "code": "", "answer": ["C"], "explanation": "因为答案很小，所以我们不妨写一个程序进行判断。不难发现，我们需要进行判断的字符只有0、1、6、8、9，所以可以从0到99999进行for循环遍历，去检验每个答案是否符合。这里可以使用string类型进行检验，讲数字转换成string类型可以使用to_string()。", "source": "C1501", "subproblem": [{"content": "", "choice": ["60", "125", "75", "100"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】假设一棵二叉树的后序遍历序列为 DGJHEBIFCA，中序遍历序列为 DBGEHJACIF，则其前序遍历序列为( )。", "code": "", "answer": ["B"], "explanation": "利用后序遍历，首先确定根为A，因为后序遍历的最后一位是A，然后又可以根据中序遍历确定，DBGEHI在A的左子树，CIF在A的右子树，然后后序遍历的倒数第二位是C，可以确定C是某子树的一个根节点，所以A的右儿子节点是C，C的右子树有IF，根据以上的操作，我们可以确定一整棵树。", "source": "C1502", "subproblem": [{"content": "", "choice": ["ABCDEFGHIJ", "ABDEGHJCFI", "ABDEGHKCFI", "ABDEGHJFIC"]}]}
{"classification": 1, "content": "【2019年CSP-J1入门级初赛】以下哪个奖项是计算机科学领域的最高奖？( )", "code": "", "answer": ["A"], "explanation": "计算机科学领域的最高奖是图灵奖。", "source": "C1503", "subproblem": [{"content": "", "choice": ["图灵奖", "鲁班奖", "诺贝尔奖", "普利策奖"]}]}
{"classification": 1, "content": "【2018年普及组初赛】以下哪一种设备属于输出设备（）。", "code": "", "answer": ["D"], "explanation": "打印机属于输出设备。", "source": "C1504", "subproblem": [{"content": "", "choice": ["扫描仪", "键盘", "鼠标", "打印机"]}]}
{"classification": 1, "content": "【2018年普及组初赛】下列四个不同进制的数中，与其它三项数值上不相等的是（ ）。", "code": "", "answer": ["D"], "explanation": "我们可以直接用D的二进制和A和C进行比较，不难发现D与A和C均不一样。", "source": "C1505", "subproblem": [{"content": "", "choice": ["(269)16", "(617)10", "(1151)8", "(1001101011)2"]}]}
{"classification": 1, "content": "【2018年普及组初赛】1MB 等于（ ）。", "code": "", "answer": ["D"], "explanation": "1 MB = 1024 KB = 1024 * 1024 B。", "source": "C1506", "subproblem": [{"content": "", "choice": ["1000 字节", "1024 字节", "1000 * 1000 字节", "1024 * 1024 字节"]}]}
{"classification": 1, "content": "【2018年普及组初赛】广域网的英文缩写是（ ）。", "code": "", "answer": ["B"], "explanation": "广域网的缩写是WAN。", "source": "C1507", "subproblem": [{"content": "", "choice": ["LAN", "WAN", "MAN", "LNA"]}]}
{"classification": 1, "content": "BIOS（基本输入输出系统）是一组固化在计算机（   ）上的一个ROM芯片上的程序", "code": "", "answer": ["C"], "explanation": "BIOS是一组固化在计算机主板ROM芯片上的程序", "source": "C1508", "subproblem": [{"content": "", "choice": ["控制器", "CPU", "主板", "内存条"]}]}
{"classification": 1, "content": "一个完整的计算机系统应包括（    ）", "code": "", "answer": ["B"], "explanation": "一个完整的计算机系统应该包括计算机的硬件系统和软件系统", "source": "C1509", "subproblem": [{"content": "", "choice": ["系统硬件和系统软件", "硬件系统和软件系统", "主机和外部设备", "主机、键盘、显示器、辅助存储器"]}]}
{"classification": 1, "content": "在微机中，通用寄存器的位数是（  ）", "code": "", "answer": ["C"], "explanation": "通用寄存器的位数跟CPU的型号有关，它取决于计算机的字长", "source": "C1510", "subproblem": [{"content": "", "choice": ["8位", "16位", "计算机字长", "32位"]}]}
{"classification": 1, "content": "不同的计算机，其指令系统也不相同，这主要取决于（   ）", "code": "", "answer": ["C"], "explanation": "计算机指令系统取决于中央处理器的控制器，所有的控制和运算操作，均由控制器中的微指令系统进行操作", "source": "C1511", "subproblem": [{"content": "", "choice": ["所用的操作系统", "系统的总体结构", "所用的CPU", "所用的程序设计语言"]}]}
{"classification": 1, "content": "CPU处理数据的基本单位是字，一个字的字长（   ）", "code": "", "answer": ["D"], "explanation": "CPU处理数据的基本单位是字，一个字的字长通常与微处理器芯片的型号有关", "source": "C1512", "subproblem": [{"content": "", "choice": ["为8个二进制位", "为16个二进制位", "为32个二进制位", "与芯片的型号有关"]}]}
{"classification": 1, "content": "中央处理器CPU能访问的最大存储器容量取决于", "code": "", "answer": ["A"], "explanation": "地址总线主要用来传输内存地址，地址线的条数越多，CPU能访问存储器的范围越大。如果地址条数不够，寻址能力也就有限，内存容量再大也用不上，因此不能选D。", "source": "C1513", "subproblem": [{"content": "", "choice": ["地址总线", "数据总线", "控制总线", "内存容量"]}]}
{"classification": 1, "content": "下列说法中错误的是", "code": "", "answer": ["B"], "explanation": "A. CPU包括运算逻辑部件、寄存器部件、控制部件。CPU从存储器或高速缓存中取出指令，放入指令寄存器，并对指令译码。\nB. CPU访问存储器的速度：Cache>内存>外村，Cache是CPU内部的高速缓存，容量很小，当然速度也最快。\nC. CPU的主频，即CPU内核工作的时钟频率（CPU Clock Speed）\nD. 计算机在使用存储器时，要给这些存储器进行编号，这个编号就是地址。", "source": "C1514", "subproblem": [{"content": "", "choice": ["CPU的基本功能就是执行指令", "CPU访问内存的速度快于访问高速缓存的速度", "CPU的主频是指CPU在1秒内完成的指令周期数", "在一台计算机内部，一个内存地址编码对应唯一的一个内存单元"]}]}
{"classification": 1, "content": "下列哪个不是CPU（中央处理器）", "code": "", "answer": ["B"], "explanation": "DDR SDRAM是Double Data Rate SDRAM的缩写。SDRAM是同步动态随机存取內存。", "source": "C1515", "subproblem": [{"content": "", "choice": ["Inter Itanium", "DDR SDRAM", "AMD Athlon64", "IBM Power 5"]}]}
{"classification": 1, "content": "【NOIP2005普及组】Inter的首颗16位处理器是", "code": "", "answer": ["D"], "explanation": "比较冷门，1978年英特尔公司生产的8086是第一个16位的微处理器", "source": "C1516", "subproblem": [{"content": "", "choice": ["8088", "80386", "80486", "8086"]}]}
{"classification": 1, "content": "【NOIP2005提高组】Inter的首颗64位处理器是", "code": "", "answer": ["D"], "explanation": "Inter公司于1993年退出了80586，其为64位微处理器，正式名称为Pentium，Pentium含有310万个晶体管，时钟频率最初为60MHz和66MHz", "source": "C1517", "subproblem": [{"content": "", "choice": ["8088", "80386", "80486", "Pentium"]}]}
{"classification": 1, "content": "处理器A每秒处理的指令数是处理器B的两倍。某一特定程序P分别编译为处理器A和处理器B的指令，编译结果处理器A的指令数是处理器B的4倍。已知程序P的算法时间复杂度为O(n^2)，如果处理器A执行程序P时能在一个小时内完成的输入规模为n，则处理器B执行程序P时能在一个小时内完成的输入规模为", "code": "", "answer": ["B"], "explanation": "每秒指令数为2：1，编译后指令量为4：1，综合速度1：2，无论在哪个处理器上，该程序P的算法复杂度都是一样的，因此产生影响的主要是指令数及两个处理器的速度。综合来看，处理器B有两倍的速度优势，所以是2*n", "source": "C1518", "subproblem": [{"content": "", "choice": ["4*n", "2*n", "n", "n/2"]}]}
{"classification": 1, "content": "以下各项中，（ ）不是CPU的组成部分", "code": "", "answer": ["D"], "explanation": "CPU由控制器、运算器、寄存器组成。运算器基本操作包括四则运算，与、或、非、异或等逻辑操作，以及移位、比较、传送等操作，这部分由ALU(算术逻辑单元)完成。RAM是随机存储器（内存），不是CPU的组成部分。", "source": "C1519", "subproblem": [{"content": "", "choice": ["控制器", "运算器", "ALU", "RAM"]}]}
{"classification": 1, "content": "计算机能直接执行的指令包括两部分，它们是", "code": "", "answer": ["B"], "explanation": "计算机指令系统由操作码和操作数组成", "source": "C1520", "subproblem": [{"content": "", "choice": ["源操作数和目标操作数", "操作码和操作数", "ASCII码和汉字代码", "数字与字符"]}]}
{"classification": 1, "content": "计算机的软件系统通常分为", "code": "", "answer": ["A"], "explanation": "软件系统基本知识", "source": "C1521", "subproblem": [{"content": "", "choice": ["系统软件和应用软件", "高级软件与一般软件", "军用软件与民用软件", "管理软件与控制软件"]}]}
{"classification": 1, "content": "Office中的Word是一种（ ）", "code": "", "answer": ["B"], "explanation": "Word是微软公司推出的办公自动化套装软件Office中的字处理软件", "source": "C1522", "subproblem": [{"content": "", "choice": ["操作系统", "文字处理软件", "多媒体制作软件", "网络浏览器"]}]}
{"classification": 1, "content": "应用软件和系统软件的相互关系是", "code": "", "answer": ["B"], "explanation": "系统软件是基础，没有它系统无法运行", "source": "C1523", "subproblem": [{"content": "", "choice": ["后者以前者为基础", "前者以后者为基础", "每一类都以另一类为基础", "每一类都不以另一类为基础"]}]}
{"classification": 1, "content": "下列哪个软件不是操作系统软件的名字", "code": "", "answer": ["B"], "explanation": "Windows XP是微软公司的操作系统，Linux是开源免费的操作系统，OS/2是IBM公司的操作系统", "source": "C1524", "subproblem": [{"content": "", "choice": ["Windows XP", "Arch/Info", "Linux", "OS/2"]}]}
{"classification": 1, "content": "数字图像文件可以用下列哪个软件来编辑", "code": "", "answer": ["D"], "explanation": "Photoshop是美国Adobe公司的专业图像处理软件。Notepad只能处理文本文件，WinRAR是Eugene Roshal的共享压缩软件。", "source": "C1525", "subproblem": [{"content": "", "choice": ["WinRAR", "记事簿（Notepad）", "Recorder", "Photoshop"]}]}
{"classification": 1, "content": "下列哪个软件不是数据库软件的名称", "code": "", "answer": ["D"], "explanation": "MySQL是一个关系型数据库管理系统。SQL，结构化查询语言。SQL Server是一个关系数据库管理系统。Oracle是殷墟出土的甲骨文的英文翻译的第一个单词，在英文里是“神谕”的意思。Oracle数据库产品为财富排行榜上的前1000家公司所采用，许多大型网站也选用了Oracle系统。", "source": "C1526", "subproblem": [{"content": "", "choice": ["MySQL", "SQL Server", "Oracle", "金山影霸"]}]}
{"classification": 1, "content": "以下哪个软件不是即时通信软件", "code": "", "answer": ["C"], "explanation": "这是3D造型软件", "source": "C1527", "subproblem": [{"content": "", "choice": ["MSN Messenger", "Google Talk", "3DS Max", "QQ"]}]}
{"classification": 1, "content": "不能在Linux上使用的网页浏览器是", "code": "", "answer": ["A"], "explanation": "微软的，未跨平台", "source": "C1528", "subproblem": [{"content": "", "choice": ["Internet Explore", "Netscape", "Firefox", "Chrome"]}]}
{"classification": 1, "content": "Linux是一种", "code": "", "answer": ["C"], "explanation": "Linux是一种自由和开源的类UNIX操作系统，目前存在许多不同的Linux，但它们都用了Linux内核。Linux可安装在各种计算机硬件设备中。严格来讲，Linux只表示Linux内核，但实际上人们已经习惯用Linux来形容整个基于Linux内核的操作系统。", "source": "C1529", "subproblem": [{"content": "", "choice": ["绘图软件", "程序设计语言", "操作系统", "网络浏览器"]}]}
{"classification": 1, "content": "解释程序的功能是", "code": "", "answer": ["C"], "explanation": "解释程序是高级语言翻译程序的一种，它将源语言书写的源程序作为输入，解释一句就执行一句，并不形成目标程序", "source": "C1530", "subproblem": [{"content": "", "choice": ["将高级语言程序转换为目标程序", "将汇编语言程序转换成目标程序", "解释执行高级语言程序", "解释执行汇编语言程序"]}]}
{"classification": 1, "content": "下列哪一种程序设计语言不是解释执行的", "code": "", "answer": ["A"], "explanation": "C++是编译型语言", "source": "C1531", "subproblem": [{"content": "", "choice": ["C++", "JavaScript", "Python", "Node.JS"]}]}
{"classification": 1, "content": "下列关于程序语言的叙述，不正确的是", "code": "", "answer": ["D"], "explanation": "汇编语言不能直接执行", "source": "C1532", "subproblem": [{"content": "", "choice": ["编写机器代码不比编写汇编代码容易", "高级语言需要编译成目标代码或通过解释器解释后才能被CPU执行", "同样一段高级语言程序通过不同的编译器可能产生不同的可执行程序", "汇编代码可被CPU直接运行"]}]}
{"classification": 1, "content": "在下列计算机语言的说法中，不正确的是", "code": "", "answer": ["C"], "explanation": "历史上第一个支持面向对象的计算机语言是Simula67语言", "source": "C1533", "subproblem": [{"content": "", "choice": ["Pascal和C都是编译执行的高级语言", "高级语言程序比汇编语言程序更容易从一种计算机一直到另一种计算机上", "C++是历史上第一个支持面向对象的计算机语言", "与汇编语言相比，高级语言更容易阅读"]}]}
{"classification": 1, "content": "在下列关于计算机语言的说法中，正确的是", "code": "", "answer": ["C"], "explanation": "高级语言比汇编语言更高级，是针对计算机语言的发展阶段讲的，人们使用其编写程序更容易。优秀的程序设计人员用汇编语言编写的程序，往往效率更高，机器语言和汇编语言并没有退出历史舞台。一些硬件操作相关的程序，往往还需要汇编语言编写", "source": "C1534", "subproblem": [{"content": "", "choice": ["高级语言比汇编语言更高级，是因为它的程序运行效率更高", "随着Pascal、C等高级语言的出现，机器语言和汇编语言已经退出了历史舞台", "高级语言程序比汇编语言程序更容易从一种计算机移植到另一种计算机上", "C是一种面向对象的高级语言"]}]}
{"classification": 1, "content": "用十六进制、八进制、十进制写了如下一个等式：52-19=33，式中三个数是各不相同进制的数。则52、19、33分别为", "code": "", "answer": ["B"], "explanation": "不需要死算，恒等变形为52=19+33，十进制时成立，假设52变成八进制，19和33中一个改成十六进制，则等式左边变小，右边变大，不再平衡。所以A和C都不对。D选项中，19不可能是八进制数，所以D不对。", "source": "C1535", "subproblem": [{"content": "", "choice": ["八进制、十进制、十六进制", "十进制、十六进制、八进制", "八进制、十六进制、十进制", "十进制、八进制、十六进制"]}]}
{"classification": 1, "content": "十进制算术表达式：3*512+7*64+4*8+5的运算结果，用二进制表示是", "code": "", "answer": ["B"], "explanation": "八进制下计算结果是3745，由八进制直接转为二进制即可", "source": "C1536", "subproblem": [{"content": "", "choice": ["10111100101", "11111100101", "11110100101", "11111101101"]}]}
{"classification": 1, "content": "下列无符号数中，最小的数是", "code": "", "answer": ["C"], "explanation": "全部转换成同一进制数来比较即可", "source": "C1537", "subproblem": [{"content": "", "choice": ["(11011001)2", "(75)10", "(37)8", "(2A)16"]}]}
{"classification": 1, "content": "与二进制数101.01011等值的十六进制数为", "code": "", "answer": ["D"], "explanation": "二进制=>十六进制：4位换1位，不足4位补0，得5.58", "source": "C1538", "subproblem": [{"content": "", "choice": ["A.B", "5.51", "A.51", "5.58"]}]}
{"classification": 1, "content": "（0.5）10 = （      ）16", "code": "", "answer": ["C"], "explanation": "5/10=8/16。“半斤八两”", "source": "C1539", "subproblem": [{"content": "", "choice": ["0.1", "0.75", "0.8", "0.25"]}]}
{"classification": 1, "content": "算式(2047)10-(3FF)16+(2000)8的结果是", "code": "", "answer": ["A"], "explanation": "转换成十进制，得到2048", "source": "C1540", "subproblem": [{"content": "", "choice": ["(2048)10", "(2049)10", "(3746)8", "(1AF7)16"]}]}
{"classification": 1, "content": "十进制数11/128可用二进制数码序列表示为", "code": "", "answer": ["D"], "explanation": "用乘2取整法", "source": "C1541", "subproblem": [{"content": "", "choice": ["1011/1000000", "1011/100000000", "0.001011", "0.0001011"]}]}
{"classification": 1, "content": "十进制数2003等值于二进制数（ ）", "code": "", "answer": ["A"], "explanation": "用除2法取余法", "source": "C1542", "subproblem": [{"content": "", "choice": ["11111010011", "10000011", "110000111", "1111010011"]}]}
{"classification": 1, "content": "十进制数100.625等值于二进制数（  ）", "code": "", "answer": ["B"], "explanation": "分开换算整数和小数部分", "source": "C1543", "subproblem": [{"content": "", "choice": ["1001100.101", "1100100.101", "1100100.011", "1001100.11"]}]}
{"classification": 1, "content": "以下二进制数的值与十进制数23.456的值最接近的是", "code": "", "answer": ["D"], "explanation": "求最接近，整数部分容易确定，小数部分按位权展开，(0.11)2=(0.4375)10", "source": "C1544", "subproblem": [{"content": "", "choice": ["10111.0101", "11011.1111", "11011.0111", "10111.0111"]}]}
{"classification": 1, "content": "与十进制数1770.625对应的八进制数是", "code": "", "answer": ["A"], "explanation": "1770转换成八进制是除以8的余数反序，即3352，小数部分是乘以8的整数部分正序，即0.625*8=5", "source": "C1545", "subproblem": [{"content": "", "choice": ["3352.5", "3350.5", "3352.1161", "3350.1151"]}]}
{"classification": 1, "content": "在24*24点阵的字库中，汉字“一”与“编”的字模占用字节数分别是", "code": "", "answer": ["C"], "explanation": "24*24点阵的字模需要24*24个二进制位来存储，每个字节有8个二进制位。所以，一个汉子字模占用字节数为24*24/8=72字节。汉字“一”与“编”尽管简繁不一，但所需空间是一样的", "source": "C1546", "subproblem": [{"content": "", "choice": ["32，32", "32，72", "72，72", "72，32"]}]}
{"classification": 1, "content": "在计算机中，ASCII码是（  ）位二进制代码", "code": "", "answer": ["A"], "explanation": "在计算机中一个字符是用一个字节来表示的，低7位是这个字符的ASCII码，最高位为0。", "source": "C1547", "subproblem": [{"content": "", "choice": ["8", "16", "32", "7"]}]}
{"classification": 1, "content": "已知小写字母m的十六进制的ASCII码值是6D，则小写字母c的十六进制数的ASCII码是", "code": "", "answer": ["D"], "explanation": "c排在m的前10个，(6D)16-(10)10=(63)16", "source": "C1548", "subproblem": [{"content": "", "choice": ["98", "62", "99", "63"]}]}
{"classification": 1, "content": "组成教授（JIAO SHOU）、副教授（FU JIAO SHOU）、讲师（JIANG SHI）这三个词的汉字，在GB2312-80字符集中都是一级汉字，对这三个词排序的结果是", "code": "", "answer": ["D"], "explanation": "GB2312-80是我国于1981年颁布的《信息交换用汉字编码字符集》，字符集中共收录6763个汉字，其中一级字库3755个，按拼音排序，二级字库3008个，按偏旁部首排序，另外还有682个图文符号。因副教授、讲师、教授三个词的汉字都在一级字库，所以按拼音排序是副教授、讲师、教授。", "source": "C1549", "subproblem": [{"content": "", "choice": ["教授、副教授、讲师", "副教授、教授、讲师", "讲师、副教授、教授", "副教授、讲师、教授"]}]}
{"classification": 1, "content": "在计算机中，字符编码通常采用", "code": "", "answer": ["C"], "explanation": "在计算机系统中，最为应用广泛的字符编码是ASCII码", "source": "C1550", "subproblem": [{"content": "", "choice": ["原码", "反码", "ASCII码", "补码"]}]}
{"classification": 1, "content": "GB2312-80规定了一级汉字3755个，二级汉字3008个，其中二级汉字字库中的汉字是以（  ）为序排列的", "code": "", "answer": ["B"], "explanation": "一级汉字按拼音字母顺序排序，二级汉字按偏旁部首排序", "source": "C1551", "subproblem": [{"content": "", "choice": ["以笔画多少", "以部首", "以ASCII码", "以机内码"]}]}
{"classification": 1, "content": "在计算机内部，一切信息存取、处理、传递的形式是", "code": "", "answer": ["C"], "explanation": "输入计算机的任何信息最终都要转为二进制", "source": "C1552", "subproblem": [{"content": "", "choice": ["ASCII码", "BCD码", "二进制", "十六进制"]}]}
{"classification": 1, "content": "2KB的内存能存储（   ）个汉字的机内码", "code": "", "answer": ["A"], "explanation": "一个汉字机内码占2个字节，2KB是2*1024个字节", "source": "C1553", "subproblem": [{"content": "", "choice": ["1024", "516", "2048", "218"]}]}
{"classification": 1, "content": "64KB的存储器用十六进制表示，它的最大地址码是", "code": "", "answer": ["B"], "explanation": "64KB即64*1024字节，等于2^{16}字节，需要16根地址线，最大地址码为1111111111111111（16个1），用十六进制表示为FFFF", "source": "C1554", "subproblem": [{"content": "", "choice": ["10000", "FFFF", "1FFFF", "EFFFF"]}]}
{"classification": 1, "content": "下列说法中，正确的是", "code": "", "answer": ["B"], "explanation": "计算机内部，所有数据都以二进制编码形式表示", "source": "C1555", "subproblem": [{"content": "", "choice": ["在内存中，可执行程序用二进制码表示，源程序用八进制表示", "程序和数据在内存中都是用二进制码表示的", "内存中数据的存取是以二进制位为单位的", "中央处理器CPU执行的每条指令长度都不同"]}]}
{"classification": 1, "content": "ASCII码的含义是", "code": "", "answer": ["B"], "explanation": "American Standard Code for Information Interchange", "source": "C1556", "subproblem": [{"content": "", "choice": ["二、十进制的转换码", "美国信息交换标准代码", "数字的二进制编码", "计算机可处理字符的唯一编码"]}]}
{"classification": 1, "content": "计算机病毒的特点是", "code": "", "answer": ["C"], "explanation": "计算机病毒的特点有：寄生性、传染性、潜伏性、隐蔽性、破坏性、可触发性等", "source": "C1557", "subproblem": [{"content": "", "choice": ["传播性、潜伏性、易读性、隐蔽性", "破坏性、传播性、潜伏性、安全性", "传播性、潜伏性、破坏性、隐蔽性", "传播性、潜伏性、破坏性、易读性"]}]}
{"classification": 1, "content": "计算机病毒是", "code": "", "answer": ["B"], "explanation": "病毒指“编制或在计算机程序中插入的破坏计算机功能或破坏数据，影响计算机使用并且能自我复制的一组计算机指令或程序代码”", "source": "C1558", "subproblem": [{"content": "", "choice": ["通过计算机传播的危害人体健康的一种病毒", "人为制造的能够入侵计算机系统并给计算机带来故障的程序或指令集合", "一种由于计算机元器件老化而产生的对生态环境有害的物质", "利用计算机的海量高速运算能力而研制出来的用于疾病预防的新型病毒"]}]}
{"classification": 1, "content": "在计算机中，防火墙的作用是", "code": "", "answer": ["B"], "explanation": "防火墙是一项协助确保信息安全的设备，会依照特定的原则，允许或限制传输的数据通过。防火墙可以是一台专属的硬件可以是假设在一般硬件上的一套软件。", "source": "C1559", "subproblem": [{"content": "", "choice": ["防止火灾蔓延", "防止网络攻击", "防止计算机死机", "防止使用者误删数据"]}]}
{"classification": 1, "content": "大部分计算机病毒会主要造成计算机（ ）的损坏", "code": "", "answer": ["A"], "explanation": "计算机病毒通常是导致正常的程序无法运行，把计算机内的文件删除或受到不同程度的损坏。只有少数特别厉害的病毒会破坏硬盘引导扇区及BIOS，从而导致硬件环境的破坏。", "source": "C1560", "subproblem": [{"content": "", "choice": ["软件和数据", "硬件和数据", "硬件、软件、数据", "硬件和软件"]}]}
{"classification": 1, "content": "计算机病毒主要是通过（ ）传播的", "code": "", "answer": ["A"], "explanation": "计算机病毒的扩散方式有多种：移动载体，如硬盘、U盘、文件等，受感染文件传播，邮件链接传播，直接安装方式等", "source": "C1561", "subproblem": [{"content": "", "choice": ["磁盘与网络", "微生物“病毒体”", "人体", "电源"]}]}
{"classification": 1, "content": "发现计算机病毒后，较为彻底的清除方法是", "code": "", "answer": ["B"], "explanation": "A错，因为病毒是隐藏传染的，删了一个文件也没用。C,D错，有些杀毒软件只能查到不能杀，有时还查不到。格式化是最彻底的，格式化后磁盘上没有东西了。", "source": "C1562", "subproblem": [{"content": "", "choice": ["删除磁盘文件", "格式化磁盘", "用查毒软件处理", "用杀毒软件处理"]}]}
{"classification": 1, "content": "计算机中的数有浮点数和定点数两种，其中用浮点数表示的数，通常由（  ）这两部分组成。", "code": "", "answer": ["C"], "explanation": "计算机中的数如1.701412E+09，叫指数计数法，也叫浮点计数法。其中1.701412叫做尾数，可以是一位非零整数或整数部分是一位非零数字的小数，小数点后最多6位数字。表示整数时，正号省略掉。E是exponent的第一个字母的大写形式，表示指数。后面+/-n叫阶码，阶码有两整数位，表示尾数所乘10的幂指数。绝对值小于10的阶码，输出时十位补0，阶码为正时，正号不省略", "source": "C1563", "subproblem": [{"content": "", "choice": ["指数与基数", "尾数与小数", "阶码与尾数", "整数与小数"]}]}
{"classification": 1, "content": "八位二进制数 [x]补码=10011000，其原码为", "code": "", "answer": ["B"], "explanation": "因为原码和补码互补，换算方式是一样的。原码=补码取反+1", "source": "C1564", "subproblem": [{"content": "", "choice": ["01100111", "11101000", "11100110", "01100101"]}]}
{"classification": 1, "content": "已知x=(0.1011010)2，则[x/2]补=", "code": "", "answer": ["C"], "explanation": "[x/2]原码=0.0101101，[x/2]补码=[x/2]原码", "source": "C1565", "subproblem": [{"content": "", "choice": ["0.1011101", "11110110", "0.0101101", "0.100110"]}]}
{"classification": 1, "content": "用十六位机器码1110001010000000来表示定点整数（最高位为符号位），当它是原码时表示的十进制真值为-25216，当它是补码时，表示的十进制真值是", "code": "", "answer": ["C"], "explanation": "求出补码后转换", "source": "C1566", "subproblem": [{"content": "", "choice": ["-12608", "-7551", "-7552", "-25216"]}]}
{"classification": 1, "content": "已知八位二进制数x的原码表示为11110111，下列（ ）是x的补码表示", "code": "", "answer": ["B"], "explanation": "符号位不变，其他位取反+1", "source": "C1567", "subproblem": [{"content": "", "choice": ["01010011B", "10001001B", "11111111B", "11000000B"]}]}
{"classification": 1, "content": "十进制数-103的补码是", "code": "", "answer": ["A"], "explanation": "十进制数-103的原码是11100111，反码是10011000，补码是10011001", "source": "C1568", "subproblem": [{"content": "", "choice": ["10011001", "11100111", "10110011", "00011001"]}]}
{"classification": 1, "content": "关于“零”的原码、反码、补码，下列说法正确的是", "code": "", "answer": ["C"], "explanation": "零的补码表示只有一种，就是全0，如果最高位符号是1，则为当前字节表示下的负数最大值，比如10000000的十进制真值是-128", "source": "C1569", "subproblem": [{"content": "", "choice": ["零的原码表示只有一种", "零的反码表示只有一种", "零的补码表示只有一种", "零的原码、反码、补码表示都有两种"]}]}
{"classification": 1, "content": "计算机网络是一个（ ）系统", "code": "", "answer": ["D"], "explanation": "计算机网络，是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统、网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递在协议控制下的多机互联系统", "source": "C1570", "subproblem": [{"content": "", "choice": ["管理信息系统", "管理数据系统", "编译系统", "在协议控制下的多机互联系统"]}]}
{"classification": 1, "content": "下面那些计算机网络不是按覆盖地域划分的", "code": "", "answer": ["D"], "explanation": "计算机网络按覆盖地域划分为局域网（LAN）、城域网（MAN）、广域网（WAN）。按拓扑结构分为总线型、星型、环形等。", "source": "C1571", "subproblem": [{"content": "", "choice": ["局域网", "城际网", "广域网", "星型网"]}]}
{"classification": 1, "content": "IPv4地址是由（  ）位二进制数码表示的", "code": "", "answer": ["C"], "explanation": "IPv4是32位的，共4字节，每个字节表示成十进制数，范围只有0到255。形如：10.250.36.78", "source": "C1572", "subproblem": [{"content": "", "choice": ["8", "16", "32", "64"]}]}
{"classification": 1, "content": "计算机网络最主要的优点是", "code": "", "answer": ["B"], "explanation": "资源共享指的是网上用户能部分或全部享受这些资源，包括软件、硬件、数据资源，提高系统资源的利用率", "source": "C1573", "subproblem": [{"content": "", "choice": ["运算速度快", "共享资源", "精度高", "存储容量大"]}]}
{"classification": 1, "content": "OSI的七层协议中，最底层是", "code": "", "answer": ["C"], "explanation": "OSI七层协议从上到下：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层", "source": "C1574", "subproblem": [{"content": "", "choice": ["会话层", "数据链路层", "物理层", "网络层"]}]}
{"classification": 1, "content": "下列IP地址错误的是", "code": "", "answer": ["A"], "explanation": "每个字节最大数值不超过255", "source": "C1576", "subproblem": [{"content": "", "choice": ["202.300.12.4", "192.168.0.3", "100.128.35.91", "19.255.0.1"]}]}
{"classification": 1, "content": "Internet的规范译名为", "code": "", "answer": ["B"], "explanation": "因特网又称国际互联网。万维网是WWW的中文名，World Wide Web的缩写。以太网是Xerox公司发明的基带局域网标准，现在泛指所有采用CSMA/CD协议的局域网。", "source": "C1578", "subproblem": [{"content": "", "choice": ["英特尔网", "因特网", "万维网", "以太网"]}]}
{"classification": 1, "content": "E-mail邮件本质上是一个", "code": "", "answer": ["A"], "explanation": "计算机是以文件方式管理数据的，计算机中绝大多数数据以文件的形式存在", "source": "C1579", "subproblem": [{"content": "", "choice": ["文件", "电报", "电话", "传真"]}]}
{"classification": 1, "content": "E-mail地址中用户名和邮件所在服务器名之间的分隔符是", "code": "", "answer": ["B"], "explanation": "电子邮件地址中必须有@符号", "source": "C1580", "subproblem": [{"content": "", "choice": ["#", "@", "&", "$"]}]}
{"classification": 1, "content": "下列电子邮件地址，正确的是", "code": "", "answer": ["A"], "explanation": "username@domain.com", "source": "C1581", "subproblem": [{"content": "", "choice": ["wang@hotmail.com", "cai@jcc.pc.tool@rf.edu.jp", "162.105.111.22", "ccf.edu.cn"]}]}
{"classification": 1, "content": "下列网络上常用名字缩写对应的中文解释错误的是", "code": "", "answer": ["C"], "explanation": "FTP：文件传输协议", "source": "C1582", "subproblem": [{"content": "", "choice": ["WWW：万维网", "URL：统一资源定位器", "FTP：快速传输协议", "HTTP：超文本传输协议"]}]}
{"classification": 1, "content": "一台计算机如果要利用电话线上网，就必须配置能够对数字信号和模拟信号进行相互转化的设备，这种设备是", "code": "", "answer": ["A"], "explanation": "调制解调器就是调制器+解调器，是一种计算机硬件，能把计算机的数字信号翻译成可沿电话线传送的脉冲信号，而这些脉冲信号又可被线路另一端的另一个调制解调器接收，并翻译成计算机可懂的数字信号", "source": "C1583", "subproblem": [{"content": "", "choice": ["调制解调器", "路由器", "网卡", "网桥"]}]}
{"classification": 1, "content": "下列哪个网络上常用的名字缩写是错误的", "code": "", "answer": ["D"], "explanation": "FTP(File Transfer Protocol)", "source": "C1584", "subproblem": [{"content": "", "choice": ["WWW(World Wide Web)", "URL(Uniform Resource Locator)", "HTTP(Hyper Text Transfer Protocol)", "FTP(Fast Transfer Protocol)"]}]}
{"classification": 1, "content": "常见的邮件传输服务器使用（   ）协议接收邮件", "code": "", "answer": ["D"], "explanation": "SMTP是发邮件协议，POP3是收邮件协议，IMAP是邮件访问协议", "source": "C1585", "subproblem": [{"content": "", "choice": ["IMAP", "SMTP", "FTP", "POP3"]}]}
{"classification": 1, "content": "表达式(4%(-3))与(-4%3)的值为", "code": "", "answer": ["B"], "explanation": "如果a 与d 是整数，d 非零，那么余数 r 满足这样的关系：a = qd + r , q 为整数，且0 ≤ |r| < |d|。-4%(3) = (-1)x(3)-1 = (-2)x(3)+2，所以这里的余数-1和2都满足定义。\n我们把2称为正余数，-1成为负余数。通常，当除以d 时，如果正余数为r1，负余数为r2，那么有r1 = r2 + d。\n所有语言和计算器都遵循了尽量让【商尽量靠近0】的原则，即-4%3 的离0更近的商为-1，所以余数结果为-1而不是2", "source": "C1586", "subproblem": [{"content": "", "choice": ["-1，-1", "1，-1", "-1，1", "1，1"]}]}
{"classification": 1, "content": "一个向量的第一个元素的存储地址是100，每个元素的长度为2，则第5个元素的地址是", "code": "", "answer": ["B"], "explanation": "元素存储位置均取决于第1个数据元素的存储位置，即LOC(ai)=LOC(a1)+(i-1)*C，所以第5个元素地址为100+2*(5-1)=108", "source": "C1587", "subproblem": [{"content": "", "choice": ["110", "108", "100", "109"]}]}
{"classification": 1, "content": "算法是指", "code": "", "answer": ["B"], "explanation": "算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。简单的说，算法就是解决问题的操作步骤", "source": "C1588", "subproblem": [{"content": "", "choice": ["为解决问题而编制的计算机程序", "为解决问题而采取的方法与步骤", "为解决问题而需要采取的计算机语言", "为解决问题而采用的计算方法"]}]}
{"classification": 1, "content": "下面关于算法的错误说法是", "code": "", "answer": ["B"], "explanation": "算法除了以计算机语言实现外，还可以框图、文字等方式存在", "source": "C1589", "subproblem": [{"content": "", "choice": ["算法必须有输出", "算法必须在计算机上用某种语言实现", "算法不一定有输入", "算法必须在有限步执行后能结束"]}]}
{"classification": 1, "content": "在下列关于计算机算法的说法中，不正确的是", "code": "", "answer": ["A"], "explanation": "算法是在有限步骤内求解某一问题所使用的一组定义明确的规则。一个算法应该具有：有穷性（有限步后结束）、确切性（每一步有确切定义）、输入（有0个或多个输入）、输出（有一个或多个输出）、可行性（能够精确运行，而且人们用笔和纸做有限次运算后即可完成）。", "source": "C1590", "subproblem": [{"content": "", "choice": ["一个正确的算法至少有一个输入", "算法的改进，很大程度上推动了计算机科学与技术的进步", "判断一个算法的好坏的主要标准是算法的时间复杂性与空间复杂性", "目前仍然存在许多涉及国计民生的重大课题，还没有找到能够在计算机上实施的有效方案"]}]}
{"classification": 1, "content": "在待排序的数据表已经为有序时，下列排序算法中花费时间反而多的是", "code": "", "answer": ["D"], "explanation": "最坏情况下，是整个序列都已经有序，此时，快速排序退化为冒泡排序，要比较n*(n-1)/2次才能完成", "source": "C1591", "subproblem": [{"content": "", "choice": ["堆排序", "希尔排序", "冒泡排序", "快速排序"]}]}
{"classification": 1, "content": "在所有排序方法中，关键字比较次数与记录的初始排序次序无关的是", "code": "", "answer": ["D"], "explanation": "选择排序特点是排序总是从第一位开始，与起始位无关。比较次数是固定的。", "source": "C1592", "subproblem": [{"content": "", "choice": ["希尔排序", "快速排序", "插入排序", "选择排序"]}]}
{"classification": 1, "content": "在下列各种排序算法中，不是以“比较”作为主要操作的算法是", "code": "", "answer": ["D"], "explanation": "基数排序按照个、十、百……轮流排序", "source": "C1593", "subproblem": [{"content": "", "choice": ["选择排序", "冒泡排序", "插入排序", "基数排序"]}]}
{"classification": 1, "content": "某数列有1000个各不相同的单元，由低至高按序排列。现要对该数列进行二分法检索，最坏情况下，需检视（   ）个单元", "code": "", "answer": ["B"], "explanation": "2^9<1000<2^{10}", "source": "C1595", "subproblem": [{"content": "", "choice": ["1000", "10", "100", "9"]}]}
{"classification": 1, "content": "在顺序表（2，5，7，10，14，15，18，23，35，41，52）中，用二分法查找12，所需关键码比较的次数为", "code": "", "answer": ["C"], "explanation": "该数需要依次和15，7，10，14比较", "source": "C1596", "subproblem": [{"content": "", "choice": ["2", "3", "4", "5"]}]}
{"classification": 1, "content": "字符串“ababacbab”和字符串“abcba”的最长公共子串", "code": "", "answer": ["B"], "explanation": "暴力模拟", "source": "C1598", "subproblem": [{"content": "", "choice": ["abcba", "cba", "abc", "ab"]}]}
{"classification": 1, "content": "电线上停着两种鸟（A,B），可以看出两只相邻的鸟就将电线分成了一个线段。这些线段可分类为：一类是两端小鸟相同；一类是两端小鸟不相同。已知：电线两个顶点上正好停着相同的小鸟，试问两端为不同小鸟的线段数目一定是（    ）", "code": "", "answer": ["B"], "explanation": "本题可考虑每增加一只小鸟，两端为不同小鸟的线段数的奇偶性是否发生变化。设想第一种情况，新增加的小鸟（如A）落在同类鸟（如AA）中间，则两端为不同小鸟的线段数目不变，奇偶性不发生变化。第二种情况，新增加的小鸟（如A）落在了两只同类鸟（如BB）中间，线段数增加2，奇偶性不发生变化。第三种情况，新增加的小鸟（如A）落在了一只同类鸟和一只不同类鸟（AB/BA），则两端为不同小鸟的线段数目减少一个，增加一个，总数不变，奇偶性也不变。可设定开始时只有两只相同小鸟停在两端，两端为不同小鸟的线段数为0，是偶数，一只小鸟飞进来奇偶性都不改变，因此一定是偶数。", "source": "C1599", "subproblem": [{"content": "", "choice": ["奇数", "偶数", "可奇可偶", "数目固定"]}]}
{"classification": 1, "content": "线性表若采用链表存储结构，要求内存中可用存储单元地址（   ）", "code": "", "answer": ["D"], "explanation": "链表中每个元素都有一个指针域，指向下一个节点，所以可以不连续，当然连续也可以。如果换成数组，则必须连续。", "source": "C1601", "subproblem": [{"content": "", "choice": ["必须连续", "部分地址必须连续", "一定连续", "连续不连续均可"]}]}
{"classification": 1, "content": "在编程时（使用任何一种高级语言，不一定是C++），如果需要从磁盘文件中输入一个很大的二维数组（例如1000*1000的double数组），按行读（即外层循环是关于行的）与按列读（即外层循环是关于列的）相比，在输入效率上", "code": "", "answer": ["D"], "explanation": "和数组存储方式有关。譬如数组是a[1000][100]，或者数组是a[100][1000]，效率可能就不同了。a[100][1000]，虽然输入的是100 * 100的数，但是第一个输入到第一百个是连续的，第100个和第101个，实际上会跨过了长度为900的地址。所以a[1000][100]的输入效率比a[100][1000]高", "source": "C1602", "subproblem": [{"content": "", "choice": ["没有区别", "按行读的方式要高一些", "按列读的方式要高一些", "取决于数组的存储方式"]}]}
{"classification": 1, "content": "下列叙述中，正确的是", "code": "", "answer": ["D"], "explanation": "链表存储在某些方面是优于线性存储结构的，队列操作方式先进先出，堆栈操作方式是后进先出", "source": "C1603", "subproblem": [{"content": "", "choice": ["线性表的线性存储结构优于链表存储结构", "队列的操作方式是先进后出", "栈的操作方式是先进先出", "二维数组是指它的每个数据元素是一个线性表的线性表"]}]}
{"classification": 1, "content": "已知A=35H，A ∧ 05H ∨ A ∧ 30H的结果是", "code": "", "answer": ["B"], "explanation": "将上述十六进制数转化成二进制数，进行位运算，注意：与运算比或运算优先级高。", "source": "C1604", "subproblem": [{"content": "", "choice": ["0", "1", "35H", "53H"]}]}
{"classification": 1, "content": "假设A=true，B=false，C=true，D=true，逻辑运算表达式A∧B∨C∧D的值是", "code": "", "answer": ["A"], "explanation": "注意：与运算比或运算优先级高", "source": "C1605", "subproblem": [{"content": "", "choice": ["true", "false", "0", "NULL"]}]}
{"classification": 1, "content": "设全集为E={1,2,3,4,5}，集合A={1,4}，B={1,2,5}，C={2,4}，则集合(A∩B)∪~C为", "code": "", "answer": ["D"], "explanation": "A∩B={1}，~C={1,3,5}", "source": "C1606", "subproblem": [{"content": "", "choice": ["空集", "{1}", "{1,5}", "{1,3,5}"]}]}
{"classification": 1, "content": "设全集I={a,b,c,d,e,f,g}，集合A={a,b,c}，B={b,d,e}，C={e,f,g}，那么集合(A-B)∪(~C∩B)为", "code": "", "answer": ["A"], "explanation": "A-B={a,c}，~C={a,b,c,d}，~C∩B={b,d}", "source": "C1607", "subproblem": [{"content": "", "choice": ["{a,b,c,d}", "{a,b,d,e}", "{b,d,e}", "{b,c,d,e}"]}]}
{"classification": 1, "content": "A=true,B=false,C=false,D=true，以下逻辑运算表达式值为真的是", "code": "", "answer": ["D"], "explanation": "注意，与运算优先级比或运算高", "source": "C1608", "subproblem": [{"content": "", "choice": ["(A∧B)∨C∧D", "((A∧B)∨C)∧D", "A∧(B∨C∧D)", "(A∧B∨C)∨D"]}]}
{"classification": 1, "content": "设A=B=D=true，C=false，下列逻辑运算表达式值为真的是", "code": "", "answer": ["B"], "explanation": "非运算优先级>与运算>或运算", "source": "C1610", "subproblem": [{"content": "", "choice": ["(¬A∧B)∨C∧D", "¬((A∨B∨D)∧C)", "¬A∧(B∨C∨D)", "(A∧B∧C)∨¬D"]}]}
{"classification": 1, "content": "设A=B=true，C=D=false，以下逻辑运算表达式值为假的是", "code": "", "answer": ["D"], "explanation": "非运算优先级>与运算>或运算", "source": "C1611", "subproblem": [{"content": "", "choice": ["(¬A∧B)∨C∧D∨A", "¬(((A∧B)∨C)∧D)", "A∧B∨C∨D∨D", "(A∧D∨C)∧B"]}]}
{"classification": 1, "content": "在c++中，表达式21 ^ 2的值是（   ）", "code": "", "answer": ["C"], "explanation": "异或操作，21在二进制下为10101，2在二进制下为00010，两数异或得到结果10111，再将其转换为十进制数，得到结果23", "source": "C1612", "subproblem": [{"content": "", "choice": ["441", "42", "23", "24"]}]}
{"classification": 1, "content": "在C++中，判断a不等于0且b不等于0的正确条件表达式是", "code": "", "answer": ["D"], "explanation": "0为假，非0为真", "source": "C1613", "subproblem": [{"content": "", "choice": ["!a==0||!b==0", "!((a==0)&&(b)==0)", "!(a==0&&b==0)", "a&&b"]}]}
{"classification": 1, "content": "在C++中，表达式23|2^5的值是", "code": "", "answer": ["A"], "explanation": "^为位运算异或，不同为1，相同为0，注意与运算>异或运算>或运算", "source": "C1614", "subproblem": [{"content": "", "choice": ["23", "1", "32", "18"]}]}
{"classification": 1, "content": "在C++中，判断a等于0或b等于0或c等于0的正确的条件表达式是", "code": "", "answer": ["B"], "explanation": "D语法错误，题目要求相当于a==0||b==0||c==0，abc只要有一个为真就成立，可以穷举验证", "source": "C1615", "subproblem": [{"content": "", "choice": ["!((a!=0)||(b!=0)||(c)!=0)", "!((a!=0)&&(b!=0)&&(c)!=0)", "!(a==0&&b==0)||(c)!=0)", "(a=0)&&(b=0)&&(c)=0"]}]}
{"classification": 1, "content": "若已知一个栈的入栈顺序是1，2，3，……，n，其输出序列为P1,P2,P3,……，Pn，若P1是n，则Pi是", "code": "", "answer": ["C"], "explanation": "归纳总结：(P1,n),(P1,n-1)…所以是n-i+1", "source": "C1616", "subproblem": [{"content": "", "choice": ["i", "n-1", "n-i+1", "不确定"]}]}
{"classification": 1, "content": "以下哪一个不是栈的基本运算", "code": "", "answer": ["B"], "explanation": "堆栈删除和插入操作只能在栈顶进行", "source": "C1617", "subproblem": [{"content": "", "choice": ["删除栈顶元素", "删除栈底元素", "判断栈是否为空", "将栈置为空栈"]}]}
{"classification": 1, "content": "已知元素（8，25，14，87，51，90，6，19，20），则这些元素以（  ）的顺序进入栈，才能使出栈顺序满足：8在51前面；90在87后面；20在14后面；25在6的前面；19在90的后面", "code": "", "answer": ["D"], "explanation": "根据栈先进后出原则，出栈顺序和入栈顺序相反，所以把题目中两个数字的前后顺序倒过来，然后检查每个选项是否符合这些顺序要求", "source": "C1619", "subproblem": [{"content": "", "choice": ["20，6，8，51，90，25，14，19，87", "51，6，19，20，14，8，87，90，25", "19，20，90，8，6，25，51，14，87", "6，25，51，8，20，19，90，87，14"]}]}
{"classification": 1, "content": "某个车站呈狭长型，宽度只能容下一台车，并且只有一个输入口。已知某时刻，该车站状态为空，从这一时刻开始的出入记录为：“进，出，进，进，进，出，出，进，进，进，出，出”。假设车辆入站的顺序为1，2，3……，则车辆出站的顺序为", "code": "", "answer": ["C"], "explanation": "模拟栈即可", "source": "C1620", "subproblem": [{"content": "", "choice": ["1，2，3，4，5", "1，2，4，5，7", "1，4，3，7，6", "1，4，3，7，2"]}]}
{"classification": 1, "content": "设栈S的初始状态为空，元素a，b，c，d，e依次入栈，以下出栈序列不可能出现的有", "code": "", "answer": ["C"], "explanation": "C中a和e出栈后，从栈顶到栈底有d、c、b，d没有出栈，c和b出不来", "source": "C1621", "subproblem": [{"content": "", "choice": ["a，b，c，e，d", "b，c，a，e，d", "a，e，c，b，d", "d，c，e，b，a"]}]}
{"classification": 1, "content": "地面上有标号为A、B、C的3根细柱，在A柱上放有10个直径相同中间有圆孔的圆盘，从上到下依次编号为1，2，3……，将A柱上的部分盘子经过B柱移入C柱，也可以在B柱上暂存。如果B柱上的操作记录为：“进，进，出，进，进，出，出，进，进，出，进，出，出”，那么，在C柱上，从下到上的盘子编号为", "code": "", "answer": ["D"], "explanation": "模拟即可", "source": "C1622", "subproblem": [{"content": "", "choice": ["2，4，3，6，5，7", "2，4，1，2，5，7", "2，4，3，1，7，6", "2，4，3，6，7，5"]}]}
{"classification": 1, "content": "设循环队列中数组的下标范围是1~n，其头尾指针分别为f和r，则其元素个数为", "code": "", "answer": ["D"], "explanation": "循环队列中f和r不一定满足f<r，如果满足f<r，则元素个数为r-f；但有时也会r<f，所以需要加n然后对n取余才能统一表示", "source": "C1623", "subproblem": [{"content": "", "choice": ["r-f", "r-f+1", "(r-f)%n+1", "(r-f+n)%n"]}]}
{"classification": 1, "content": "已知队列（13，2，11，34，41，77，5，7，18，26，15），第一个进入队列的元素是13，则第五个出队列的元素是", "code": "", "answer": ["B"], "explanation": "根据队列先进先出的操作原则，第一个进入队列的是13，则第一个出队的也是13，向后依次为2，11，34，41，77，5，7，18，26，15。其中第五个是41", "source": "C1624", "subproblem": [{"content": "", "choice": ["5", "41", "77", "13"]}]}
{"classification": 1, "content": "若用一个大小为6的数组来实现循环队列，且当rear和front的值分别为0和3。当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为", "code": "", "answer": ["B"], "explanation": "删除一个元素，则front要前进一格，即3+1=4；加入两个元素，则rear要前进两格，即0+2=2；所以rear和front的值分别为2和4", "source": "C1625", "subproblem": [{"content": "", "choice": ["1和5", "2和4", "4和2", "5和1"]}]}
{"classification": 1, "content": "一个高度为h的二叉树最小元素数目是", "code": "", "answer": ["B"], "explanation": "呈链状", "source": "C1629", "subproblem": [{"content": "", "choice": ["2h+1", "h", "2h-1", "2^{h}-1"]}]}
{"classification": 1, "content": "满二叉树的叶节点个数为N，则它的结点总数是（  ）", "code": "", "answer": ["C"], "explanation": "【分析1】根据二叉树性质，n0=n2+1，满二叉树没有度为1的节点，所以选C。\n【分析2】总共是2^n-1，第n排叶子总数2^{n-1}，最后一排是n，前面所有的和是n-1，答案是2n-1", "source": "C1632", "subproblem": [{"content": "", "choice": ["N", "2*N", "2*N-1", "2^{N}-1"]}]}
{"classification": 1, "content": "完全二叉树的结点个数为11，则它的叶节点个数为", "code": "", "answer": ["D"], "explanation": "左下角不许缺，右下可以", "source": "C1633", "subproblem": [{"content": "", "choice": ["4", "3", "5", "6"]}]}
{"classification": 1, "content": "二叉树T的宽度优先遍历序列为A B C D E F G H I，已知A是C的父节点，D是G的父节点，F是I的父节点，树中所有结点的最大深度为3（根节点深度设为0），可知F的父节点是", "code": "", "answer": ["C"], "explanation": "根节点是A，A是C的父节点，而序列中B在C前，说明B也是A的子节点，这样就排满了深度为1的情况。接下来深度为2时，D和F必须都为深度为2，否则它们的子节点深度将会超过3。而序列中E夹在D和F中间，由二叉树可以确定D父节点一定是B，E的父亲可能是B也可能是C，但无论哪种情况，F的父节点一定是C。", "source": "C1634", "subproblem": [{"content": "", "choice": ["无法确定", "B", "C", "D"]}]}
{"classification": 1, "content": "高度为n的均衡的二叉树是指：如果去掉叶节点及相应的树枝，它应该是高度为n-1的满二叉树。在这里，树高等于叶节点的最大深度，根节点的深度为0，如果某个均衡的二叉树共有2381个结点，则该树树高为", "code": "", "answer": ["B"], "explanation": "2^{11}=2048。如果根节点的深度为1，则满二叉树节点总数为2^{深度-1}，由于2048-1=2047<2381，故整个树高为11（满二叉树）+1=12。本题根节点深度为0，所以树高为11", "source": "C1635", "subproblem": [{"content": "", "choice": ["10", "11", "12", "13"]}]}
{"classification": 1, "content": "已知6个结点的二叉树的先根遍历为1 2 3 4 5 6（数字为结点的编号，以下同），后根遍历是3 2 5 6 4 1，则该二叉树的可能的中根遍历是", "code": "", "answer": ["B"], "explanation": "先根、中根、后根分别指的是先序、中序、后序，可以根据先根和任一可能的中根形成一棵二叉树，然后读取其后根遍历，如果和题干中后根遍历相同，即为答案", "source": "C1636", "subproblem": [{"content": "", "choice": ["3 2 1 4 6 5", "3 2 1 5 4 6", "2 1 3 5 4 6", "2 3 1 4 6 5"]}]}
{"classification": 1, "content": "已知7个结点的二叉树的先根遍历是1 2 4 5 6 3 7（数字为结点编号，以下同），中根遍历是4 2 6 5 1 7 3，则该二叉树的后根遍历是", "code": "", "answer": ["A"], "explanation": "1为根，2为左子根，3为右子根，7为3的左子根，4为2的左子根，5为2的右子根，6为5的左子根。", "source": "C1637", "subproblem": [{"content": "", "choice": ["4 6 5 2 7 3 1", "4 6 5 2 1 3 7", "4 2 3 1 5 4 7", "4 6 5 3 1 7 2"]}]}
{"classification": 1, "content": "在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的（  ）倍", "code": "", "answer": ["B"], "explanation": "在有向图中，所有顶点的入度之和等于所有顶点的出度之和", "source": "C1639", "subproblem": [{"content": "", "choice": ["1/2", "1", "2", "4"]}]}
{"classification": 1, "content": "假设我们用d=(a1,a2,…,a5)，表示无向图G中的5个顶点的度数，下面给出的哪组d值合理", "code": "", "answer": ["B"], "explanation": "每条边被两个顶点计算度数，因此度数和必为偶数，ACD的度数和为奇数，因此正确答案为BE", "source": "C1640", "subproblem": [{"content": "", "choice": ["{5,4,4,3,1}", "{4,2,2,1,1}", "{3,3,3,2,2}", "{5,4,3,2,1}"]}]}
{"classification": 1, "content": "平面上有五个点A(5,3),B(3,5),C(2,1),D(3,3),E(5,1)。以这五点作为完全图G的顶点，每两点之间的直线距离是图G中对应边的权值。以下哪条边不是图G的最小生成树中的边", "code": "", "answer": ["D"], "explanation": "笛卡尔坐标系画出来，标上顶点后，把完全图画好后，用kruskal的方式，即从小到大把边排序，试图把每条边加入图中，若加入后会使图中有环，则不加入该条边，直到遍历完所有的边，得到n-1条边", "source": "C1642", "subproblem": [{"content": "", "choice": ["AD", "BD", "CD", "DE"]}]}
{"classification": 1, "content": "欧拉图G是指可以构成一个闭回路的图，且图G的每一条边恰好在这个闭回路上出现一次（即一笔画成）。在以下各个描述中，不一定是欧拉图的是", "code": "", "answer": ["D"], "explanation": "D是哈密尔顿图，欧拉图是每边一次，一笔画问题，闭迹回到起点封口", "source": "C1644", "subproblem": [{"content": "", "choice": ["图G中没有度为奇数的顶点", "包括欧拉环游的图（欧拉环游是指通过图中每条边恰好一次）", "包括欧拉闭迹的图（欧拉迹是指通过图中每遍恰好一次的路径）", "存在一条回路，通过每个顶点恰好一次"]}]}
{"classification": 1, "content": "体领域经常提到的14nm、7nm等数值是指（　　）。", "code": "", "answer": ["D"], "explanation": "我们平时所讲14nm或者7nm说的是晶体管的宽度（也叫线宽），要想做到纳米级的电路，工艺难度是很难的。在制造晶体管的国产中涉及到光刻、刻蚀等复杂的加工工艺。", "source": "C1647", "subproblem": [{"content": "", "choice": ["集成电路的运算速度", "集成电路的制程工艺", "集成电路的运算功耗", "集成电路的尺寸"]}]}
{"classification": 1, "content": "传递消息时的“嘀”表示短声，“嗒”表示长声。“嘀嘀嗒嗒”所表示的二进制编码为（）。", "code": "", "answer": ["B"], "explanation": "“嘀嘀嗒嗒”中，“滴”表示1，“嗒”表示0，在二进制中表示1100。", "source": "C1648", "subproblem": [{"content": "", "choice": ["1001", "1100", "1010", "1011"]}]}
{"classification": 1, "content": "硬盘的容量比软盘大得多，其读写速度与软盘相比（　　）。", "code": "", "answer": ["A"], "explanation": "大容量的硬盘读写速度比小容量的内存要快得多，举个例子：\n1.44M的软驱读写速度约为500KB/s\n现在最流行的串口硬盘（7200转的）内部传输速率为683Mbits/s 外部传输速率为150MB/s。", "source": "C1650", "subproblem": [{"content": "", "choice": ["快得多", "慢得多", "慢一些", "快一些"]}]}
{"classification": 1, "content": "下面对算法概念阐述正确的是（　　）。", "code": "", "answer": ["B"], "explanation": "无论是时间复杂度还是空间复杂度，均跟代码的条数无关，而是分别跟时间效率、使用内存有关。算法的执行效率与数据的存储结构有关，地址的不同会影响数据的寻址时间。", "source": "C1651", "subproblem": [{"content": "", "choice": ["算法的空间复杂度是指描述算法的程序中出现的语句的条数", "算法的有穷性是指算法必须能在有限步后终止", "算法的时间复杂度是指描述算法的程序中出现语句的条数", "算法的执行效率与数据的存储结构无关"]}]}
{"classification": 1, "content": "中国的国家顶级域名是（　　）。", "code": "", "answer": ["D"], "explanation": "中国的国家顶级域名是cn", "source": "C1652", "subproblem": [{"content": "", "choice": ["com", "net", "cc", "cn"]}]}
{"classification": 1, "content": "为计算程序拟定算法、书写第一份流程图，世界上公认的第一位程序员是（　　）。", "code": "", "answer": ["A"], "explanation": "奥古斯塔·阿达·金，勒芙蕾丝伯爵夫人（Augusta Ada King, Countess of Lovelace，1815年12月10日－1852年11月27日），原名奥古斯塔·阿达·拜伦（Augusta Ada Byron），通称阿达·洛芙莱斯（Ada Lovelace），是著名英国诗人拜伦之女，数学家。计算机程序创始人，建立了循环和子程序概念。为计算程序拟定算法、书写第一份流程图，世界上公认的第一位程序员是阿达·洛芙莱斯", "source": "C1653", "subproblem": [{"content": "", "choice": ["阿达·洛芙莱斯", "戈登·摩尔", "阿兰·图灵", "冯·诺伊曼"]}]}
{"classification": 1, "content": "2021年6月2日，华为正式发布新一代智能终端操作系统——（　　）。", "code": "", "answer": ["C"], "explanation": "华为正式发布新一代智能终端操作系统是鸿蒙系统。", "source": "C1654", "subproblem": [{"content": "", "choice": ["方舟OS", "iOS", "鸿蒙OS 2.0", "安卓OS"]}]}
{"classification": 1, "content": "32位操作系统和64位操作系统的最主要区别是（　　）。", "code": "", "answer": ["C"], "explanation": "32位操作系统和64位操作系统的最主要区别是地址线数量不同，也就是说32位最多支持访问内存空间地址为2的32次方，而64位最多支持的是2的64次方。", "source": "C1655", "subproblem": [{"content": "", "choice": ["内存空间不同", "硬盘空间不同", "寻址空间不同", "主板大小不同"]}]}
{"classification": 1, "content": "断电后，存储的数据会丢失的是（　　）。", "code": "", "answer": ["A"], "explanation": "RAM存储时，需要通电操作。对计算机RAM中的信息进行读、写操作时，主机必须通电。", "source": "C1656", "subproblem": [{"content": "", "choice": ["RAM", "网盘", "ROM", "光盘"]}]}
{"classification": 1, "content": "有8枚金币，其中有且只有1枚是假币。假币的重量比真币轻。你只有一台天平，请设计一个方案，在最坏情况下，最少需要用几次天秤才能找出假币？", "code": "", "answer": ["D"], "explanation": "第一次，我们取成3个、3个、2个，其3个的两堆放上两边秤砣，然后最坏情况就是天平向某一边倾斜，此时还需要1次操作，放1个、1个、1个，进行比较就可以了。", "source": "C1657", "subproblem": [{"content": "", "choice": ["4次", "3次", "1次", "2次"]}]}
{"classification": 1, "content": "能被计算机直接识别运行的语言是（　　）。", "code": "", "answer": ["C"], "explanation": "在所有的程序设计语言中，只有机器语言编制的源程序能够被计算机直接理解和执行。", "source": "C1658", "subproblem": [{"content": "", "choice": ["自然语言", "汇编语言", "机器语言", "高级语言"]}]}
{"classification": 1, "content": "某学校开设机器人、编程和舞蹈三个社团，其中参加机器人社团的有30人，参加编程社团的有15人，参加舞蹈社团的有18人，参加这三个社团中至少一个社团的人数为50人，其中有3人同时参加了三个社团，那么恰好参加两个社团的同学有（　　）人。", "code": "", "answer": ["B"], "explanation": "可以列方程进行求解。假设参加一个社团的有x个人，参加两个社团的有y个人，于是有x + y + 3 = 50，则x + y = 47。又有x + 2y = 27 + 12 + 15 = 54，则y = 7。", "source": "C1659", "subproblem": [{"content": "", "choice": ["12", "7", "11", "9"]}]}
{"classification": 1, "content": "用于测试机器是否具备人类思考模式的方法是（　　）。", "code": "", "answer": ["C"], "explanation": "图灵测试是图灵发明的一种测试机器是不是具备人类思考模式的方式。", "source": "C1661", "subproblem": [{"content": "", "choice": ["黑盒测试", "机器测试", "图灵测试", "智商测试"]}]}
{"classification": 1, "content": "已知十进制中的5在二进制中为101，那么十进制中11在二进制中为（　　）。", "code": "", "answer": ["D"], "explanation": "(11)10 = (8 + 2 + 1) = (1011)2。", "source": "C1662", "subproblem": [{"content": "", "choice": ["1010", "1101", "1111", "1011"]}]}
{"classification": 1, "content": "阿兰图灵是哪国人？", "code": "", "answer": ["C"], "explanation": "阿兰•图灵(1912.6.23—1954.6.7),英国数学家、逻辑学家,被称为计算机科学之父、人工智能之父,是计算机逻辑的奠基者,提出了“图灵机”和“图灵测试”等重要概念。", "source": "C1665", "subproblem": [{"content": "", "choice": ["匈牙利人", "法国人", "英国人", "德国人"]}]}
{"classification": 1, "content": "健康码是通过大数据分析与计算，反应用户的“风险等级”信息，可以作为出入通行的电子凭证，这体现了信息的（　　）。", "code": "", "answer": ["A"], "explanation": "信息共享性是信息在一定的时空范围内可以被多个认识主体接收和利用。信息的价值性表现在满足人们的精神生活所需。信息的时效性就是信息在一定时间范围内的效力。信息的依附性是指信息必须依附媒介才能传播。即信息要借助于某种符号表现出来。", "source": "C1666", "subproblem": [{"content": "", "choice": ["共享性", "价值性", "时效性", "依附性"]}]}
{"classification": 1, "content": "100以内的最大素数是（　　）。", "code": "", "answer": ["B"], "explanation": "97是100以内最大的素数。", "source": "C1667", "subproblem": [{"content": "", "choice": ["91", "97", "95", "93"]}]}
{"classification": 1, "content": "若当前网速为80000000000bit/秒，要下载一个50G的文件大约需要（　　）。", "code": "", "answer": ["B"], "explanation": "8 * 10^10 bit/s = 10^10 Byte/s ≈ 10 GB/s，所以大致上需要5秒。", "source": "C1668", "subproblem": [{"content": "", "choice": ["1秒", "5秒", "50秒", "0.5秒"]}]}
{"classification": 1, "content": "应用软件和系统软件的相互关系是（ ）。", "code": "", "answer": ["B"], "explanation": "系统软件为控制和协调计算机及外部设备，支持应用软件开发和运行的系统。\n各种应用软件，虽然完成的工作各不相同，但它们都需要一些共同的基础操作，例如都要从输入设备取得数据，向输出设备送出数据，向外存写数据，从外存读数据，对数据的常规管理，等等。这些基础工作也要由一系列指令来完成。\n人们把这些指令集中组织在一起，形成专门的软件，用来支持应用软件的运行，这种软件称为系统软件。", "source": "C1669", "subproblem": [{"content": "", "choice": ["每一类都不以另一类为基础", "前者以后者为基础", "后者以前者为基础", "每一类都以另一类为基础"]}]}
{"classification": 1, "content": "在二进制下，1011001 +（　　）= 1100110。", "code": "", "answer": ["D"], "explanation": "在二进制中，1100110 - 1011001 = 1101。", "source": "C1671", "subproblem": [{"content": "", "choice": ["1111", "1010", "1011", "1101"]}]}
{"classification": 1, "content": "某人走楼梯，每步可以跨1个台阶或2个台阶，若要走4个台阶，有5种方法，如果要走6个台阶，有（　　）种方法。", "code": "", "answer": ["C"], "explanation": "我们可以枚举每个台阶的情况，走一阶台阶有1种方法，走2阶台阶有2种方法，走3阶台阶有3种方法，为“1阶台阶+2阶台阶”的方案和，所以走i阶台阶的方案f(i) = f(i - 1) + f(i - 2)。", "source": "C1672", "subproblem": [{"content": "", "choice": ["12", "10", "13", "11"]}]}
{"classification": 1, "content": "以下曾获图灵奖的计算机科学家是（　　）。", "code": "", "answer": ["D"], "explanation": "姚期智，1946年12月24日出生于中国上海，计算机科学专家，2000年图灵奖获得者。", "source": "C1673", "subproblem": [{"content": "", "choice": ["王选", "陈省身", "王安", "姚期智"]}]}
{"classification": 1, "content": "以下不是计算机病毒特性的是（　　）。", "code": "", "answer": ["C"], "explanation": "计算机病毒具有传播性、隐蔽性、感染性、潜伏性、可激发性、表现性或破坏性。", "source": "C1674", "subproblem": [{"content": "", "choice": ["潜伏性", "破坏性", "特异性", "传播性"]}]}
{"classification": 1, "content": "人工智能的英文缩写为（　　）。", "code": "", "answer": ["D"], "explanation": "人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。", "source": "C1675", "subproblem": [{"content": "", "choice": ["MR", "VR", "AR", "AI"]}]}
{"classification": 1, "content": "健康码需要在出入公共场所时实时查询，截图无效，这体现了信息的（　　）。", "code": "", "answer": ["C"], "explanation": "信息共享性是信息在一定的时空范围内可以被多个认识主体接收和利用。信息的价值性表现在满足人们的精神生活所需。信息的时效性就是信息在一定时间范围内的效力。信息的依附性是指信息必须依附媒介才能传播。即信息要借助于某种符号表现出来。\n由于是实时查询，所以体现了信息的时效性。", "source": "C1676", "subproblem": [{"content": "", "choice": ["共享性", "依附性", "时效性", "价值性"]}]}
{"classification": 1, "content": "64位机中的64指的是（　　）。", "code": "", "answer": ["C"], "explanation": "这个位数指的是CPU GPRs(General-Purpose Registers，通用寄存器)的数据宽度为64位，64位指令集就是运行64位数据的指令，也就是说处理器一次可以运行64bit数据。", "source": "C1677", "subproblem": [{"content": "", "choice": ["内存容量", "微机型号", "机器字长", "存储单位"]}]}
{"classification": 1, "content": "摩尔曾预测集成电路上可以容纳的晶体管数目大约每（　　）便会增加一倍。", "code": "", "answer": ["A"], "explanation": "根据摩尔定律,当价格不变时,集成电路上可容纳的晶体管数目,约每隔18个月便会增加一倍,性能也将提升一倍。", "source": "C1678", "subproblem": [{"content": "", "choice": ["18个月", "12个月", "36个月", "24个月"]}]}
{"classification": 1, "content": "2MB等于（　　）。", "code": "", "answer": ["D"], "explanation": "1 MB = 1024 KB = 1024 * 1024 B。", "source": "C1679", "subproblem": [{"content": "", "choice": ["2 * 1000 * 1000 字节", "2 * 1024 字节", "2 * 1000 字节", "2 * 1024 * 1024 字节"]}]}
{"classification": 1, "content": "我国在1983年研制出第一台超级计算机（　　），使中国成为世界上第三个能独立设计和研制超级计算机的国家。", "code": "", "answer": ["A"], "explanation": "1983年底,我国第一台名叫\"银河\"的亿次巨型电子计算机诞生,标示着我国计算机技术的发展进入一个崭新的阶段。", "source": "C1680", "subproblem": [{"content": "", "choice": ["银河一号", "神舟一号", "天宫一号", "天问一号"]}]}
{"classification": 1, "content": "计算机之父是（）。", "code": "", "answer": ["C"], "explanation": "冯·诺依曼（John von Neumann，1903~1957），原籍匈牙利，布达佩斯大学数学博士。20世纪最重要的数学家之一，在现代计算机、博弈论、核武器和生化武器等领域内的科学全才之一，被后人称为“计算机之父”和“博弈论之父”。", "source": "C1681", "subproblem": [{"content": "", "choice": ["查尔斯·巴贝奇", "艾伦·麦席森·图灵", "冯·诺伊曼", "姚期智"]}]}
{"classification": 1, "content": "人工智能之父是（）。", "code": "", "answer": ["B"], "explanation": "艾伦·麦席森·图灵（Alan Mathison Turing，1912年6月23日－1954年6月7日），英国数学家、逻辑学家，被称为计算机科学之父，人工智能之父。", "source": "C1682", "subproblem": [{"content": "", "choice": ["查尔斯·巴贝奇", "艾伦·麦席森·图灵", "约翰·阿塔那索夫", "冯·诺依曼"]}]}
{"classification": 1, "content": "世界第一台电子计算机问世是在（）。", "code": "", "answer": ["A"], "explanation": "1946年2月15日，世界第一台电子计算机问世。", "source": "C1683", "subproblem": [{"content": "", "choice": ["1946年2月15日", "1947年2月17日", "1992年4月17日", "1990年10月2日"]}]}
{"classification": 1, "content": "计算机按照规模可以分类成为（）。", "code": "", "answer": ["A"], "explanation": "计算机按照规模可以分类成为巨、大、中、小、微。", "source": "C1684", "subproblem": [{"content": "", "choice": ["巨、大、中、小、微", "大、中、小、微", "中、小、微", "巨、中、小、微"]}]}
{"classification": 1, "content": "（）指计算机主时钟一秒钟内发出的脉冲数，在很大程度上决定了计算机的运算速度。", "code": "", "answer": ["B"], "explanation": "主频指计算机主时钟一秒钟内发出的脉冲数，在很大程度上决定了计算机的运算速度。", "source": "C1685", "subproblem": [{"content": "", "choice": ["字长", "主频", "内存容量", "外存容量"]}]}
{"classification": 1, "content": "（）指计算机能够直接处理的二进制数据的位数。", "code": "", "answer": ["A"], "explanation": "字长指计算机能够直接处理的二进制数据的位数。", "source": "C1686", "subproblem": [{"content": "", "choice": ["字长", "主频", "内存容量", "外存容量"]}]}
{"classification": 1, "content": "（）是标志计算机处理信息能力强弱的一项技术指标。单位微字节（Byte）。", "code": "", "answer": ["C"], "explanation": "内存容量是标志计算机处理信息能力强弱的一项技术指标。单位微字节（Byte）。", "source": "C1687", "subproblem": [{"content": "", "choice": ["字长", "主频", "内存容量", "外存容量"]}]}
{"classification": 1, "content": "计算机网络按其计算机及网络设备在空间上的排列形式分为（）。", "code": "", "answer": ["C"], "explanation": "计算机网络按其计算机及网络设备在空间上的排列形式分为星型、总线型和环形。", "source": "C1688", "subproblem": [{"content": "", "choice": ["树形、星型和总线型", "拓扑型、树形、星型和总线型", "星型、总线型和环形", "拓扑型、星型和总线型"]}]}
{"classification": 1, "content": "随机存储器简称是（）。", "code": "", "answer": ["B"], "explanation": "随机存储器简称是RAM。", "source": "C1689", "subproblem": [{"content": "", "choice": ["ROM", "RAM", "RRM", "CPU"]}]}
{"classification": 1, "content": "只读存储器的简称是（）。", "code": "", "answer": ["A"], "explanation": "只读存储器的简称是ROM。", "source": "C1690", "subproblem": [{"content": "", "choice": ["ROM", "RAM", "RRM", "CPU"]}]}
{"classification": 1, "content": "内存被称之为“主存储器”。它安装在（）。", "code": "", "answer": ["B"], "explanation": "内存安装在计算机的主板上。", "source": "C1691", "subproblem": [{"content": "", "choice": ["计算机硬盘上", "计算机的主板上", "计算机的USB接口上", "内存是虚假的存在，并没有实体"]}]}
{"classification": 1, "content": "以下关于内存说法不正确的是（）。", "code": "", "answer": ["D"], "explanation": "关闭计算机电源，只读存储器中存储的数据不会被修改，断电后保存在只读存储器内的数据不会消失。", "source": "C1692", "subproblem": [{"content": "", "choice": ["随机存储器中的数据可以由用户进行修改。", "关闭计算机电源，随机存储器中存储的数据将全部消失。", "只读存储器中存储的数据由计算机生产厂家写入，只能读取不能修改。", "关闭计算机电源，只读存储器中存储的数据将全部消失。"]}]}
{"classification": 1, "content": "CPU的主要功能是进行（）。", "code": "", "answer": ["D"], "explanation": "CPU的主要功能是进行算术逻辑运算与全机的控制。", "source": "C1693", "subproblem": [{"content": "", "choice": ["算术运算", "逻辑运算", "算术逻辑运算", "算术逻辑运算与全机的控制"]}]}
{"classification": 1, "content": "CPU能直接访问的存储部件是（）。", "code": "", "answer": ["C"], "explanation": "CPU能直接访问的存储部件是内存。", "source": "C1694", "subproblem": [{"content": "", "choice": ["软盘", "硬盘", "内存", "光盘"]}]}
{"classification": 1, "content": "通常所说的CPU芯片包括（）。", "code": "", "answer": ["A"], "explanation": "通常所说的CPU芯片包括控制器、运算器和寄存器组。", "source": "C1695", "subproblem": [{"content": "", "choice": ["控制器、运算器和寄存器组", "控制器、运算器和内存储器", "内存储器和运算器", "控制器和内存储器"]}]}
{"classification": 1, "content": "在内存中，每个基本单位都被赋予一个唯一的序号，这个序号称为（）。", "code": "", "answer": ["C"], "explanation": "在内存中，每个基本单位都被赋予一个唯一的序号，这个序号称为地址。", "source": "C1696", "subproblem": [{"content": "", "choice": ["字节", "编号", "地址", "容量"]}]}
{"classification": 1, "content": "在微机的性能指标中，用户可用的内存存储器容量是指（）。", "code": "", "answer": ["B"], "explanation": "在微机的性能指标中，用户可用的内存存储器容量是指RAM的容量。", "source": "C1697", "subproblem": [{"content": "", "choice": ["ROM的容量", "RAM的容量", "ROM和RAM的容量综合", "CD-ROM的容量"]}]}
{"classification": 1, "content": "计算机的I/O设备和主机之间的数据传送可通过（）实现。", "code": "", "answer": ["C"], "explanation": "计算机的I/O设备和主机之间的数据传送可通过串行接口和并行接口实现。", "source": "C1698", "subproblem": [{"content": "", "choice": ["串行接口", "并行接口", "串行接口和并行接口", "双向接口和单向接口"]}]}
{"classification": 1, "content": "计算机的主机包括（）。", "code": "", "answer": ["D"], "explanation": "计算机的主机包括CPU和主存。", "source": "C1699", "subproblem": [{"content": "", "choice": ["运算器和控制器", "CPU和磁盘存储器", "硬件和软件", "CPU和主存"]}]}
{"classification": 1, "content": "硬盘工作时应特别注意避免（）。", "code": "", "answer": ["C"], "explanation": "硬盘工作时应特别注意避免潮湿。", "source": "C1700", "subproblem": [{"content": "", "choice": ["噪声", "通电", "震动", "日光"]}]}
{"classification": 1, "content": "微机外存是指（）。", "code": "", "answer": ["C"], "explanation": "微机外存是指磁盘。", "source": "C1701", "subproblem": [{"content": "", "choice": ["RAM", "ROM", "磁盘", "虚拟盘"]}]}
{"classification": 1, "content": "CD-ROM是一种大容量的外部存储设备，其特点是（）。", "code": "", "answer": ["A"], "explanation": "CD-ROM是一种大容量的外部存储设备，其特点是只能读不能写。", "source": "C1702", "subproblem": [{"content": "", "choice": ["只能读不能写", "处理数据速度低于软盘", "只能写不能读", "既能写也能读"]}]}
{"classification": 1, "content": "存储器是用来存放（）信息的主要部件。", "code": "", "answer": ["B"], "explanation": "存储器是用来存放二进制信息的主要部件。", "source": "C1703", "subproblem": [{"content": "", "choice": ["十进制", "二进制", "八进制", "十六进制"]}]}
{"classification": 1, "content": "在下列设备中，不能作为微机的输出设备的是（）。", "code": "", "answer": ["D"], "explanation": "在下列设备中，不能作为微机的输出设备的是键盘。", "source": "C1704", "subproblem": [{"content": "", "choice": ["打印机", "显示器", "绘图仪", "键盘"]}]}
{"classification": 1, "content": "微型计算机的分类通常以微处理器的（）来划分。", "code": "", "answer": ["C"], "explanation": "微型计算机的分类通常以微处理器的字长来划分。", "source": "C1705", "subproblem": [{"content": "", "choice": ["规格", "芯片名", "字长", "寄存器的数目"]}]}
{"classification": 1, "content": "以80386微处理器为CPU的微机是（）位的微型计算机。", "code": "", "answer": ["C"], "explanation": "以80386微处理器为CPU的微机是32位的微型计算机。", "source": "C1706", "subproblem": [{"content": "", "choice": ["8", "16", "32", "64"]}]}
{"classification": 1, "content": "世界上首次提出存储程序计算机体系结构的是（）。", "code": "", "answer": ["B"], "explanation": "世界上首次提出存储程序计算机体系结构的是冯·诺伊曼。", "source": "C1707", "subproblem": [{"content": "", "choice": ["艾伦·图灵", "冯·诺伊曼", "莫奇莱", "比尔·盖茨"]}]}
{"classification": 1, "content": "1946年世界上有了第一台电子数字计算机，奠定了至今仍然在使用的计算机的（）。", "code": "", "answer": ["D"], "explanation": "1946年世界上有了第一台电子数字计算机，奠定了至今仍然在使用的计算机的体系结构。", "source": "C1708", "subproblem": [{"content": "", "choice": ["外型结构", "总线结构", "存储结构", "体系结构"]}]}
{"classification": 1, "content": "计算机工作最重要的特征是（）。", "code": "", "answer": ["C"], "explanation": "计算机工作最重要的特征是存储程序和程序控制。", "source": "C1709", "subproblem": [{"content": "", "choice": ["高速度", "高精度", "存储程序和程序控制", "记忆力强"]}]}
{"classification": 1, "content": "第四媒体是指（）。", "code": "", "answer": ["B"], "explanation": "第四媒体是指网络媒体。", "source": "C1710", "subproblem": [{"content": "", "choice": ["报纸媒体", "网络媒体", "电视媒体", "广播媒体"]}]}
{"classification": 1, "content": "将高级语言程序设计语言源程序翻译成计算机可执行代码的软件称为（）。", "code": "", "answer": ["B"], "explanation": "将高级语言程序设计语言源程序翻译成计算机可执行代码的软件称为编译程序。", "source": "C1711", "subproblem": [{"content": "", "choice": ["汇编程序", "编译程序", "管理程序", "服务程序"]}]}
{"classification": 1, "content": "下面是有关计算机病毒的说法，其中（）不正确。", "code": "", "answer": ["D"], "explanation": "A、B、C均正确。", "source": "C1712", "subproblem": [{"content": "", "choice": ["计算机病毒有引导型病毒、文件型病毒、复合型病毒等", "计算机病毒中也有良性病毒", "计算机病毒实际上是一种计算机程序", "计算机病毒是由于程序的错误编制而产生的"]}]}
{"classification": 1, "content": "不同的计算机，其指令系统也不相同，这主要取决于（）。", "code": "", "answer": ["C"], "explanation": "不同的计算机，其指令系统也不相同，这主要取决于所用的CPU。", "source": "C1713", "subproblem": [{"content": "", "choice": ["所用的操作系统", "系统的总体结构", "所用的CPU", "所用额程序设计语言"]}]}
{"classification": 1, "content": "多媒体计算机是指（）。", "code": "", "answer": ["C"], "explanation": "多媒体计算机是指能处理多种媒体的计算机。", "source": "C1714", "subproblem": [{"content": "", "choice": ["具有多种外部设备的计算机", "能与多种电器连接的计算机", "能处理多种媒体的计算机", "借助多种媒体操作的计算机"]}]}
{"classification": 1, "content": "在微机中，bit的中文含义是（）。", "code": "", "answer": ["A"], "explanation": "在微机中，bit的中文含义是二进制位。", "source": "C1715", "subproblem": [{"content": "", "choice": ["二进制位", "双字", "字节", "字"]}]}
{"classification": 1, "content": "计算机中字节是常用单位，它的英文名字是（）。", "code": "", "answer": ["B"], "explanation": "计算机中字节是常用单位，它的英文名字是byte。", "source": "C1716", "subproblem": [{"content": "", "choice": ["Bit", "byte", "bout", "baut"]}]}
{"classification": 1, "content": "计算机存储和处理数据的基本单位是（）。", "code": "", "answer": ["B"], "explanation": "计算机存储和处理数据的基本单位是字节Byte。", "source": "C1717", "subproblem": [{"content": "", "choice": ["bit", "Byte", "GB", "KB"]}]}
{"classification": 1, "content": "“32位微型计算机”中的32是指（）。", "code": "", "answer": ["D"], "explanation": "“32位微型计算机”中的32是指机器字长。", "source": "C1718", "subproblem": [{"content": "", "choice": ["微机型号", "内存容量", "存储单位", "机器字长"]}]}
{"classification": 1, "content": "“64位微型计算机”中的64是指（）。", "code": "", "answer": ["D"], "explanation": "“64位微型计算机”中的64是指机器字长。", "source": "C1719", "subproblem": [{"content": "", "choice": ["微机型号", "内存容量", "存储单位", "机器字长"]}]}
{"classification": 1, "content": "控制面板的主要作用是（）。", "code": "", "answer": ["B"], "explanation": "控制面板的主要作用是设置系统配置。", "source": "C1720", "subproblem": [{"content": "", "choice": ["调整窗口", "设置系统配置", "管理应用程序", "设置高级语言"]}]}
{"classification": 1, "content": "计算机技术和（）技术相结合，出现了计算机网络。", "code": "", "answer": ["B"], "explanation": "计算机技术和通信技术相结合，出现了计算机网络。", "source": "C1721", "subproblem": [{"content": "", "choice": ["自动化", "通信", "信息", "电缆"]}]}
{"classification": 1, "content": "计算机网络的特点是（）。", "code": "", "answer": ["C"], "explanation": "计算机网络的特点是资源共享。", "source": "C1722", "subproblem": [{"content": "", "choice": ["运算速度快", "精度高", "资源共享", "内存容量大"]}]}
{"classification": 1, "content": "因特网上每台计算机都有一个规定的“地址”，这个“地址”被称为（）地址。", "code": "", "answer": ["B"], "explanation": "因特网上每台计算机都有一个规定的“地址”，这个“地址”被称为IP地址。", "source": "C1723", "subproblem": [{"content": "", "choice": ["TCP", "IP", "Web", "Html"]}]}
{"classification": 1, "content": "每台计算机必须知道对方的（）才能在Internet上与之通信。", "code": "", "answer": ["C"], "explanation": "每台计算机必须知道对方的IP地址才能在Internet上与之通信。", "source": "C1724", "subproblem": [{"content": "", "choice": ["电话号码", "主机号", "IP地址", "邮编与通信地址"]}]}
{"classification": 1, "content": "下列哪些计算机网络不是按覆盖地域划分的（）。", "code": "", "answer": ["D"], "explanation": "星型网不是按地域划分的，而是网络结构。", "source": "C1725", "subproblem": [{"content": "", "choice": ["局域网", "都市网", "广域网", "星型网"]}]}
{"classification": 1, "content": "Internet是（）类型网络。", "code": "", "answer": ["C"], "explanation": "Internet是广域网类型网络。", "source": "C1726", "subproblem": [{"content": "", "choice": ["局域网", "城域网", "广域网", "企业网"]}]}
{"classification": 1, "content": "Internet起源于（）。", "code": "", "answer": ["A"], "explanation": "Internet起源于美国。", "source": "C1727", "subproblem": [{"content": "", "choice": ["美国", "英国", "德国", "澳大利亚"]}]}
{"classification": 1, "content": "电子邮件到达时，如果并没有开机，那么邮件将（）。", "code": "", "answer": ["D"], "explanation": "电子邮件到达时，如果并没有开机，那么邮件将保存在服务商的E-mail服务器上。", "source": "C1728", "subproblem": [{"content": "", "choice": ["退回给发件人", "开机时对方重新发送", "该邮件丢失", "保存在服务商的E-mail服务器上"]}]}
{"classification": 1, "content": "互联网上的服务都是基于一种协议，www服务基于（）协议。", "code": "", "answer": ["C"], "explanation": "互联网上的服务都是基于一种协议，www服务基于HTTP协议。", "source": "C1729", "subproblem": [{"content": "", "choice": ["POP3", "SMTP", "HTTP", "TELNET"]}]}
